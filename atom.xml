<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Ascetic in the deadlock]]></title>
  <link href="https://sparkbye.github.io/myBlog/atom.xml" rel="self"/>
  <link href="https://sparkbye.github.io/myBlog/"/>
  <updated>2019-08-11T16:41:42+08:00</updated>
  <id>https://sparkbye.github.io/myBlog/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[Python常见的错误<十>]]></title>
    <link href="https://sparkbye.github.io/myBlog/15656215590319.html"/>
    <updated>2019-08-12T22:52:39+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15656215590319.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">常见错误10: 浮点与整除</h4>

<p>下面这段代码在Python2下输出结果将是什么？请解释。</p>

<pre><code class="language-python">def div1(x,y):
    print(&quot;%s/%s = %s&quot; % (x, y, x/y))
def div2(x,y):
    print(&quot;%s//%s = %s&quot; % (x, y, x//y))
div1(5,2)
div1(5.,2)
div2(5,2)
div2(5.,2.)
</code></pre>

<pre><code>5/2 = 2.5
5.0/2 = 2.5
5//2 = 2
5.0//2.0 = 2.0
</code></pre>

<p>在Python3下结果会有怎样的不同？<br/><br/>
在Python2中，上述代码输出将是<br/><br/>
5/2 = 2<br/><br/>
5.0/2 = 2.5<br/><br/>
5//2 = 2<br/><br/>
5.0//2.0 = 2.0  </p>

<p>默认情况下，Python 2 自动执行整形计算如果两者都是整数。因此,5/2 结果是2，而5./2结果是2.5。<br/><br/>
注意，在Python2中，你可以通过增加以下引用来覆写这个行为。  </p>

<pre><code class="language-python">from future import division
</code></pre>

<p>同时要注意的是，//操作符将总是执行整形除法，不管操作符的类型。这就是为什么即使在Python 2中5.0//2.0的结果是2.0。<br/><br/>
然而在Python3中，没有此类特性。例如，在两端都是整形的情况下，它不会执行整形除法。<br/><br/>
因此，在Python3中，将会是如下结果：<br/><br/>
5/2 = 2.5<br/><br/>
5.0/2 = 2.5<br/><br/>
5//2 = 2<br/><br/>
5.0//2.0 = 2.0  </p>

<p>注：在 Python 3 中，/ 操作符是做浮点除法，而 // 是做整除（即商没有余数，比如 10 // 3 其结果就为 3，余数会被截除掉，而 (-7) // 3 的结果却是 -3。这个算法与其它很多编程语言不一样，需要注意，它们的整除运算会向0的方向取值。而在 Python 2 中，/ 就是整除，即和 Python 3 中的 // 操作符一样）</p>

<pre><code class="language-python">
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python常见的错误<九>]]></title>
    <link href="https://sparkbye.github.io/myBlog/15655124741455.html"/>
    <updated>2019-08-11T16:34:34+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15655124741455.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">常见错误9: 误用__del__方法</h4>

<p>假设你有一个名为 calledmod.py 的文件：</p>

<pre><code class="language-python">import foo

class Bar(object):
           ...
    def __del__(self):
        foo.cleanup(self.myhandle)
</code></pre>

<p>并且有一个名为 another_mod.py 的文件：</p>

<pre><code class="language-python">import mod
mybar = mod.Bar()
</code></pre>

<p>你会得到一个 AttributeError 的异常。<br/><br/>
为什么呢？因为，正如这里所说<br/><br/>
<a href="https://mail.python.org/pipermail/python-bugs-list/2009-January/069209.html">https://mail.python.org/pipermail/python-bugs-list/2009-January/069209.html</a><br/><br/>
当解释器退出的时候，模块中的全局变量都被设置成了 None。所以，在上面这个例子中，当 <strong>del</strong> 被调用时，foo 已经被设置成了None。<br/><br/>
解决方法是使用 atexit.register() 代替。<br/><br/>
<a href="https://docs.python.org/2/library/atexit.html">https://docs.python.org/2/library/atexit.html</a><br/><br/>
用这种方式，当你的程序结束执行时（意思是正常退出），你注册的处理程序会在解释器退出之前执行。<br/><br/>
了解了这些，我们可以将上面 mod.py 的代码修改成下面的这样。</p>

<pre><code class="language-python">import foo
import atexit

def cleanup(handle):
    foo.cleanup(handle)


class Bar(object):
    def __init__(self):
        ...
        atexit.register(cleanup, self.myhandle)
</code></pre>

<p>这种实现方式提供了一个整洁并且可信赖的方法用来在程序退出之前做一些清理工作。很显然，它是由foo.cleanup 来决定对绑定在 self.myhandle 上对象做些什么处理工作的，但是这就是你想要的。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python常见的错误<八>]]></title>
    <link href="https://sparkbye.github.io/myBlog/15655124251876.html"/>
    <updated>2019-08-11T16:33:45+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15655124251876.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">常见错误8: 未能解决Python 2和Python 3之间的差异</h4>

<p>请看下面这个 filefoo.py:</p>

<pre><code class="language-python">import sys

def bar(i):
    if i == 1:
        raise KeyError(1)
    if i == 2:
        raise ValueError(2)

def bad():
    e = None
    try:
        bar(int(sys.argv[1]))
    except KeyError as e:
        print(&#39;key error&#39;)
    except ValueError as e:
        print(&#39;value error&#39;)
    print(e)

bad()
</code></pre>

<p>在Python 2中运行正常：</p>

<pre><code class="language-python">$ python foo.py 1
key error
1
$ python foo.py 2
value error
2
</code></pre>

<p>但是，现在让我们把它在Python 3中运行一下：</p>

<pre><code class="language-python">&gt;&gt;&gt; python3 foo.py 1
key error
Traceback (most recent call last):
  File &quot;foo.py&quot;, line 19, in &lt;module&gt;
    bad()
  File &quot;foo.py&quot;, line 17, in bad
    print(e)
UnboundLocalError: local variable &#39;e&#39; referenced before assignment
</code></pre>

<p>出什么问题了？ “问题”就是，在 Python 3 中，异常的对象在 except 代码块之外是不可见的。（这样做的原因是，它将保存一个对内存中堆栈帧的引用周期，直到垃圾回收器运行并且从内存中清除掉引用。了解更多技术细节请参考）</p>

<p><a href="https://docs.python.org/3/reference/compound_stmts.html#except">https://docs.python.org/3/reference/compound_stmts.html#except</a></p>

<p>一种解决办法是在 except 代码块的外部作用域中定义一个对异常对象的引用，以便访问。下面的例子使用了该方法，因此最后的代码可以在Python 2 和 Python 3中运行良好。</p>

<pre><code class="language-python">import sys

def bar(i):
    if i == 1:
        raise KeyError(1)
    if i == 2:
        raise ValueError(2)
        
def good():
    exception = None
    try:
        bar(int(sys.argv[1]))
    except KeyError as e:
        exception = e
        print(&#39;key error&#39;)
    except ValueError as e:
        exception = e
        print(&#39;value error&#39;)
    print(exception)

sys.argv.append(1)
good()
sys.argv.append(2)
good()
</code></pre>

<pre><code class="language-python">
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python常见的错误<七>]]></title>
    <link href="https://sparkbye.github.io/myBlog/15655123624150.html"/>
    <updated>2019-08-11T16:32:42+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15655123624150.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">常见错误7: 创建循环依赖模块</h4>

<p>让我们假设你有两个文件，a.py 和 b.py，他们之间相互引用，如下所示：</p>

<pre><code class="language-python">import b

def f():
    return b.x
print(f())
</code></pre>

<pre><code class="language-python">import a

x = 1
def g():
    print(a.f())
</code></pre>

<p>首先，让我们尝试引入 a.py：</p>

<pre><code class="language-python">import a
</code></pre>

<p>可以正常工作。这也许是你感到很奇怪。毕竟，我们确实在这里引入了一个循环依赖的模块，我们推测这样会出问题的，不是吗？<br/><br/>
答案就是在Python中，仅仅引入一个循环依赖的模块是没有问题的。如果一个模块已经被引入了，Python并不会去再次引入它。但是，根据每个模块要访问其他模块中的函数和变量位置的不同，就很可能会遇到问题。<br/><br/>
所以，回到我们这个例子，当我们引入 a.py 时，再引入 b.py 不会产生任何问题，因为当引入的时候，b.py 不需要 a.py 中定义任何东西。b.py 中唯一引用 a.py 中的东西是调用 a.f()。 但是那个调用是发生在g() 中的，并且 a.py 和 b.py 中都没有调用 g()。所以运行正常。<br/><br/>
但是，如果我们尝试去引入b.py 会发生什么呢？（在这之前不引入a.py），如下所示:</p>

<pre><code class="language-python">import b
</code></pre>

<p>啊哦。 出问题了！此处的问题是，在引入b.py的过程中，Python尝试去引入 a.py，但是a.py 要调用f()，而f() 有尝试去访问 b.x。但是此时 b.x 还没有被定义呢。所以发生了 AttributeError 异常。</p>

<p>至少，解决这个问题很简单，只需修改b.py，使其在g()中引入 a.py：</p>

<pre><code class="language-python">x = 1

def g():
    import a    # 只有当g()被调用的时候才会引入a
    print a.f()
</code></pre>

<p>现在，当我们再引入b，没有任何问题：</p>

<pre><code class="language-python">&gt;&gt;&gt; import b
&gt;&gt;&gt; b.g()
1    # Printed a first time since module &#39;a&#39; calls &#39;print f()&#39; at the end
1    # Printed a second time, this one is our call to &#39;g&#39;
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python常见的错误<六>]]></title>
    <link href="https://sparkbye.github.io/myBlog/15655122908336.html"/>
    <updated>2019-08-11T16:31:30+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15655122908336.html</id>
    <content type="html"><![CDATA[
<h5 id="toc_0">常见错误6: 不明白Python在闭包中是如何绑定变量的</h5>

<p>我们来看下面这个例子：</p>

<pre><code class="language-python">def create_multipliers():
    return [lambda x : i * x for i in range(5)]

for multiplier in create_multipliers():
    print(multiplier(2))
</code></pre>

<pre><code>8
8
8
8
8
</code></pre>

<p>你也许希望获得下面的输出结果：<br/><br/>
0<br/><br/>
2<br/><br/>
4<br/><br/>
6<br/><br/>
8<br/><br/>
惊讶吧!<br/><br/>
这之所以会发生是由于Python中的“后期绑定”行为，也叫做闭包的延迟绑定。<br/><br/>
<b>闭包中用到的变量只有在函数被调用的时候才会被赋值。</b><br/>
因此，当任何由create_multipliers()返回的函数被调用时，Python会在该函数被调用时的作用域中查找i对应的值。那时，不管返回的函数是否被调用，for循环已经完成，i被赋予了最终的值4。<br/><br/>
解决的办法有很多：</p>

<p>第一种办法是用Python的生成器：</p>

<pre><code class="language-python">def create_multipliers():
    for i in range(5): yield lambda x : i * x

for multiplier in create_multipliers():
    print(multiplier(2))
</code></pre>

<pre><code>0
2
4
6
8
</code></pre>

<p>第二种办法就是创造一个闭包，利用默认函数立即绑定。<br/><br/>
在这里，我们利用了默认参数来生成一个匿名的函数以便实现我们想要的结果。有人说这个方法很巧妙，有人说它难以理解，还有人讨厌这种做法。但是，如果你是一个 Python 开发者，理解这种行为很重要。</p>

<pre><code class="language-python">def create_multipliers():
    return [lambda x, i=i : i * x for i in range(5)]

for multiplier in create_multipliers():
    print(multiplier(2))
</code></pre>

<pre><code>0
2
4
6
8
</code></pre>

<p>还有种替代的方案是，使用偏函数：</p>

<pre><code class="language-python">from functools import partial
from operator import mul
def create_multipliers():
    return [partial(mul, i) for i in range(5)]

for multiplier in create_multipliers():
    print(multiplier(2))
</code></pre>

<pre><code>0
2
4
6
8
</code></pre>

<pre><code class="language-python">
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python常见的错误<五>]]></title>
    <link href="https://sparkbye.github.io/myBlog/15655122526636.html"/>
    <updated>2019-08-11T16:30:52+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15655122526636.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">常见错误5: 当迭代时修改一个列表（List）</h4>

<p>我们来看下面这个例子：</p>

<pre><code class="language-python">odd = lambda x : bool(x % 2)
numbers = [n for n in range(10)]
for i in range(len(numbers)):
     if odd(numbers[i]):
            del numbers[i]
</code></pre>

<pre><code>---------------------------------------------------------------------------

IndexError                                Traceback (most recent call last)

&lt;ipython-input-1-c259828f5d17&gt; in &lt;module&gt;
      2 numbers = [n for n in range(10)]
      3 for i in range(len(numbers)):
----&gt; 4      if odd(numbers[i]):
      5             del numbers[i]


IndexError: list index out of range
</code></pre>

<p>当迭代的时候，从一个 列表或者数组中删除元素，对于任何有经验的开发者来说，这是一个众所周知的错误。尽管上面的例子非常明显，但是许多高级开发者在更复杂的代码中也并非是故意而为之的。<br/>
幸运的是，Python包含大量简洁优雅的编程范例，若使用得当，能大大简化和精炼代码。<br/><br/>
这样的好处是能得到更简化和更精简的代码，能更好的避免程序中出现当迭代时修改一个列表这样的bug。一个这样的范例是递推式列表（list comprehensions）。<br/><br/>
<a href="https://docs.python.org/2/tutorial/datastructures.html#tut-listcomps">https://docs.python.org/2/tutorial/datastructures.html#tut-listcomps</a><br/><br/>
而且，递推式列表（list comprehensions）针对这个问题是特别有用的，通过更改上文中的实现，得到一段极佳的代码：</p>

<pre><code class="language-python">odd = lambda x : bool(x % 2)
numbers = [n for n in range(10)]
numbers[:] = [n for n in numbers if not odd(n)]  # ahh, the beauty of it all
numbers
</code></pre>

<pre><code>[0, 2, 4, 6, 8]
</code></pre>

<pre><code class="language-python">
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python常见的错误<四>]]></title>
    <link href="https://sparkbye.github.io/myBlog/15655122052917.html"/>
    <updated>2019-08-11T16:30:05+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15655122052917.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">常见错误4: 不理解Python的作用域</h4>

<p>Python是基于 LEGB 来进行作用于解析的, LEGB<br/><br/>
是 Local, Enclosing, Global,Built-in 的缩写。看起来“见文知意”，对吗？实际上，在Python中还有一些需要注意的地方，先看下面一段代码：</p>

<pre><code class="language-python">x = 10
def foo():
    x += 1
    print(x)

foo()
</code></pre>

<pre><code>---------------------------------------------------------------------------

UnboundLocalError                         Traceback (most recent call last)

&lt;ipython-input-1-ec96c7a5b5d8&gt; in &lt;module&gt;
      4     print(x)
      5 
----&gt; 6 foo()


&lt;ipython-input-1-ec96c7a5b5d8&gt; in foo()
      1 x = 10
      2 def foo():
----&gt; 3     x += 1
      4     print(x)
      5 


UnboundLocalError: local variable &#39;x&#39; referenced before assignment
</code></pre>

<p>这里出什么问题了？<br/><br/>
上面的问题之所以会发生是因为当你给作用域中的一个变量赋值时，Python 会自动的把它当做是当前作用域的局部变量，从而会隐藏外部作用域中的同名变量。<br/><br/>
很多人会感到很吃惊，当他们给之前可以正常运行的代码的函数体的某个地方添加了一句赋值语句之后就得到了一个 UnboundLocalError 的错误。<br/><br/>
尤其是当开发者使用 lists 时，这个问题就更加常见。请看下面这个例子：</p>

<pre><code class="language-python">lst = [1, 2, 3]
def foo_1():
    lst.append(5)

foo_1()
lst
</code></pre>

<pre><code>[1, 2, 3, 5]
</code></pre>

<pre><code class="language-python">def foo_2():
    lst += [5]

foo_2()
</code></pre>

<pre><code>---------------------------------------------------------------------------

UnboundLocalError                         Traceback (most recent call last)

&lt;ipython-input-5-4f369a1ee364&gt; in &lt;module&gt;
      2     lst += [5]
      3 
----&gt; 4 foo_2()


&lt;ipython-input-5-4f369a1ee364&gt; in foo_2()
      1 def foo_2():
----&gt; 2     lst += [5]
      3 
      4 foo_2()


UnboundLocalError: local variable &#39;lst&#39; referenced before assignment
</code></pre>

<p>嗯？为什么 foo2 报错，而foo1没有问题呢？<br/><br/>
原因和之前那个例子的一样，不过更加令人难以捉摸。foo1 没有对 lst 进行赋值操作，而 foo2 做了。<br/><br/>
要知道， lst += [5] 是 lst = lst + [5] 的缩写，我们试图对 lst 进行赋值操作（Python把他当成了局部变量）。<br/><br/>
此外，我们对 lst 进行的赋值操作是基于 lst 自身（这再一次被Python当成了局部变量），但此时还未定义。因此出错！</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python常见的错误<三>]]></title>
    <link href="https://sparkbye.github.io/myBlog/15655121732301.html"/>
    <updated>2019-08-11T16:29:33+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15655121732301.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">常见错误3: 为 except 指定错误的参数</h4>

<p>我们来看下面这个例子：</p>

<pre><code class="language-python">try:
    l = [&quot;a&quot;, &quot;b&quot;]
    int(l[2])
except ValueError, IndexError:
    pass
</code></pre>

<pre><code>  File &quot;&lt;ipython-input-2-4f54e4adb7ee&gt;&quot;, line 4
    except ValueError, IndexError:
                     ^
SyntaxError: invalid syntax
</code></pre>

<p>这里的问题在于 except 语句并不接受以这种方式指定的异常列表。相反，在Python 2.x中，使用语法 except Exception, e 是将一个异常对象绑定到第二个可选参数（在这个例子中是 e）上，以便在后面使用。所以，在上面这个例子中，IndexError 这个异常并不是被except语句捕捉到的，而是被绑定到一个名叫 IndexError的参数上时引发的。<br/><br/>
在一个except语句中捕获多个异常的正确做法是将第一个参数指定为一个含有所有要捕获异常的元组。并且，为了代码的可移植性，要使用as关键词，因为Python 2 和Python 3都支持这种语法：</p>

<pre><code class="language-python">try:
    l = [&quot;a&quot;, &quot;b&quot;]
    int(l[2])
except (ValueError, IndexError) as e:
    pass
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python常见的错误<二>]]></title>
    <link href="https://sparkbye.github.io/myBlog/15655120913106.html"/>
    <updated>2019-08-11T16:28:11+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15655120913106.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">常见错误2: 错误地使用类变量</h4>

<p>我们来看下面这个例子：</p>

<pre><code class="language-python">class A(object):
    x = 1

class B(A):
    pass

class C(A):
    pass

print(A.x, B.x, C.x)
B.x = 2
print(A.x, B.x, C.x)
A.x = 3
print(A.x, B.x, C.x)
</code></pre>

<pre><code>1 1 1
1 2 1
3 2 3
</code></pre>

<p>WTF?? 我们只改了A.x，为什么C.x也改了?<br/><br/>
在Python中，<b>类变量在内部当做字典来处理，其遵循常被引用的方法解析顺序（MRO）</b>。<br/><br/>
一个变量名如果没有在当前类下的字典中被发现，则会在更高级的类（如它的父类）中尽心搜索直到引用的变量名被找到。（如果引用变量名在自身类和更高级类中没有找到，将会引发一个属性错误）。<br/><br/>
所以在上面的代码中，由于class C中的x属性没有找到，它会向上找它的基类（尽管Python支持多重继承，但上面的例子中只有A）。<br/><br/>
如果它的任何一个子类被覆写了值（例如说，当我们执行语句B.x = 2）,这个值只在子类中进行了修改。所以第二个打印语句输出结果是1 2 1。<br/><br/>
如果这个值在父类中进行了修改，（例如说，当我们执行语句A.x = 3）,这个改变将会影响那些还没有覆写子类的值（在这个例子中就是C），所以第三打印语句输出结果是3 2 3。换句话说，class C中没有它自己的x属性，其独立于A。因此，C.x事实上是A.x的引用。  </p>

<p><img src="./jupyter_logo.png", width=320, heigth=240></p>

<pre><code class="language-python">
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python常见的错误<一>]]></title>
    <link href="https://sparkbye.github.io/myBlog/15654471089883.html"/>
    <updated>2019-08-10T22:25:08+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15654471089883.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">常见错误1: 滥用表达式作为函数参数的默认值</h4>

<p>Python允许为函数的参数提供默认的可选值。尽管这是语言的一大特色，但是它可能会导致一些易变默认值的混乱。<br/><br/>
一个常见的错误是认为函数每次不提供可选参数调用时，会将可选参数将设置为默认指定值。例如下面这段代码：</p>

<pre><code class="language-python">def extendList(val, list=[]):
    list.append(val)
    return list

list1 = extendList(10)
list2 = extendList(123,[])
list3 = extendList(&#39;a&#39;)

print(&quot;list1 = %s&quot; % list1)
print(&quot;list2 = %s&quot; % list2)
print(&quot;list3 = %s&quot; % list3)
</code></pre>

<pre><code>list1 = [10, &#39;a&#39;]
list2 = [123]
list3 = [10, &#39;a&#39;]
</code></pre>

<p>很多人都会误认为list1=[10]，list3=[‘a’]，因为他们以为每次extendList被调用时，列表参数的默认值都将被设置为[]。<br/><br/>
但实际上的情况是，<b> 函数参数的默认列表只在函数被定义的那一刻创建一次。</b><br/><br/>
当extendList被没有指定特定参数list调用时，这组list的值随后将被使用。这是因为<u>带有默认参数的表达式在函数被定义的时候被计算，不是在调用的时候被计算。</u><br/><br/>
因此list1和list3是在同一个默认列表上进行操作（计算）的。<br/><br/>
而list2是在一个分离的列表上进行操作（计算）的。（通过传递一个自有的空列表作为列表参数的数值）。<br/>
extendList的定义可以作如下修改:</p>

<pre><code class="language-python">def extendList_2(val, list=None):
    if list is None:
        list = []
    list.append(val)
    return list

list1 = extendList_2(10)
list2 = extendList_2(123,[])
list3 = extendList_2(&#39;a&#39;)

print(&quot;list1 = %s&quot; % list1)
print(&quot;list2 = %s&quot; % list2)
print(&quot;list3 = %s&quot; % list3)
</code></pre>

<pre><code>list1 = [10]
list2 = [123]
list3 = [&#39;a&#39;]
</code></pre>

<p>下面dis库是python(默认的CPython)自带的一个库,可以用来分析字节码。</p>

<pre><code class="language-python">import dis
dis.dis(extendList)
</code></pre>

<pre><code>  2           0 LOAD_FAST                1 (list)
              2 LOAD_METHOD              0 (append)
              4 LOAD_FAST                0 (val)
              6 CALL_METHOD              1
              8 POP_TOP

  3          10 LOAD_FAST                1 (list)
             12 RETURN_VALUE
</code></pre>

<p><img src="./jupyter_logo.png", width=320, heigth=240></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python 陷阱与缺陷列表]]></title>
    <link href="https://sparkbye.github.io/myBlog/15211187332796.html"/>
    <updated>2018-03-15T20:58:53+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15211187332796.html</id>
    <content type="html"><![CDATA[
<p>我个人对陷阱的定义是这样的：代码看起来可以工作，但不是以你“想当然“”的方式。如果一段代码直接出错，抛出了异常，我不认为这是陷阱。比如，Python程序员应该都遇到过的“UnboundLocalError”, 示例：</p>

<pre><code class="language-python">&gt;&gt;&gt; a=1
&gt;&gt;&gt; def func():
...     a+=1
...     print a
...
&gt;&gt;&gt; func()
Traceback (most recent call last):
File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
File &quot;&lt;stdin&gt;&quot;, line 2, in func
UnboundLocalError: local variable &#39;a&#39; referenced before assignment
</code></pre>

<p>&lt;-朕的朱批 -&gt; 这是因为在函数内部对变量赋值进行修改后，该变量就会被Python解释器认为是局部变量而非全局变量，当程序执行到a+=1的时候，因为这条语句是给a赋值，所以a成为了局部变量，那么在执行print a的时候，因为a这个局部变量还没有定义，自然就会抛出这样的错误。只要去掉a+=1，或者加关键字global就不会报错了</p>

<p>对于“UnboundLocalError”,还有更高级的版本：</p>

<pre><code class="language-python">import random
 
def func(ok):
    if ok:
        a = random.random()
    else:
        import random
        a = random.randint(1, 10)
    return a
 
func(True)# UnboundLocalError: local variable &#39;random&#39; referenced before assignment
</code></pre>

<p>可能对于很多python新手来说，这个Error让人摸不着头脑。但我认为这不算陷阱，因为这段代码一定会报错，而不是默默的以错误的方式运行。不怕真小人，就怕伪君子。我认为缺陷就好比伪君子。</p>

<p>那么Python中哪些真正算得上陷阱呢？</p>

<p><strong>第一：以mutable对象作为默认参数</strong></p>

<p>这个估计是最广为人知的了，Python和其他很多语言一样，提供了默认参数，默认参数确实是个好东西，可以让函数调用者忽略一些细节（比如GUI编程，Tkinter，QT），对于lambda表达式也非常有用。但是如果使用了可变对象作为默认参数，那么事情就不那么愉快了。</p>

<pre><code class="language-python">&gt;&gt;&gt; def f(lst = []):
...     lst.append(1)
...     return lst
...
&gt;&gt;&gt; f()
[1]
&gt;&gt;&gt; f()
[1, 1]
</code></pre>

<p>惊喜不惊喜？！究其原因，python中一切都是对象，函数也不列外，默认参数只是函数的一个属性。而默认参数在函数定义的时候已经求值了。<br/>
<code>Default parameter values are evaluated when the function definition is executed.</code><br/>
&lt;-朕的朱批 -&gt; lst是可变对象，默认参数在函数定义的时候已经求值了</p>

<p>stackoverflow上有一个更适当的例子来说明默认参数是在定义的时候求值，而不是调用的时候。</p>

<pre><code class="language-python">&gt;&gt;&gt; import time
&gt;&gt;&gt; def report(when=time.time()):
... return when
...
&gt;&gt;&gt; report()
1500113234.487932
&gt;&gt;&gt; report()
1500113234.487932
</code></pre>

<p>python docoment 给出了标准的解决办法：<br/>
<code>A way around this is to use None as the default, and explicitly test for it in the body of the function</code></p>

<pre><code class="language-python">&gt;&gt;&gt; def report(when=None):
...  if when is None:
...  when = time.time()
... return when
...
&gt;&gt;&gt; report()
1500113446.746997
&gt;&gt;&gt; report()
1500113448.552873
</code></pre>

<p><strong>第二: x += y vs x = x + y</strong><br/>
一般来说，二者是等价的，至少看起来是等价的（这也是陷阱的定义 — 看起来都OK，但不一定正确）。</p>

<pre><code class="language-python">&gt;&gt;&gt; x=1;x += 1;print x
2 
&gt;&gt;&gt; x=1;x = x+1;print x
2
&gt;&gt;&gt; x=[1];x+=[2];print x
[1, 2]
&gt;&gt;&gt; x=[1];x=x+[2];print x
[1, 2]
</code></pre>

<p>呃，被光速打脸了？</p>

<pre><code class="language-python">&gt;&gt;&gt; x=[1];print id(x);x=x+[2];print id(x) 
4357132800
4357132728
&gt;&gt;&gt; x=[1];print id(x);x+=[2];print id(x)
4357132800
4357132800
</code></pre>

<p>前者x指向一个新的对象，后者x在原来的对象是修改，当然，那种效果是正确的取决于应用场景。至少，得知道，二者有时候并不一样</p>

<p>&lt;-朕的朱批 -&gt; 我们可以通过dis来检查下这两者的区别;</p>

<pre><code class="language-python">import dis

def foo(x, y):
    x += y

def foo2(x, y):
    x = x + y

print dis.dis(foo)
print dis.dis(foo2)
</code></pre>

<p>输出结果如下：</p>

<pre><code class="language-python">74            0 LOAD_FAST                0 (x)
              3 LOAD_FAST                1 (y)
              6 INPLACE_ADD         
              7 STORE_FAST               0 (x)
             10 LOAD_CONST               0 (None)
             13 RETURN_VALUE             None

77            0 LOAD_FAST                0 (x)
              3 LOAD_FAST                1 (y)
              6 BINARY_ADD          
              7 STORE_FAST               0 (x)
             10 LOAD_CONST               0 (None)
             13 RETURN_VALUE             None
</code></pre>

<p>分别对应INPLACE_ADD和BINARY_ADD<br/>
更多内容可以参考：<br/>
<a href="https://stackoverflow.com/questions/15376509/when-is-i-x-different-from-i-i-x-in-python">https://stackoverflow.com/questions/15376509/when-is-i-x-different-from-i-i-x-in-python</a></p>

<p><strong>第三，神奇的小括号–()</strong><br/>
小括号（parenthese）在各种编程语言中都有广泛的应用，python中，小括号还能表示元组（tuple）这一数据类型, 元组是immutable的序列。</p>

<pre><code class="language-python">&gt;&gt;&gt; a = (1, 2)
&gt;&gt;&gt; type(a)
&lt;type &#39;tuple&#39;&gt;
&gt;&gt;&gt; type(())
&lt;type &#39;tuple&#39;&gt;
</code></pre>

<p>但如果只有一个元素呢</p>

<pre><code class="language-python">&gt;&gt;&gt; a=(1)
&gt;&gt;&gt; type(a)
&lt;type &#39;int&#39;&gt;
</code></pre>

<p>神奇不神奇，如果要表示只有一个元素的元组，正确的姿势是：</p>

<pre><code class="language-python">&gt;&gt;&gt; a=(1,)
&gt;&gt;&gt; type(a)
&lt;type &#39;int&#39;&gt;
</code></pre>

<p><strong>第四：生成一个元素是列表的列表</strong><br/>
这个有点像二维数组，当然生成一个元素是字典的列表也是可以的，更通俗的说，生成一个元素是可变对象的序列<br/>
很简单嘛：</p>

<pre><code class="language-python">&gt;&gt;&gt; a= [[]] * 10
&gt;&gt;&gt; a
[[], [], [], [], [], [], [], [], [], []]
&gt;&gt;&gt; a[0].append(10)
&gt;&gt;&gt; a[0] 
[10]
</code></pre>

<p>看起来很不错，简单明了，but</p>

<pre><code class="language-python">&gt;&gt;&gt; a[1]
[10]
&gt;&gt;&gt; a
[[10], [10], [10], [10], [10], [10], [10], [10], [10], [10]]
</code></pre>

<p>我猜，这应该不是你预期的结果吧，究其原因，还是因为python中list是可变对象，上述的写法大家都指向的同一个可变对象，正确的姿势</p>

<pre><code class="language-python">&gt;&gt;&gt; a = [[] for _ in xrange(10)]
&gt;&gt;&gt; a[0].append(10)
&gt;&gt;&gt; a
[[10], [], [], [], [], [], [], [], [], []]
</code></pre>

<p><strong>第五，在访问列表的时候，修改列表</strong><br/>
列表（list）在python中使用非常广泛，当然经常会在访问列表的时候增加或者删除一些元素。比如，下面这个函数，试图删掉列表中为3的倍数的元素：</p>

<pre><code class="language-python">&gt;&gt;&gt; def modify_lst(lst):
... for idx, elem in enumerate(lst):
... if elem % 3 == 0:
... del lst[idx]
</code></pre>

<p>测试一下，</p>

<pre><code class="language-python">&gt;&gt;&gt; lst = [1,2,3,4,5,6]
&gt;&gt;&gt; modify_lst(lst)
&gt;&gt;&gt; lst
[1, 2, 4, 5]
</code></pre>

<p>好像没什么错，不过这只是运气好</p>

<pre><code class="language-python">&gt;&gt;&gt; lst = [1,2,3,6,5,4]
&gt;&gt;&gt; modify_lst(lst)
&gt;&gt;&gt; lst
[1, 2, 6, 5, 4]
</code></pre>

<p>上面的例子中，6这个元素就没有被删除。如果在modify_lst函数中print idx， item就可以发现端倪：lst在变短，但idx是递增的，所以在上面出错的例子中，当3被删除之后，6变成了lst的第2个元素（从0开始）。在C++中，如果遍历容器的时候用迭代器删除元素，也会有同样的问题。<br/>
如果逻辑比较简单，使用list comprehension是不错的注意<br/>
&lt;-朕的朱批 -&gt; 不用不知道，一用吓一跳啊<br/>
修改方法很简单：</p>

<pre><code class="language-python">def mod_list(lst):
    new_lst = []
    for elem in lst:
        if elem % 3 != 0:
            new_lst.append(elem)
    return new_lst

lst = [1, 2, 3, 4, 5, 6]
s = mod_list(lst)
print s

lst = [1, 2, 3, 6, 5, 4]
s = mod_list(lst)
print s
</code></pre>

<p><strong>第六，闭包与lambda</strong><br/>
这个也是老生长谈的例子，在其他语言也有类似的情况。先看一个例子:</p>

<pre><code class="language-python">&gt;&gt;&gt; def create_multipliers():
...  return [lambda x:i*x for i in range(5)]
...
&gt;&gt;&gt; for multiplier in create_multipliers():
... print multiplier(2)
...
</code></pre>

<p>create_multipliers函数的返回值时一个列表，列表的每一个元素都是一个函数 －－ 将输入参数x乘以一个倍数i的函数。预期的结果时0，2，4，6，8. 但结果是5个8，意外不意外。</p>

<p>由于出现这个陷阱的时候经常使用了lambda，所以可能会认为是lambda的问题，但lambda表示不愿意背这个锅。问题的本质在与python中的属性查找规则，LEGB（local，enclousing，global，bulitin），在上面的例子中，i就是在闭包作用域（enclousing），而Python的闭包是迟绑定，这意味着闭包中用到的变量的值，是在内部函数被调用时查询得到的。<br/>
解决办法也很简单，那就是变闭包作用域为局部作用域。</p>

<pre><code class="language-python">&gt;&gt;&gt; def create_multipliers():
... return [lambda x, i = i:i*x for i in range(5)]
...
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[高效的 itertools 模块]]></title>
    <link href="https://sparkbye.github.io/myBlog/15211176555242.html"/>
    <updated>2018-03-15T20:40:55+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15211176555242.html</id>
    <content type="html"><![CDATA[
<p>我们知道，迭代器的特点是：惰性求值（Lazy evaluation），即只有当迭代至某个值时，它才会被计算，这个特点使得迭代器特别适合于遍历大文件或无限集合等，因为我们不用一次性将它们存储在内存中。</p>

<p>&lt;-朕的朱批 -&gt; 还记得enumerate犯下的错误吗？</p>

<p>Python 内置的 itertools 模块包含了一系列用来产生不同类型迭代器的函数或类，这些函数的返回都是一个迭代器，我们可以通过 for 循环来遍历取值，也可以使用 next() 来取值。<br/>
itertools 模块提供的迭代器函数有以下几种类型：</p>

<ul>
<li>无限迭代器：生成一个无限序列，比如自然数序列 1, 2, 3, 4, ...；</li>
<li>有限迭代器：接收一个或多个序列（sequence）作为参数，进行组合、分组和过滤等；</li>
<li>组合生成器：序列的排列、组合，求序列的笛卡儿积等；</li>
</ul>

<p>无限迭代器</p>

<p>itertools 模块提供了三个函数（事实上，它们是类）用于生成一个无限序列迭代器：</p>

<ul>
<li>count(firstval=0, step=1)创建一个从 firstval (默认值为 0) 开始，以 step (默认值为 1) 为步长的的无限整数迭代器</li>
<li>cycle(iterable)对 iterable 中的元素反复执行循环，返回迭代器</li>
<li>repeat(object [,times]反复生成 object，如果给定 times，则重复次数为 times，否则为无限
下面，让我们看看一些例子。</li>
</ul>

<p><strong>count</strong><br/>
count() 接收两个参数，第一个参数指定开始值，默认为 0，第二个参数指定步长，默认为 1：</p>

<pre><code class="language-python">&gt;&gt;&gt; import itertools
&gt;&gt;&gt;
&gt;&gt;&gt; nums = itertools.count()
&gt;&gt;&gt; for i in nums:
...     if i &gt; 6:
...         break
...     print i
...
0
1
2
3
4
5
6
&gt;&gt;&gt; nums = itertools.count(10, 2)    # 指定开始值和步长
&gt;&gt;&gt; for i in nums:
...     if i &gt; 20:
...         break
...     print i
...
10
12
14
16
18
20
</code></pre>

<p><strong>cycle</strong><br/>
cycle() 用于对 iterable 中的元素反复执行循环：</p>

<pre><code class="language-python">&gt;&gt;&gt; import itertools
&gt;&gt;&gt;
&gt;&gt;&gt; cycle_strings = itertools.cycle(&#39;ABC&#39;)
&gt;&gt;&gt; i = 1
&gt;&gt;&gt; for string in cycle_strings:
...     if i == 10:
...         break
...     print i, string
...     i += 1
...
1 A
2 B
3 C
4 A
5 B
6 C
7 A
8 B
9 C
</code></pre>

<p><strong>repeat</strong><br/>
repeat() 用于反复生成一个 object：</p>

<pre><code class="language-python">&gt;&gt;&gt; import itertools
&gt;&gt;&gt;
&gt;&gt;&gt; for item in itertools.repeat(&#39;hello world&#39;, 3):
...     print item
...
hello world
hello world
hello world
&gt;&gt;&gt;
&gt;&gt;&gt; for item in itertools.repeat([1, 2, 3, 4], 3):
...     print item
...
[1, 2, 3, 4]
[1, 2, 3, 4]
[1, 2, 3, 4]
</code></pre>

<p><strong>有限迭代器</strong><br/>
itertools 模块提供了多个函数（类），接收一个或多个迭代对象作为参数，对它们进行组合、分组和过滤等：</p>

<ul>
<li>chain()</li>
<li>compress()</li>
<li>dropwhile()</li>
<li>groupby()</li>
<li>ifilter()</li>
<li>ifilterfalse()</li>
<li>islice()</li>
<li>imap()</li>
<li>starmap()</li>
<li>tee()</li>
<li>takewhile()</li>
<li>izip()</li>
<li>izip_longest()</li>
</ul>

<p><strong>chain</strong><br/>
chain 的使用形式如下：<br/>
<code>chain(iterable1, iterable2, iterable3, ...)</code><br/>
chain 接收多个可迭代对象作为参数，将它们『连接』起来，作为一个新的迭代器返回。</p>

<pre><code class="language-python">&gt;&gt;&gt; from itertools import chain
&gt;&gt;&gt;
&gt;&gt;&gt; for item in chain([1, 2, 3], [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]):
...     print item
...
1
2
3
a
b
c
</code></pre>

<p>chain 还有一个常见的用法：<br/>
<code>chain.from_iterable(iterable)</code><br/>
接收一个可迭代对象作为参数，返回一个迭代器：</p>

<pre><code class="language-python">&gt;&gt;&gt; from itertools import chain
&gt;&gt;&gt;
&gt;&gt;&gt; string = chain.from_iterable(&#39;ABCD&#39;)
&gt;&gt;&gt; string.next()
&#39;A&#39;
</code></pre>

<p><strong>compress</strong><br/>
compress 的使用形式如下：<br/>
<code>compress(data, selectors)</code><br/>
compress 可用于对数据进行筛选，当 selectors 的某个元素为 true 时，则保留 data 对应位置的元素，否则去除：</p>

<pre><code class="language-python">&gt;&gt;&gt; from itertools import compress
&gt;&gt;&gt;
&gt;&gt;&gt; list(compress(&#39;ABCDEF&#39;, [1, 1, 0, 1, 0, 1]))
[&#39;A&#39;, &#39;B&#39;, &#39;D&#39;, &#39;F&#39;]
&gt;&gt;&gt; list(compress(&#39;ABCDEF&#39;, [1, 1, 0, 1]))
[&#39;A&#39;, &#39;B&#39;, &#39;D&#39;]
&gt;&gt;&gt; list(compress(&#39;ABCDEF&#39;, [True, False, True]))
[&#39;A&#39;, &#39;C&#39;]
</code></pre>

<p><strong>dropwhile</strong><br/>
dropwhile 的使用形式如下：<br/>
<code>dropwhile(predicate, iterable)</code><br/>
其中，predicate 是函数，iterable 是可迭代对象。对于 iterable 中的元素，如果 predicate(item) 为 true，则丢弃该元素，否则返回该项及所有后续项。<br/>
&lt;-朕的朱批 -&gt; predicate 断言，断定。 注意其返回项是丢弃元素判定失败后的后续项</p>

<pre><code class="language-python">&gt;&gt;&gt; from itertools import dropwhile
&gt;&gt;&gt;
&gt;&gt;&gt; list(dropwhile(lambda x: x &lt; 5, [1, 3, 6, 2, 1]))
[6, 2, 1]
&gt;&gt;&gt;
&gt;&gt;&gt; list(dropwhile(lambda x: x &gt; 3, [2, 1, 6, 5, 4]))
[2, 1, 6, 5, 4]
</code></pre>

<p><strong>groupby</strong><br/>
groupby 用于对序列进行分组，它的使用形式如下：<br/>
<code>groupby(iterable[, keyfunc])</code><br/>
其中，iterable 是一个可迭代对象，keyfunc 是分组函数，用于对 iterable 的连续项进行分组，如果不指定，则默认对 iterable 中的连续相同项进行分组，返回一个 (key, sub-iterator) 的迭代器。</p>

<pre><code class="language-python">&gt;&gt;&gt; from itertools import groupby
&gt;&gt;&gt;
&gt;&gt;&gt; for key, value_iter in groupby(&#39;aaabbbaaccd&#39;):
...     print key, &#39;:&#39;, list(value_iter)
...
a : [&#39;a&#39;, &#39;a&#39;, &#39;a&#39;]
b : [&#39;b&#39;, &#39;b&#39;, &#39;b&#39;]
a : [&#39;a&#39;, &#39;a&#39;]
c : [&#39;c&#39;, &#39;c&#39;]
d : [&#39;d&#39;]
&gt;&gt;&gt;
&gt;&gt;&gt; data = [&#39;a&#39;, &#39;bb&#39;, &#39;ccc&#39;, &#39;dd&#39;, &#39;eee&#39;, &#39;f&#39;]
&gt;&gt;&gt; for key, value_iter in groupby(data, len):    # 使用 len 函数作为分组函数
...     print key, &#39;:&#39;, list(value_iter)
...
1 : [&#39;a&#39;]
2 : [&#39;bb&#39;]
3 : [&#39;ccc&#39;]
2 : [&#39;dd&#39;]
3 : [&#39;eee&#39;]
1 : [&#39;f&#39;]
&gt;&gt;&gt;
&gt;&gt;&gt; data = [&#39;a&#39;, &#39;bb&#39;, &#39;cc&#39;, &#39;ddd&#39;, &#39;eee&#39;, &#39;f&#39;]
&gt;&gt;&gt; for key, value_iter in groupby(data, len):
...     print key, &#39;:&#39;, list(value_iter)
...
1 : [&#39;a&#39;]
2 : [&#39;bb&#39;, &#39;cc&#39;]
3 : [&#39;ddd&#39;, &#39;eee&#39;]
1 : [&#39;f&#39;]
</code></pre>

<p><strong>ifilter</strong><br/>
ifilter 的使用形式如下：<br/>
<code>ifilter(function or None, sequence)</code><br/>
将 iterable 中 function(item) 为 True 的元素组成一个迭代器返回，如果 function 是 None，则返回 iterable 中所有计算为 True 的项。</p>

<pre><code class="language-python">&gt;&gt;&gt; from itertools import ifilter
&gt;&gt;&gt;
&gt;&gt;&gt; list(ifilter(lambda x: x &lt; 6, range(10)))
[0, 1, 2, 3, 4, 5]
&gt;&gt;&gt;
&gt;&gt;&gt; list(ifilter(None, [0, 1, 2, 0, 3, 4]))
[1, 2, 3, 4]
</code></pre>

<p><strong>ifilterfalse</strong><br/>
ifilterfalse 的使用形式和 ifilter 类似，它将 iterable 中 function(item) 为 False 的元素组成一个迭代器返回，如果 function 是 None，则返回 iterable 中所有计算为 False 的项。</p>

<pre><code class="language-python">&gt;&gt;&gt; from itertools import ifilterfalse
&gt;&gt;&gt;
&gt;&gt;&gt; list(ifilterfalse(lambda x: x &lt; 6, range(10)))
[6, 7, 8, 9]
&gt;&gt;&gt;
&gt;&gt;&gt; list(ifilter(None, [0, 1, 2, 0, 3, 4]))
[0, 0]
</code></pre>

<p><strong>islice</strong><br/>
islice 是切片选择，它的使用形式如下：<br/>
<code>islice(iterable, [start,] stop [, step])</code><br/>
其中，iterable 是可迭代对象，start 是开始索引，stop 是结束索引，step 是步长，start 和 step 可选。</p>

<pre><code class="language-python">&gt;&gt;&gt; from itertools import count, islice
&gt;&gt;&gt;
&gt;&gt;&gt; list(islice([10, 6, 2, 8, 1, 3, 9], 5))
[10, 6, 2, 8, 1]
&gt;&gt;&gt;
&gt;&gt;&gt; list(islice(count(), 6))
[0, 1, 2, 3, 4, 5]
&gt;&gt;&gt;
&gt;&gt;&gt; list(islice(count(), 3, 10))
[3, 4, 5, 6, 7, 8, 9]
&gt;&gt;&gt; list(islice(count(), 3, 10 ,2))
[3, 5, 7, 9]
</code></pre>

<p>&lt;-朕的朱批 -&gt;似乎没啥用<br/>
<strong>imap</strong><br/>
imap 类似 map 操作，它的使用形式如下：<br/>
<code>imap(func, iter1, iter2, iter3, ...)</code><br/>
imap 返回一个迭代器，元素为 func(i1, i2, i3, ...)，i1，i2 等分别来源于 iter, iter2。</p>

<pre><code class="language-python">&gt;&gt;&gt; from itertools import imap
&gt;&gt;&gt;
&gt;&gt;&gt; imap(str, [1, 2, 3, 4])
&lt;itertools.imap object at 0x10556d050&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; list(imap(str, [1, 2, 3, 4]))
[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;]
&gt;&gt;&gt;
&gt;&gt;&gt; list(imap(pow, [2, 3, 10], [4, 2, 3]))
[16, 9, 1000]
</code></pre>

<p><strong>tee</strong><br/>
tee 的使用形式如下：<br/>
<code>tee(iterable [,n])</code><br/>
tee 用于从 iterable 创建 n 个独立的迭代器，以元组的形式返回，n 的默认值是 2。</p>

<pre><code class="language-python">&gt;&gt;&gt; from itertools import tee
&gt;&gt;&gt;
&gt;&gt;&gt; tee(&#39;abcd&#39;)   # n 默认为 2，创建两个独立的迭代器
(&lt;itertools.tee object at 0x1049957e8&gt;, &lt;itertools.tee object at 0x104995878&gt;)
&gt;&gt;&gt;
&gt;&gt;&gt; iter1, iter2 = tee(&#39;abcde&#39;)
&gt;&gt;&gt; list(iter1)
[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]
&gt;&gt;&gt; list(iter2)
[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]
&gt;&gt;&gt;
&gt;&gt;&gt; tee(&#39;abc&#39;, 3)  # 创建三个独立的迭代器
(&lt;itertools.tee object at 0x104995998&gt;, &lt;itertools.tee object at 0x1049959e0&gt;, &lt;itertools.tee object at 0x104995a28&gt;)
</code></pre>

<p><strong>takewhile</strong><br/>
takewhile 的使用形式如下：<br/>
<code>takewhile(predicate, iterable)</code><br/>
其中，predicate 是函数，iterable 是可迭代对象。对于 iterable 中的元素，如果 predicate(item) 为 true，则保留该元素，只要 predicate(item) 为 false，则立即停止迭代。</p>

<pre><code class="language-python">&gt;&gt;&gt; from itertools import takewhile
&gt;&gt;&gt;
&gt;&gt;&gt; list(takewhile(lambda x: x &lt; 5, [1, 3, 6, 2, 1]))
[1, 3]
&gt;&gt;&gt; list(takewhile(lambda x: x &gt; 3, [2, 1, 6, 5, 4]))
[]
</code></pre>

<p><strong>zip</strong><br/>
izip 用于将多个可迭代对象对应位置的元素作为一个元组，将所有元组『组成』一个迭代器，并返回。它的使用形式如下：<br/>
<code>izip(iter1, iter2, ..., iterN)</code><br/>
如果某个可迭代对象不再生成值，则迭代停止。</p>

<pre><code class="language-python">&gt;&gt;&gt; from itertools import izip
&gt;&gt;&gt;
&gt;&gt;&gt; for item in izip(&#39;ABCD&#39;, &#39;xy&#39;):
...     print item
...
(&#39;A&#39;, &#39;x&#39;)
(&#39;B&#39;, &#39;y&#39;)
&gt;&gt;&gt; for item in izip([1, 2, 3], [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]):
...     print item
...
(1, &#39;a&#39;)
(2, &#39;b&#39;)
(3, &#39;c&#39;)
</code></pre>

<p><strong>izip_longest</strong><br/>
izip_longest 跟 izip 类似，但迭代过程会持续到所有可迭代对象的元素都被迭代完。它的形式如下：<br/>
<code>izip_longest(iter1, iter2, ..., iterN, [fillvalue=None])</code><br/>
如果有指定 fillvalue，则会用其填充缺失的值，否则为 None。</p>

<pre><code class="language-python">&gt;&gt;&gt; from itertools import izip_longest
&gt;&gt;&gt;
&gt;&gt;&gt; for item in izip_longest(&#39;ABCD&#39;, &#39;xy&#39;):
...     print item
...
(&#39;A&#39;, &#39;x&#39;)
(&#39;B&#39;, &#39;y&#39;)
(&#39;C&#39;, None)
(&#39;D&#39;, None)
&gt;&gt;&gt;
&gt;&gt;&gt; for item in izip_longest(&#39;ABCD&#39;, &#39;xy&#39;, fillvalue=&#39;-&#39;):
...     print item
...
(&#39;A&#39;, &#39;x&#39;)
(&#39;B&#39;, &#39;y&#39;)
(&#39;C&#39;, &#39;-&#39;)
(&#39;D&#39;, &#39;-&#39;)
</code></pre>

<p>&lt;-朕的朱批 -&gt; filevalue挺方便<br/>
<strong>组合生成器</strong><br/>
itertools 模块还提供了多个组合生成器函数，用于求序列的排列、组合等：</p>

<ul>
<li>product</li>
<li>permutations</li>
<li>combinations</li>
<li>combinations_with_replacement</li>
</ul>

<p>&lt;-朕的朱批 -&gt; 排列组合必备良方<br/>
<strong>product</strong><br/>
product 用于求多个可迭代对象的笛卡尔积，它跟嵌套的 for 循环等价。它的一般使用形式如下：<br/>
<code>product(iter1, iter2, ... iterN, [repeat=1])</code><br/>
其中，repeat 是一个关键字参数，用于指定重复生成序列的次数，</p>

<pre><code class="language-python">&gt;&gt;&gt; from itertools import product
&gt;&gt;&gt;
&gt;&gt;&gt; for item in product(&#39;ABCD&#39;, &#39;xy&#39;):
...     print item
...
(&#39;A&#39;, &#39;x&#39;)
(&#39;A&#39;, &#39;y&#39;)
(&#39;B&#39;, &#39;x&#39;)
(&#39;B&#39;, &#39;y&#39;)
(&#39;C&#39;, &#39;x&#39;)
(&#39;C&#39;, &#39;y&#39;)
(&#39;D&#39;, &#39;x&#39;)
(&#39;D&#39;, &#39;y&#39;)
&gt;&gt;&gt;
&gt;&gt;&gt; list(product(&#39;ab&#39;, range(3)))
[(&#39;a&#39;, 0), (&#39;a&#39;, 1), (&#39;a&#39;, 2), (&#39;b&#39;, 0), (&#39;b&#39;, 1), (&#39;b&#39;, 2)]
&gt;&gt;&gt;
&gt;&gt;&gt; list(product((0,1), (0,1), (0,1)))
[(0, 0, 0), (0, 0, 1), (0, 1, 0), (0, 1, 1), (1, 0, 0), (1, 0, 1), (1, 1, 0), (1, 1, 1)]
&gt;&gt;&gt;
&gt;&gt;&gt; list(product(&#39;ABC&#39;, repeat=2))
[(&#39;A&#39;, &#39;A&#39;), (&#39;A&#39;, &#39;B&#39;), (&#39;A&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;A&#39;), (&#39;B&#39;, &#39;B&#39;), (&#39;B&#39;, &#39;C&#39;), (&#39;C&#39;, &#39;A&#39;), (&#39;C&#39;, &#39;B&#39;), (&#39;C&#39;, &#39;C&#39;)]
&gt;&gt;&gt;
</code></pre>

<p><strong>permutations</strong><br/>
permutations 用于生成一个排列，它的一般使用形式如下：<br/>
<code>permutations(iterable[, r])</code><br/>
其中，r 指定生成排列的元素的长度，如果不指定，则默认为可迭代对象的元素长度。</p>

<pre><code class="language-python">&gt;&gt;&gt; from itertools import permutations
&gt;&gt;&gt;
&gt;&gt;&gt; permutations(&#39;ABC&#39;, 2)
&lt;itertools.permutations object at 0x1074d9c50&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; list(permutations(&#39;ABC&#39;, 2))
[(&#39;A&#39;, &#39;B&#39;), (&#39;A&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;A&#39;), (&#39;B&#39;, &#39;C&#39;), (&#39;C&#39;, &#39;A&#39;), (&#39;C&#39;, &#39;B&#39;)]
&gt;&gt;&gt;
&gt;&gt;&gt; list(permutations(&#39;ABC&#39;))
[(&#39;A&#39;, &#39;B&#39;, &#39;C&#39;), (&#39;A&#39;, &#39;C&#39;, &#39;B&#39;), (&#39;B&#39;, &#39;A&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;C&#39;, &#39;A&#39;), (&#39;C&#39;, &#39;A&#39;, &#39;B&#39;), (&#39;C&#39;, &#39;B&#39;, &#39;A&#39;)]
&gt;&gt;&gt;
</code></pre>

<p><strong>combinations</strong><br/>
combinations 用于求序列的组合，它的使用形式如下：<br/>
<code>combinations(iterable, r)</code><br/>
其中，r 指定生成组合的元素的长度。</p>

<pre><code class="language-python">&gt;&gt;&gt; from itertools import combinations
&gt;&gt;&gt;
&gt;&gt;&gt; list(combinations(&#39;ABC&#39;, 2))
[(&#39;A&#39;, &#39;B&#39;), (&#39;A&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;C&#39;)]
</code></pre>

<p><strong>combinations_with_replacement</strong><br/>
combinations_with_replacement 和 combinations 类似，但它生成的组合包含自身元素。</p>

<pre><code class="language-python">&gt;&gt;&gt; from itertools import combinations_with_replacement
&gt;&gt;&gt;
&gt;&gt;&gt; list(combinations_with_replacement(&#39;ABC&#39;, 2))
[(&#39;A&#39;, &#39;A&#39;), (&#39;A&#39;, &#39;B&#39;), (&#39;A&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;B&#39;), (&#39;B&#39;, &#39;C&#39;), (&#39;C&#39;, &#39;C&#39;)]
</code></pre>

<p><strong>小结</strong></p>

<p>itertools 模块提供了很多用于产生多种类型迭代器的函数，它们的返回值不是 list，而是迭代器。</p>

<p><strong>参考链接</strong></p>

<ul>
<li>itertools — Functions creating iterators for efficient looping</li>
<li>itertools – Iterator functions for efficient looping – Python Module of the Week</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[浅谈Python中字符串处理]]></title>
    <link href="https://sparkbye.github.io/myBlog/15211170247112.html"/>
    <updated>2018-03-15T20:30:24+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15211170247112.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">一、拆分含有多种分隔符的字符串</h2>

<h3 id="toc_1">1.如何拆分含有多种分隔符的字符串</h3>

<p>问题： 我们要把某个字符串依据分隔符号拆分不同的字段，该字符串包含多种不同的分隔符，例如：</p>

<pre><code class="language-python">s = &quot;ab;cd|efg|hi,jkl|mn\topq;rst,uvw\txyz&quot;
</code></pre>

<p>其中;,|,\t 都是分隔符号，如何处理？<br/>
方法一： 连续使用str.split()方法，每次处理一种分隔符号</p>

<pre><code class="language-python">s = &quot;ab;cd|efg|hi,jkl|mn\topq;rst,uvw\txyz&quot;
def mySplit(s,ds):
    res = [s]    
    for d in ds:
        t = []
        map(lambda x: t.extend(x.split(d)), res)
        res = t    
    return res

print mySplit(s,&#39;;|,\t&#39;)

输出：
[&#39;ab&#39;, &#39;cd&#39;, &#39;efg&#39;, &#39;hi&#39;, &#39;jkl&#39;, &#39;mn&#39;, &#39;opq&#39;, &#39;rst&#39;, &#39;uvw&#39;, &#39;xyz&#39;]
</code></pre>

<p>方法二： 使用正则表达式的re.split()方法，一次性拆分字符串</p>

<pre><code class="language-python">import re

s = &quot;ab;cd|efg|hi,jkl|mn\topq;rst,uvw\txyz&quot;

print re.split(r&#39;[;|,\t]+&#39;,s)

输出：
[&#39;ab&#39;, &#39;cd&#39;, &#39;efg&#39;, &#39;hi&#39;, &#39;jkl&#39;, &#39;mn&#39;, &#39;opq&#39;, &#39;rst&#39;, &#39;uvw&#39;, &#39;xyz&#39;]
</code></pre>

<h2 id="toc_2">二、调整字符串中文本格式</h2>

<h3 id="toc_3">1. 如何判断字符串a是否以字符串b开头或结尾</h3>

<p>问题：某文件系统目录下有一系列文件：a.py,quicksort.c,stack.cpp,b.sh , 编写程序给其中所有.sh文件和.py文件加上用户可执行权限？<br/>
解决方案：<br/>
使用字符串中的str.startswith()和end.startswith()方法 (注意：多个匹配时参数使用元组)</p>

<pre><code class="language-python">In [1]: import os    #列出当前目录以.sh和以.py结尾的文件
In [2]: [name for name in os.listdir(&#39;.&#39;) if name.endswith((&#39;.py&#39;,&#39;.sh&#39;))]
Out[2]: [&#39;b.sh&#39;, &#39;a.py&#39;]

In [3]: import stat

# 查看 a.py 文件权限
In [4]: os.stat(&#39;a.py&#39;).st_mode
Out[4]: 33204# 把文件权限转换成8进制，即为平常看到的权限
In [5]: oct(os.stat(&#39;a.py&#39;).st_mode)
Out[5]: &#39;0100664&#39;# 更改文件权限，添加一个可执行权限
In [6]: os.chmod(&#39;a.py&#39;,os.stat(&#39;a.py&#39;).st_mode | stat.S_IXUSR)

In [7]: ll
total 0
-rwxrw-r-- 1 yangevan 0 5月   9 14:48 a.py*
-rw-rw-r-- 1 yangevan 0 5月   9 14:48 b.sh
-rw-rw-r-- 1 yangevan 0 5月   9 14:48 quicksort.c
-rw-rw-r-- 1 yangevan 0 5月   9 14:48 stack.cpp
</code></pre>

<h3 id="toc_4">2.如何对字符串中文本的格式进行调整</h3>

<p>问题：某软件的log文件，其中日期格式为“yyyy-mm-dd”:</p>

<pre><code class="language-python">2017-05-08 09:12:48 status half-configured passwd:amd64 1:4.2-3.1ubuntu5.2
2017-05-08 09:12:48 status installed passwd:amd64 1:4.2-3.1ubuntu5.2
2017-05-08 09:12:48 status unpacked passwd:amd64 1:4.2-3.1ubuntu5.2
2017-05-08 09:12:48 status unpacked passwd:amd64 1:4.2-3.1ubuntu5.2
2017-05-08 09:12:48 status half-configured passwd:amd64 1:4.2-3.1ubuntu5.2
2017-05-08 09:12:48 status installed passwd:amd64 1:4.2-3.1ubuntu5.2
2017-05-08 09:12:48 startup packages configure
09:12:48 startup packages configure
</code></pre>

<p>我们想把其中日期改为美国日期的格式&quot;mm/dd/yyyy&quot;,2017-05-08 ==&gt; 05/08/2017 ,应如何处理？<br/>
解决方案：<br/>
使用正则表达式re.sub()方法做字符串替换，利用正则表达式的捕获组捕获每个部分内容，在字符串中调整各个组的捕获顺序。</p>

<pre><code class="language-python">In [1]: import re

In [2]: log = open(&#39;/var/log/dpkg.log&#39;).read()
# (\d{4}) 匹配到4个数字为一个捕获组，其顺序为1。故后面替换用\1放到最后，r是为了防止字符串被转义
In [3]: print re.sub(&#39;(\d{4})-(\d{2})-(\d{2})&#39;,r&#39;\2/\3/\1&#39;, log)
05/08/2017 09:12:48 status unpacked passwd:amd64 1:4.2-3.1ubuntu5.2
05/08/2017 09:12:48 status unpacked passwd:amd64 1:4.2-3.1ubuntu5.2
05/08/2017 09:12:48 status unpacked passwd:amd64 1:4.2-3.1ubuntu5.2
05/08/2017 09:12:48 status half-configured passwd:amd64 1:4.2-3.1ubuntu5.2
05/08/2017 09:12:48 status installed passwd:amd64 1:4.2-3.1ubuntu5.2
05/08/2017 09:12:48 startup packages configure

# 也可以为每个捕获组起个名称，而不使用默认顺序来处理
In [5]: print re.sub(&#39;(?P&lt;year&gt;\d{4})-(?P&lt;month&gt;\d{2})-(?P&lt;day&gt;\d{2})&#39;,r&#39;\g&lt;month&gt;/\g&lt;day&gt;/\g&lt;year&gt;&#39;, log)
05/08/2017 09:12:48 status unpacked passwd:amd64 1:4.2-3.1ubuntu5.2
05/08/2017 09:12:48 status unpacked passwd:amd64 1:4.2-3.1ubuntu5.2
05/08/2017 09:12:48 status unpacked passwd:amd64 1:4.2-3.1ubuntu5.2
05/08/2017 09:12:48 status half-configured passwd:amd64 1:4.2-3.1ubuntu5.2
05/08/2017 09:12:48 status installed passwd:amd64 1:4.2-3.1ubuntu5.2
05/08/2017 09:12:48 startup packages configure
</code></pre>

<h2 id="toc_5">三、字符串拼接</h2>

<h3 id="toc_6">1.如何将多个小字符串拼接成一个大的字符串</h3>

<p>问题：在程序中我们将各个参数按次序收集到列表中： [&quot;<0112>&quot;, &quot;<32>&quot;,&quot;<1024x768>&quot;,&quot;<60>&quot; ],要把各个参数拼接成数据报进行发送&quot;<0112><32><1024x768><60>&quot;<br/>
解决方案：<br/>
方法一：迭代列表，连续使用“+”操作依次拼接每一个字符串</p>

<pre><code class="language-python">In [1]: pl = [&quot;&lt;0112&gt;&quot;, &quot;&lt;32&gt;&quot;,&quot;&lt;1024x768&gt;&quot;,&quot;&lt;60&gt;&quot; ]

In [2]: s = &#39;&#39;

# 这种方法会产生许多临时结果，会造成资源的浪费
In [3]: for p in pl:
  ...:     s = s + p
  ...:     print s
  ...:    
&lt;0112&gt;&lt;0112&gt;&lt;32&gt;&lt;0112&gt;&lt;32&gt;&lt;1024x768&gt;&lt;0112&gt;&lt;32&gt;&lt;1024x768&gt;&lt;60&gt;
In [4]: s
Out[4]: &#39;&lt;0112&gt;&lt;32&gt;&lt;1024x768&gt;&lt;60&gt;&#39;
</code></pre>

<p>方法二：使用str.join()方法，更加快速的拼接列表中所有字符串</p>

<pre><code class="language-python">In [5]: &#39;&#39;.join(pl)
Out[5]: &#39;&lt;0112&gt;&lt;32&gt;&lt;1024x768&gt;&lt;60&gt;&#39;
</code></pre>

<p>有个列表l = [&#39;abc&#39;,123,45,&#39;xyz&#39;],如何让123和45以字符串的方式拼接</p>

<pre><code class="language-python">In [6]: l = [&#39;abc&#39;,123,45,&#39;xyz&#39;]

# 使用生成器表达式，开销比列表表达式小
In [7]: (str(x) for x in l)
  ...:
Out[7]: &lt;generator object &lt;genexpr&gt; at 0x7fe3cadef550&gt;

In [8]: &#39;&#39;.join(str(x) for x in l)
Out[8]: &#39;abc12345xyz&#39;
</code></pre>

<h2 id="toc_7">四、字符串居中对齐</h2>

<h3 id="toc_8">1.如何对字符串进行左、右、居中对齐</h3>

<p>问题： 某个字典存储了一系列属性值</p>

<pre><code class="language-python">{    &quot;loDist&quot;:100.0,    &quot;smartCull&quot;:0.04,    &quot;farclip&quot;:477}
</code></pre>

<p>在程序中想以工整的格式进行输出，如何处理？<br/>
解决方案：<br/>
方法一： 使用字符串的str.ljust(),str.rjust(),str.center()进行,右,居中对齐<br/>
方法二： 使用format方法，传递类似&#39;<20','>20&#39;,&#39;<sup>20&#39;参数完成同样任务</sup></p>

<pre><code class="language-python">In [1]: s = &#39;abc&#39;In 

Out[2]: &#39;abc                 &#39;
In [3]: s.ljust(20,&#39;=&#39;)
Out[3]: &#39;abc=================&#39;
In [4]: s.center(20)
Out[4]: &#39;        abc         &#39;
In [5]: format(s,&#39;&lt;20&#39;)
Out[5]: &#39;abc                 &#39;
In [6]: d = {
  ...:     &quot;loDist&quot;:100.0,
  ...:     &quot;smartCull&quot;:0.04,
  ...:     &quot;farclip&quot;:477
  ...: }
In [7]: d.keys()
Out[7]: [&#39;loDist&#39;, &#39;smartCull&#39;, &#39;farclip&#39;]
In [8]: w =max(map(len,d.keys()))
In [9]: for k in d:
  ...:     print k.ljust(w),&#39;:&#39;,d[k]
  ...:    
loDist    : 100.0
smartCull : 0.04
farclip   : 477
</code></pre>

<h3 id="toc_9">2.去掉不需要的字符串</h3>

<p>问题：<br/>
1.过滤掉用户输入中前后多余的空白字符： &#39; <a href="mailto:nick@gmail.com">nick@gmail.com</a> &#39;<br/>
2.过滤某windows下编辑文本中的&#39;\r&#39;: &#39;hello world\r\n&#39;<br/>
3.去掉文本中的unicode组合符号(音调):u&#39;zǒu&#39;<br/>
解决方案：<br/>
方法一： 字符串strip(),lstrip(),rstrip()方法去掉字符串两端字符<br/>
方法二：删除单个固定位置的字符，可以使用切片+拼接的方式<br/>
方法三：字符串的replace方法或正则表达式re.sub()方法删除任意位置字符<br/>
方法四：字符串translate()方法,可以同时删除多种不同字符</p>

<pre><code class="language-python">In [1]: s = &#39;  abc 123  &#39;
In [2]: s.strip()
Out[2]: &#39;abc 123&#39;
In [3]: s.lstrip()
Out[3]: &#39;abc 123  &#39;
In [4]: s = &#39;-----ab+++++&#39;
In [5]: s.strip(&#39;-+&#39;)
Out[5]: &#39;ab&#39;
In [6]: s = &#39;abc:123&#39;
In [7]: s[:3]+s[4:]
Out[7]: &#39;abc123&#39;
In [8]: s = &#39;\tabc\t123\txyz&#39;# 去除\t
In [9]: s.replace(&#39;\t&#39;,&#39;&#39;)
Out[9]: &#39;abc123xyz&#39;
In [10]: s = &#39;\tabc\t123\txyz\ropq\r&#39;
In [11]: import re# 去除\t\r
In [12]: re.sub(&#39;[\t\r]&#39;,&#39;&#39;,s)
Out[12]: &#39;abc123xyzopq&#39;
In [13]: s = &#39;abc\refg\n\2342\t&#39;# 去除\t\r\n
In [14]: s.translate(None,&#39;\t\r\n&#39;)
Out[14]: &#39;abcefg\x9c2&#39;
In [15]: u = u&#39;zǒu&#39;
In [16]: u
Out[16]: u&#39;z\u01d2u&#39;
In [17]: print u.translate({0x01d2:None})
zu
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python 字典的内部实现]]></title>
    <link href="https://sparkbye.github.io/myBlog/15198200217202.html"/>
    <updated>2018-02-28T20:13:41+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15198200217202.html</id>
    <content type="html"><![CDATA[
<p>python中字典是通过键索引的，因此，字典也可视作彼此关联的两个数组。下面我们尝试向字典中添加3个键/值（key/value）对：</p>

<pre><code class="language-python">d = {&#39;a&#39;:1, &#39;b&#39;:2}
d[&#39;c&#39;] = 3
print d
</code></pre>

<p>输出：<code>{&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3}</code><br/>
这些值可通过如下方法访问：</p>

<pre><code class="language-python">print d[&#39;a&#39;]
print d[&#39;b&#39;]
print d[&#39;c&#39;]
print d[&#39;d&#39;]
</code></pre>

<p><code>Traceback (most recent call last):<br/>
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; KeyError: &#39;d&#39;</code><br/>
由于不存在 &#39;d&#39; 这个键，所以引发了KeyError异常。</p>

<p><strong>哈希表（Hash tables）</strong><br/>
在Python中，字典是通过哈希表实现的。也就是说，字典是一个数组，而数组的索引是键经过哈希函数处理后得到的。哈希函数的目的是使键均匀地分布在数组中。由于不同的键可能具有相同的哈希值，即可能出现冲突，高级的哈希函数能够使冲突数目最小化。Python中并不包含这样高级的哈希函数，几个重要（用于处理字符串和整数）的哈希函数通常情况下均是常规的类型：</p>

<pre><code>&gt;&gt;&gt; map(hash, (0, 1, 2, 3))
[0, 1, 2, 3]
&gt;&gt;&gt; map(hash, (&quot;namea&quot;, &quot;nameb&quot;, &quot;namec&quot;, &quot;named&quot;))
[-1658398457, -1658398460, -1658398459, -1658398462]
</code></pre>

<p>在以下的篇幅中，我们仅考虑用字符串作为键的情况。在Python中，用于处理字符串的哈希函数是这样定义的：</p>

<pre><code class="language-python">arguments: string object
returns: hash
function string_hash:
    if hash cached:
        return it
    set len to string&#39;s length
    initialize var p pointing to 1st char of string object
    set x to value pointed by p left shifted by 7 bits
    while len &gt;= 0:
        set var x to (1000003 * x) xor value pointed by p
        increment pointer p
    set x to x xor length of string object
    cache x as the hash so we don&#39;t need to calculate it again
    return x as the hash
</code></pre>

<p>如果在Python中运行 hash(&#39;a&#39;) ，后台将执行 string_hash()函数，然后返回 12416037344 （这里我们假设采用的是64位的平台）。</p>

<p>如果用长度为 x 的数组存储键/值对，则我们需要用值为 x-1 的掩码计算槽（slot，存储键/值对的单元）在数组中的索引。这可使计算索引的过程变得非常迅速。字典结构调整长度的机制（以下会详细介绍）会使找到空槽的概率很高，也就意味着在多数情况下只需要进行简单的计算。假如字典中所用数组的长度是 8 ，那么键&#39;a&#39;的索引为：hash(&#39;a&#39;) &amp; 7 = 0，同理&#39;b&#39;的索引为 3 ,&#39;c&#39;的索引为 2 , 而&#39;z&#39;的索引与&#39;b&#39;相同，也为 3 ，这就出现了冲突。<br/>
<img src="media/15198200217202/15198207691451.png" alt=""/><br/>
可以看出，Python的哈希函数在键彼此连续的时候表现得很理想，这主要是考虑到通常情况下处理的都是这类形式的数据。然而，一旦我们添加了键&#39;z&#39;就会出现冲突，因为这个键值并不毗邻其他键，且相距较远。</p>

<p>当然，我们也可以用索引为键的哈希值的链表来存储键/值对，但会增加查找元素的时间，时间复杂度也不再是 O(1) 了。下一节将介绍Python的字典解决冲突所采用的方法。</p>

<p><strong>开放寻址法（ Open addressing ）</strong></p>

<p>开放寻址法是一种用探测手段处理冲突的方法。在上述键&#39;z&#39;冲突的例子中，索引 3 在数组中已经被占用了，因而需要探寻一个当前未被使用的索引。增加和搜寻键/值对需要的时间均为 O(1)。</p>

<p>搜寻空闲槽用到了一个二次探测序列（quadratic probing sequence），其代码如下：</p>

<pre><code class="language-python">j = (5*j) + 1 + perturb; 
perturb &gt;&gt;= PERTURB_SHIFT;
use j % 2**i as the next table index;
</code></pre>

<p>循环地5*j+1可以快速放大不影响初始索引的哈希值二进位的微小差异。变量perturb可使其他二进位也不断变化。</p>

<p>出于好奇，我们来看一看当数组长度为 32 时的探测序列，j = 3 -&gt; 11 -&gt; 19 -&gt; 29 -&gt; 5 -&gt; 6 -&gt; 16 -&gt; 31 -&gt; 28 -&gt; 13 -&gt; 2…</p>

<p>关于探测序列的更多介绍可以参阅dictobject.c的源码。文件的开头包含了对探测机理的详细介绍。<br/>
<img src="media/15198200217202/15198208428424.jpg" alt=""/><br/>
下面我们结合例子来看一看 Python 内部代码。<br/>
<strong>基于C语言的字典结构</strong><br/>
以下基于C语言的数据结构用于存储字典的键/值对（也称作 entry），存储内容有哈希值，键和值。PyObject 是 Python 对象的一个基类。</p>

<pre><code class="language-C">typedef struct {
    Py_ssize_t me_hash;
    PyObject *me_key;
    PyObject *me_value
} PyDictEntry;
</code></pre>

<p>下面为字典对应的数据结构。其中，ma_fill为活动槽以及哑槽（dummy slot）的总数。当一个活动槽中的键/值对被删除后，该槽则被标记为哑槽。ma_used为活动槽的总数。ma_mask值为数组的长度减 1 ，用于计算槽的索引。ma_table为数组本身，ma_smalltable为长度为 8 的初始数组。</p>

<pre><code class="language-C">typedef struct _dictobject PyDictObject;
struct _dictobject {
    PyObject_HEAD
    Py_ssize_t ma_fill;
    Py_ssize_t ma_used;
    Py_ssize_t ma_mask;
    PyDictEntry *ma_table;
    PyDictEntry *(*ma_lookup)(PyDictObject *mp, PyObject *key, long hash);
    PyDictEntry ma_smalltable[PyDict_MINSIZE];
};
</code></pre>

<p><strong>字典初始化</strong><br/>
字典在初次创建时将调用PyDict_New()函数。这里删掉了源代码中的部分行，并且将C语言代码转换成了伪代码以突出其中的几个关键概念。</p>

<pre><code class="language-C">returns new dictionary object
function PyDict_New:
    allocate new dictionary object
    clear dictionary&#39;s table
    set dictionary&#39;s number of used slots + dummy slots (ma_fill) to 0
    set dictionary&#39;s number of active slots (ma_used) to 0
    set dictionary&#39;s mask (ma_value) to dictionary size - 1 = 7
    set dictionary&#39;s lookup function to lookdict_string
    return allocated dictionary object
</code></pre>

<p><strong>添加项</strong><br/>
添加新的键/值对调用的是PyDict_SetItem()函数。函数将使用一个指针指向字典对象和键/值对。这一过程中，首先会检查键是否是字符串，然后计算哈希值，如果先前已经计算并缓存了键的哈希值，则直接使用缓存的值。接着调用insertdict()函数添加新键/值对。如果活动槽和空槽的总数超过数组长度的2/3，则需调整数组的长度。为什么是 2/3 ？这主要是为了保证探测序列能够以足够快的速度找到空闲槽。后面我们会介绍调整长度的函数。</p>

<pre><code class="language-C">arguments: dictionary, key, value
returns: 0 if OK or -1
function PyDict_SetItem:
    if key&#39;s hash cached:
        use hash
    else:
        calculate hash
    call insertdict with dictionary object, key, hash and value
    if key/value pair added successfully and capacity over 2/3:
        call dictresize to resize dictionary&#39;s table
</code></pre>

<p>inserdict() 使用搜寻函数 lookdict_string() 来查找空闲槽。这跟查找键所用的是同一函数。lookdict_string() 使用哈希值和掩码计算槽的索引。如果用“索引 = 哈希值&amp;掩码”的方法未找到键，则会用调用先前介绍的循环方法探测，直至找到一个空闲槽。第一轮探测，如果未找到匹配的键的且探测过程中遇到过哑槽，则返回一个哑槽。这可使优先选择先前删除的槽。<br/>
现在我们想添加如下的键/值对：{‘a’: 1, ‘b’: 2′, ‘z’: 26, ‘y’: 25, ‘c’: 5, ‘x’: 24}，那么将会发生如下过程：</p>

<p>分配一个字典结构，内部表的尺寸为8。<br/>
<img src="media/15198200217202/15198209955932.jpg" alt=""/><br/>
以下就是我们目前所得到的：<br/>
<img src="media/15198200217202/15198210086336.jpg" alt=""/><br/>
8个槽中的6个已被使用，使用量已经超过了总容量的2/3，因而，dictresize()函数将会被调用，用以分配一个长度更大的数组，同时将旧表中的条目复制到新的表中。</p>

<p>在我们这个例子中，dictresize()函数被调用后，数组长度调整后的长度不小于活动槽数量的 4 倍，即minused = 24 = 4 * ma_used。而当活动槽的数量非常大（大于50000）时，调整后长度应不小于活动槽数量的2倍，即2*ma_used。为什么是 4 倍？这主要是为了减少调用调整长度函数的次数，同时能显著提高稀疏度。</p>

<p>新表的长度应大于 24，计算长度值时会不断对当前长度值进行升位运算，直到大于 24，最终得到的长度是 32，例如当前长度为 8 ，则计算过程如8 -&gt; 16 -&gt; 32。</p>

<p>这就是长度调整的过程：分配一个长度为 32 的新表，然后用新的掩码，也就是 31 ，将旧表中的条目插入到新表。最终得到的结果如下：<br/>
<img src="media/15198200217202/15198210614829.jpg" alt=""/><br/>
<strong>删除项</strong><br/>
删除条目时将调用PyDict_DelItem()函数。删除时，首先计算键的哈希值，然后调用搜询函数返回到该条目，最后该槽被标记为哑槽。</p>

<p>假设我们想要从字典中删除键&#39;c&#39;，我们最终将得到如下结果：<br/>
<img src="media/15198200217202/15198210844803.png" alt=""/><br/>
注意，删除项目后，即使最终活动槽的数量远小于总的数量也不会触发调整数组长度的动作。但是，若删减后又增加键/值对时，由于调整长度的条件判断基于的是活动槽与哑槽的总数量，因而可能会缩减数组长度。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Auto Install Stack(v2.0)]]></title>
    <link href="https://sparkbye.github.io/myBlog/15161073656469.html"/>
    <updated>2018-01-16T20:56:05+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15161073656469.html</id>
    <content type="html"><![CDATA[
<p>更新了脚本：</p>

<pre><code class="language-sh">#!/bin/bash

##############################################################################
# Use script like this:
# ./auto_install_stack.sh ${num}
#            run 1  --- will re-install stack with default image.
#            run 2  --- will re-install stack with specified image(install new stack with same yaml file).
#            run 3  --- will re-install stack with specified image and yaml parameter(first use this scripts).
##############################################################################

set -x

function echo__blue()            { echo -e &quot;\e[0;34;1m$1\e[0m&quot;;}
function echo__red()             { echo -e &quot;\e[0;31;1m$1\e[0m&quot;;}
function echo__green()           { echo -e &quot;\e[0;32;1m$1\e[0m&quot;;}
function echo__yellow()          { echo -e &quot;\e[0;33;1m$1\e[0m&quot;;}
function echo__red_shining()     { echo -e &quot;\033[31m \033[05m $2 \033[0m&quot;;}
function echo__blue_shining()    { echo -e &quot;\033[34m \033[05m $2 \033[0m&quot;;}

CURRENT_DIR=`pwd`
LOCAL_DIR=&quot;rcp-heat&quot;
STACK_TYPE=&quot;net&quot;
NUM=`echo ${CURRENT_DIR##*/} | tr -cd &quot;[0-9]&quot;`

if [ ${CURRENT_DIR##*/} != &quot;hranuser$NUM&quot; ];then
    echo__red &quot;======= Error: Current directory must be end with &#39;/hranuser&#39; ======&quot;
    exit -1
fi

if [ ! -d &quot;$LOCAL_DIR&quot; ];then
    mkdir -p $LOCAL_DIR
fi

function _create_image()
{
    IMAGE_FILE=`echo ${RCP_IMAGE_URL##*/} | cut -d &quot;.&quot; -f 1,2`
    IMAGE_EXIST=`glance image-list | grep $IMAGE_FILE | wc -l`
    if [ $IMAGE_EXIST -ne 0 ];then
        IMAGE_UUID=`glance image-list | grep $IMAGE_FILE | awk &#39;{print $2}&#39;`
        glance image-delete $IMAGE_UUID
        sleep 3
    fi
    echo__blue &quot;====== Begin to download RCP image to $LOCAL_DIR ======&quot;
    wget -O $LOCAL_DIR/${RCP_IMAGE_URL##*/} $RCP_IMAGE_URL
    if [ $? -ne 0 ];then
        echo__red &quot;====== Download image unsuceessfully, please check your image name is right ======&quot;
        exit -1
    fi
    echo__blue &quot;====== Download image suceessfully ======&quot;    
    echo__blue &quot;====== Begin to create image ======&quot;
    glance image-create --name=$IMAGE_FILE --container-format=bare --visibility=private --disk-format=qcow2 --file=$LOCAL_DIR/${RCP_IMAGE_URL##*/}
    IMAGE_UUID=`glance image-list | grep $IMAGE_FILE | awk &#39;{print $2}&#39;`
    while ((1))
    do
        GLANCE_STATUS=`glance image-show $IMAGE_UUID | grep status | awk &#39;{print $4}&#39;`
        if [ &quot;active&quot; != &quot;$GLANCE_STATUS&quot; ];then
            echo__blue &quot;====== Waiting for image active... ======&quot;
            sleep 5
        else
            break
        fi
    done
    echo__blue &quot;====== Create image suceessfully ======&quot;
    sleep 3
}

function _download_yaml()
{
    TEMPLATE_FILE=${RCP_TEMPLATE_URL##*/}
    echo__blue &quot;====== Downloading RCP template to $LOCAL_DIR/$TEMPLATE_FILE ======&quot;
    wget -O $LOCAL_DIR/$TEMPLATE_FILE $RCP_TEMPLATE_URL
    if [ $? -ne 0 ]
    then
        echo__red &quot;====== Download template unsuceessfully, please check your template file is right ======&quot;
        exit -1
    fi
    echo__blue &quot;====== Download template suceessfully ======&quot;
    ls -l $LOCAL_DIR
    tar -xzvf $LOCAL_DIR/$TEMPLATE_FILE -C $LOCAL_DIR
    rm -f $LOCAL_DIR/$TEMPLATE_FILE
}

function _uninstall_old_stack()
{
    echo__blue &quot;====== Begin to uninstall existed stack ======&quot;
    STACK_UUID=`openstack stack list | awk &#39;{print $2}&#39; | awk &#39;NR&gt;2&#39; | awk &#39;{if(length!=0) print $0}&#39;`
    ### === used for Multi-stack === ###
    # STACK_UUID=`openstack stack list | grep touchdown | awk &#39;{print $2}&#39; | awk &#39;{if(length!=0) print $0}&#39;`
    if [ -n &quot;$STACK_UUID&quot; ];then
        /usr/bin/expect &lt;&lt; EOF
        set time 10
        spawn openstack stack delete ${STACK_UUID}
        expect &quot;*y/N*&quot;
        send &quot;y\r&quot;
        expect eof
EOF
    fi
    while ((1))
    do
        STACK_STATUS=`openstack stack list | awk &#39;{print $6}&#39; | awk &#39;NR&gt;2&#39; | awk &#39;{if(length!=0) print $0}&#39;`
        if [ -n &quot;${STACK_STATUS}&quot; ];then
            sleep 10
            echo__blue &quot;====== Deleting old stack, please wait... ======&quot;
        else
            break
        fi
    done
    echo__blue &quot; === Uninstall existed stack successfully === &quot;
}

function _mod_env_file_part()
{
    echo__blue &quot;====== Begin to modify env file... ======&quot;
    image=`echo ${REPLY##*/} | cut -d &quot;.&quot; -f 1,2`
    RCP_HEAT_FILE=&quot;rcp-heat/$STACK_TYPE/rcp-heat.env&quot;
    sed -i &quot;s/image: .*/image: $image/g&quot; $RCP_HEAT_FILE
    echo__blue &quot;====== Modify successfully ======&quot;
}

function _mod_env_file_full()
{
    echo__blue &quot;====== Begin to modify env file... ======&quot;  
    availability_zone=&quot;nova&quot;
    cluster_id=&quot;RCP-1234&quot;
    dns_forwarders=&quot;10.56.126.31&quot;
    config_drive=&quot;false&quot;
    ext0=&quot;`neutron net-list | grep hran${num} | awk &#39;{print $4}&#39; | awk &#39;NR==1&#39;`&quot;
    ext1=&quot;`neutron net-list | grep hran${num} | awk &#39;{print $4}&#39; | awk &#39;NR==2&#39;`&quot;
    ext2=&quot;`neutron net-list | grep hran${num} | awk &#39;{print $4}&#39; | awk &#39;NR==3&#39;`&quot;
    cp=&quot;rcp_medium_v2&quot;
    ei=&quot;rcp_xlarge_v2&quot;
    mn=&quot;rcp_large_v2&quot;
    up=&quot;rcp_xlarge_v2&quot;
    uvm=&quot;rcp_medium_v2&quot;
    hostname_prefix=&quot;abc&quot;
    image=`echo ${RCP_IMAGE_URL##*/} | cut -d &quot;.&quot; -f 1,2`
    key_name=`nova keypair-list | awk &#39;NR&gt;2&#39; | awk &#39;{print $2}&#39; | awk &#39;{if(length!=0) print $0}&#39;`
    if [ -z &quot;$key_name&quot; ];then
        nova keypair-add default_key
        key_name=`nova keypair-list | awk &#39;NR&gt;2&#39; | awk &#39;{print $2}&#39; | awk &#39;{if(length!=0) print $0}&#39;`
    fi
    ntp_servers=&quot;10.39.12.252&quot;
    number_of_uvm_nodes=&quot;0&quot;
    ### use oam uuid
    #oam_network=&quot;`nova network-list | grep -w &quot;vnfoam &quot; | awk &#39;{print $2}&#39;`&quot;
    ### use oam name
    oam_network=&quot;vnfoam&quot;
    _nokadmin=&quot;Nokia123&quot;
    _nokfsoperator=&quot;RCP_owner&quot;
    root=&quot;root&quot;
    time_zone=&quot;Asia/Shanghai&quot;    
    vif_models=&quot;avp&quot;
    vif_models_2=&quot;virtio&quot;  
    rcp_heat_file=&quot;rcp-heat/$STACK_TYPE/rcp-heat.env&quot;
    sed -i &quot;s/availability_zone: .*/availability_zone: $availability_zone/g&quot; ${rcp_heat_file}
    sed -i &quot;s/cluster_id: .*/cluster_id: $cluster_id/g&quot; ${rcp_heat_file}
    sed -i &quot;s/dns_forwarders: .*/dns_forwarders: $dns_forwarders/g&quot; ${rcp_heat_file}
    sed -i &quot;s/config_drive: .*/config_drive: $config_drive/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ext0: .*/ext0: $ext0/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ext1: .*/ext1: $ext1/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ext2: .*/ext2: $ext2/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ cp: .*/ cp: $cp/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ ei: .*/ ei: $ei/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ mn: .*/ mn: $mn/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ up: .*/ up: $up/g&quot; ${rcp_heat_file}
    sed -i &quot;s/uvm: .*/uvm: $uvm/g&quot; ${rcp_heat_file}
    sed -i &quot;s/hostname_prefix: .*/hostname_prefix: $hostname_prefix/g&quot; ${rcp_heat_file}
    sed -i &quot;s/image: .*/image: $image/g&quot; ${rcp_heat_file}
    sed -i &quot;s/key_name: .*/key_name: $key_name/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ntp_servers: .*/ntp_servers: $ntp_servers/g&quot; ${rcp_heat_file}
    sed -i &quot;s/number_of_uvm_nodes: .*/number_of_uvm_nodes: $number_of_uvm_nodes/g&quot; ${rcp_heat_file}
    sed -i &quot;s/oam_network: .*/oam_network: $oam_network/g&quot; ${rcp_heat_file}
    sed -i &quot;s/_nokadmin: .*/_nokadmin: $_nokadmin/g&quot; ${rcp_heat_file}
    sed -i &quot;s/_nokfsoperator: .*/_nokfsoperator: $_nokfsoperator/g&quot; ${rcp_heat_file}
    sed -i &quot;s/root: .*/root: $root/g&quot; ${rcp_heat_file}
    sed -i &quot;s#time-zone: .*#time-zone: $time_zone#g&quot; ${rcp_heat_file}
    sed -i &quot;s/uvm_image: .*/uvm_image: $image/g&quot; ${rcp_heat_file}  
    sed -i &quot;s/ external: .*/ external: $vif_models/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ internal: .*/ internal: $vif_models_2/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ oam: .*/ oam: $vif_models/g&quot; ${rcp_heat_file}   
    echo__blue &quot;====== Modify successfully ======&quot;
}

function _launch_stack()
{
    echo__blue &quot;====== Begin to launch stack ======&quot;
    openstack stack create -f yaml -e $LOCAL_DIR/$STACK_TYPE/rcp-heat.env -t $LOCAL_DIR/$STACK_TYPE/rcp-heat.yaml ${CURRENT_DIR##*/}_auto
    while ((1))
    do
        STACK_STATUS=`openstack stack list | awk &#39;{print $6}&#39; | awk &#39;NR&gt;2&#39; | awk &#39;{if(length!=0) print $0}&#39;`
        if [ &quot;CREATE_COMPLETE&quot; != &quot;${STACK_STATUS}&quot; ];then
            sleep 30
            echo__blue &quot;====== Installing, please wait... ======&quot;
        else
            break
        fi
    done
    oam=`nova list | grep vnfoam | awk &#39;{print $13}&#39;`
    echo__blue_shining &quot;====== Launch stack successfully, ${oam} DONE ====== \033[05m ${oam}&quot;
}

function reinstall_stack_1()
{
    _uninstall_old_stack
    _launch_stack
}

function reinstall_stack_2()
{
    _create_image $REPLY
    _uninstall_old_stack
    _mod_env_file_part
    _launch_stack
    rm -f $LOCAL_DIR/${REPLY##*/}
}

function reinstall_stack_3()
{
    _download_yaml
    _mod_env_file_full
    _create_image ${RCP_IMAGE_URL}
    _uninstall_old_stack
    _launch_stack
    rm -f $LOCAL_DIR/${RCP_IMAGE_URL##*/}
}


case &quot;$1&quot; in
    1)
      echo &quot;Begin to re-install stack.....&quot;
      reinstall_stack_1
      echo &quot;Script completes!!!!!&quot;
      exit 1
      ;;
    2)
      read -p &quot;Please input specified image url: &quot;
      echo &quot;Begin to re-install stack with image ${REPLY##*/}.....&quot;
      reinstall_stack_2
      echo &quot;Script completes!!!!!&quot;
      exit 1
      ;;
    3)
      read -p &quot;Please input specified image url: &quot; RCP_IMAGE_URL
      read -p &quot;Please input specified yaml url: &quot; RCP_TEMPLATE_URL
      echo &quot;Begin to re-install stack with image ${RCP_IMAGE_URL##*/} and yaml ${RCP_TEMPLATE_URL##*/}.....&quot;
      reinstall_stack_3
      echo &quot;Script completes!!!!!&quot;
      exit 1
      ;;
    *)
      echo &quot;Usage:
            run 1  --- will re-install stack with default image.
            run 2  --- will re-install stack with specified image.
            run 3  --- will re-install stack with specified image and yaml parameter.&quot;
      exit 1
      ;;
esac
exit 0
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Auto Install Stack]]></title>
    <link href="https://sparkbye.github.io/myBlog/15161072350728.html"/>
    <updated>2018-01-16T20:53:55+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15161072350728.html</id>
    <content type="html"><![CDATA[
<p>自动安装脚本：</p>

<pre><code class="language-sh">#!/bin/bash

##############################################################################
# Use script like this:
# ./auto_install_stack.sh ${num}
#            run 1  --- will re-install stack with default image.
#            run 2  --- will re-install stack with specified image(install new stack with same yaml file).
#            run 3  --- will re-install stack with specified image and yaml parameter(first use this scripts).
##############################################################################

set +x

function echo_color(){
    case $1 in
        &quot;red&quot;)
            echo -e &quot;\033[31m $2 \033[0m&quot; ;;
        &quot;red-shining&quot;)
            echo -e &quot;\033[31m \033[05m $2 \033[0m&quot; ;;
        &quot;yellow&quot;)
            echo -e &quot;\033[33m $2 \033[0m&quot; ;;
        &quot;blue&quot;)
            echo -e &quot;\033[34m $2 \033[0m&quot; ;;
        &quot;blue-shining&quot;)
            echo -e &quot;\033[34m \033[05m $2 \033[0m&quot; ;;
        &quot;purple&quot;)
            echo -e &quot;\033[35m $2 \033[0m&quot; ;;
        &quot;green&quot;)
            echo -e &quot;\033[32m $2 \033[0m&quot; ;;
        &quot;*&quot;)
            echo -e &quot;\033[37m $2 \033[0m&quot; ;;
    esac
}

current_dir=`pwd`
num=`echo ${current_dir##*/} | tr -cd &quot;[0-9]&quot;`
if [ ${current_dir##*/} != &quot;hranuser${num}&quot; ]
then
    echo_color red &quot; === Error: Current directory must be end with &#39;/hranuser&#39; ===&quot;
    exit -1
fi
local_dir=&quot;rcp-heat&quot;
stack_type=&quot;net&quot;
if [ ! -d &quot;${local_dir}&quot; ]
then
    mkdir -p ${local_dir}
fi

function _create_image()
{
    RCP_IMAGE_URL=$1
    IMAGE_FILE=${RCP_IMAGE_URL##*/}
    echo_color blue &quot; === Begin to download RCP image to ${local_dir}/${IMAGE_FILE} === &quot;
    wget -O ${local_dir}/${IMAGE_FILE} ${RCP_IMAGE_URL}
    if [ $? -ne 0 ]
    then
        set +x
        echo_color red &quot; === Download image unsuceessfully, please check your image name is right === &quot;
        exit -1
    fi
    echo_color blue &quot; === Download image suceessfully ==== &quot;
    echo_color blue &quot; === Begin to create image === &quot;
    nova image-delete ${IMAGE_FILE}
    glance image-create --name=${IMAGE_FILE} --container-format=bare --visibility=private --disk-format=qcow2 --file=${local_dir}/${IMAGE_FILE}
    glance_status=`nova image-show ${IMAGE_FILE} | grep status | awk &#39;{print $4}&#39;`
    if [ &quot;ACTIVE&quot; != &quot;${glance_status}&quot; ]
    then
        echo_color blue-shining &quot; === Waiting for image active... ==== &quot;
        sleep 5
    fi
    echo_color blue &quot; === Create image suceessfully ==== &quot;
    sleep 3
}

function _download_yaml()
{
    TEMPLATE_FILE=${RCP_TEMPLATE_URL##*/}
    echo_color blue &quot; === Downloading RCP template to ${local_dir}/${TEMPLATE_FILE} === &quot;
    wget -O ${local_dir}/${TEMPLATE_FILE} ${RCP_TEMPLATE_URL}
    if [ $? -ne 0 ]
    then
        set +x
        echo_color red &quot; === Download template unsuceessfully, please check your template file is right === &quot;
        exit -1
    fi
    echo_color blue &quot; === Download template suceessfully ==== &quot;
    ls -l ${local_dir}
    tar -xzvf ${local_dir}/${TEMPLATE_FILE} -C ${local_dir}
    rm -f ${local_dir}/${TEMPLATE_FILE}
}

function _uninstall_old_stack()
{
    echo_color blue &quot; === Begin to uninstall existed stack === &quot;
    ### === used for N34 === ###
    STACK_UUID=`heat stack-list | awk &#39;{print $2}&#39; | awk &#39;NR&gt;2&#39; | awk &#39;{if(length!=0) print $0}&#39;`
    ### === used for touchdown === ###
    # STACK_UUID=`heat stack-list | grep touchdown | awk &#39;{print $2}&#39; | awk &#39;{if(length!=0) print $0}&#39;`
    if [ -n &quot;${STACK_UUID}&quot; ]
    then    
        heat stack-delete ${STACK_UUID}
        while ((1))
        do
            set +x
            STACK_STATUS=`heat stack-list | awk &#39;{print $6}&#39; | awk &#39;NR&gt;2&#39; | awk &#39;{if(length!=0) print $0}&#39;`
            if [ -n &quot;${STACK_STATUS}&quot; ]
            then
                sleep 10
                echo_color blue &quot; === Deleting old stack, please wait... === &quot;
            else
                break
            fi
        done
    fi
    echo_color blue &quot; === Uninstall existed stack successfully === &quot;
}

function _mod_env_file_part()
{
    echo_color blue &quot; === Begin to modify env file... === &quot;
    RCP_IMAGE_URL=$REPLY
    IMAGE_FILE=${RCP_IMAGE_URL##*/}
    rcp_heat_file=&quot;rcp-heat/net/rcp-heat.env&quot;
    sed -i &quot;s/image: .*/image: ${IMAGE_FILE}/g&quot; ${rcp_heat_file}
    echo_color blue &quot; === Modify successfully. === &quot;
}

function _mod_env_file_full()
{
    echo_color blue &quot; === Begin to modify env file... === &quot;
    IMAGE_FILE=${RCP_IMAGE_URL##*/}
    key_name=&quot;default_key&quot;
    cluster_id=&quot;RCP-1234&quot;
    hostname_prefix=&quot;abc&quot;
    cp=&quot;rcp_medium_v2&quot;
    ei=&quot;rcp_xlarge_v2&quot;
    mn=&quot;rcp_large_v2&quot;
    up=&quot;rcp_xlarge_v2&quot;
    uvm=&quot;rcp_medium_v2&quot;
    time_zone=&quot;Asia/Shanghai&quot;
    ### use oam uuid
    #oam_network=&quot;`nova network-list | grep -w &quot;vnfoam &quot; | awk &#39;{print $2}&#39;`&quot;
    ### use oam name
    oam_network=&quot;vnfoam&quot;
    ntp_servers=&quot;10.39.12.252&quot;
    dns_forwarders=&quot;10.56.126.31&quot;
    vif_models=&quot;avp&quot;
    vif_models_2=&quot;virtio&quot;
    _nokadmin=&quot;Nokia123&quot;
    _nokfsoperator=&quot;RCP_owner&quot;
    root=&quot;root&quot;
    ext0=&quot;`nova network-list | grep hran${num} | awk &#39;{print $4}&#39; | awk &#39;NR==1&#39;`&quot;
    ext1=&quot;`nova network-list | grep hran${num} | awk &#39;{print $4}&#39; | awk &#39;NR==2&#39;`&quot;
    ext2=&quot;`nova network-list | grep hran${num} | awk &#39;{print $4}&#39; | awk &#39;NR==3&#39;`&quot;
    number_of_uvm_nodes=&quot;0&quot;
    rcp_heat_file=&quot;rcp-heat/net/rcp-heat.env&quot;
    sed -i &quot;s/image: .*/image: ${IMAGE_FILE}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/key_name: .*/key_name: ${key_name}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/cluster_id: .*/cluster_id: ${cluster_id}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/hostname_prefix: .*/hostname_prefix: ${hostname_prefix}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ cp: .*/ cp: ${cp}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ ei: .*/ ei: ${ei}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ mn: .*/ mn: ${mn}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ up: .*/ up: ${up}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/uvm: .*/uvm: ${uvm}/g&quot; ${rcp_heat_file}
    sed -i &quot;s#time-zone: .*#time-zone: ${time_zone}#g&quot; ${rcp_heat_file}
    sed -i &quot;s/oam_network: .*/oam_network: ${oam_network}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ntp_servers: .*/ntp_servers: ${ntp_servers}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/dns_forwarders: .*/dns_forwarders: ${dns_forwarders}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/_nokadmin: .*/_nokadmin: ${_nokadmin}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/_nokfsoperator: .*/_nokfsoperator: ${_nokfsoperator}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/root: .*/root: ${root}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ext0: .*/ext0: ${ext0}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ext1: .*/ext1: ${ext1}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ext2: .*/ext2: ${ext2}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ external: .*/ external: ${vif_models}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ internal: .*/ internal: ${vif_models_2}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ oam: .*/ oam: ${vif_models}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/number_of_uvm_nodes: .*/number_of_uvm_nodes: ${number_of_uvm_nodes}/g&quot; ${rcp_heat_file}
    nova keypair-add ${key_name}
    echo_color blue &quot; === Modify successfully. === &quot;
}

function _launch_stack()
{
    echo_color blue &quot; === Begin to launch stack === &quot;
    heat stack-create -e ${local_dir}/${stack_type}/rcp-heat.env -f ${local_dir}/${stack_type}/rcp-heat.yaml touchdown_auto
    while ((1))
    do
        set +x
        STACK_STATUS=`heat stack-list | awk &#39;{print $6}&#39; | awk &#39;NR&gt;2&#39; | awk &#39;{if(length!=0) print $0}&#39;`
        if [ &quot;CREATE_COMPLETE&quot; != &quot;${STACK_STATUS}&quot; ]
        then
            sleep 30
            echo_color blue &quot; === Installing, please wait... === &quot;
        else
            break
        fi
    done
    oam=`nova list | grep vnfoam | awk &#39;{print $14}&#39;`
    echo_color blue &quot; === Launch stack successfully, ${oam} === \033[05m ${oam} &quot;
}

function reinstall_stack_1()
{
    _uninstall_old_stack
    _launch_stack
}

function reinstall_stack_2()
{
    _create_image $REPLY
    _uninstall_old_stack
    _mod_env_file_part
    _launch_stack
    rm -f ${local_dir}/${IMAGE_FILE}
}

function reinstall_stack_3()
{
    _download_yaml
    _mod_env_file_full
    _create_image ${RCP_IMAGE_URL}
    _uninstall_old_stack
    _launch_stack
    rm -f ${local_dir}/${IMAGE_FILE}
}


case &quot;$1&quot; in
    1)
      echo &quot;Begin to re-install stack.....&quot;
      reinstall_stack_1
      echo &quot;Script completes!!!!!&quot;
      exit 1
      ;;
    2)
      read -p &quot;Please input specified image url: &quot;
      echo &quot;Begin to re-install stack with image ${REPLY##*/}.....&quot;
      reinstall_stack_2
      echo &quot;Script completes!!!!!&quot;
      exit 1
      ;;
    3)
      read -p &quot;Please input specified image url: &quot; RCP_IMAGE_URL
      read -p &quot;Please input specified yaml url: &quot; RCP_TEMPLATE_URL
      echo &quot;Begin to re-install stack with image ${RCP_IMAGE_URL##*/} and yaml ${RCP_TEMPLATE_URL##*/}.....&quot;
      reinstall_stack_3
      echo &quot;Script completes!!!!!&quot;
      exit 1
      ;;
    *)
      echo &quot;Usage:
            run 1  --- will re-install stack with default image.
            run 2  --- will re-install stack with specified image.
            run 3  --- will re-install stack with specified image and yaml parameter.&quot;
      exit 1
      ;;
esac
exit 0
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Auto Migrate Tools(v2.0)]]></title>
    <link href="https://sparkbye.github.io/myBlog/15161070375181.html"/>
    <updated>2018-01-16T20:50:37+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15161070375181.html</id>
    <content type="html"><![CDATA[
<p>更新了下脚本：<br/>
还是有些问题：<br/>
1. 如果有其他Project的node怎么处理？<br/>
2. 如果有自己的其他node怎么处理？</p>

<pre><code class="language-sh">#!/bin/bash

function echo__blue()      { echo -e &quot;\e[0;34;1m$1\e[0m&quot;;}
function echo__red()       { echo -e &quot;\e[0;31;1m$1\e[0m&quot;;}
function echo__green()     { echo -e &quot;\e[0;32;1m$1\e[0m&quot;;}
function echo__yellow()    { echo -e &quot;\e[0;33;1m$1\e[0m&quot;;}

COMPUTER_LIST=`nova hypervisor-list | awk &#39;{print $4}&#39; | awk &#39;NR&gt;2&#39; | awk &#39;{if(length!=0) print $0}&#39;`
UE_NODE_LIST=`nova list | grep ei | awk &#39;{print $4}&#39;`
UE_NODE_NAME=`nova list | grep ei-0 | awk &#39;{print $4}&#39;`
OTHER_NODE_LIST=`nova list --fields name | grep -v ei | awk &#39;NR&gt;2&#39; | awk &#39;{print $4}&#39; | awk &#39;{if(length!=0) print $0}&#39;`
OPTIMAL_COMPUTE=&#39;&#39;
INFERIOR_COMPUTE=&#39;&#39;
INIT_USED=8.0

for COMPUTER in $COMPUTER_LIST
    do
        CPUS_USED=`nova hypervisor-show $COMPUTER | grep -i &quot;vcpus_used&quot; | awk &#39;{print $4}&#39; | head -1`
        echo__blue &quot;$COMPUTER node&#39;s vcpus_used is :  $CPUS_USED&quot;
        if [[ $(echo &quot;$CPUS_USED == 0.0&quot;|bc) = 1 ]];then
            echo__blue &quot;Greate! $COMPUTER is a optimal computer.&quot;
            OPTIMAL_COMPUTER=$COMPUTER
            break
        elif [[ $(echo &quot;$CPUS_USED &gt; 0.0&quot;|bc) = 1 ]] &amp;&amp; [[ $(echo &quot;$CPUS_USED &lt; 8.0 &quot;|bc) = 1 ]];then
            echo__green &quot;Maybe $COMPUTER is a selectable computer.&quot;
            if [[ $(echo &quot;$CPUS_USED &lt; $INIT_USED&quot;|bc) = 1 ]];then
                INIT_USED=$CPUS_USED
                INFERIOR_COMPUTE=$COMPUTER
                echo__blue &quot;Now OPTIMAL_COMPUTER is: $COMPUTER.&quot;
            fi
        elif [[ $(echo &quot;$CPUS_USED &gt;= 8.0&quot;|bc) = 1 ]] &amp;&amp; [[ $(echo &quot;$CPUS_USED &lt;= 13.0 &quot;|bc) = 1 ]];then
            echo__red &quot;Maybe $COMPUTER is not a good choice.&quot;
            INSTANCE_NUMBER=`nova hypervisor-servers compute-159 | awk &#39;{print $4}&#39; | awk &#39;NR&gt;2&#39; | awk &#39;{if(length!=0) print $0}&#39; | wc -l`
            USED_RATE=$(echo &quot;$CPUS_USED / $INSTANCE_NUMBER&quot; | bc)
            echo &quot;===========USED_RATE: $USED_RATE=============&quot;
            if [[ $(echo &quot;$USED_RATE &lt; $INIT_USED&quot;|bc) = 1 ]];then
                INIT_USED=$USED_RATE
                echo &quot;===========INIT_USED: $INIT_USED=============&quot;
                INFERIOR_COMPUTE=$COMPUTER
                echo__blue &quot;Now OPTIMAL_COMPUTER is: $COMPUTER.&quot;
            else
                continue
            fi
        else
            echo__red &quot;This computer node is full.&quot;
        fi
    done
    echo &quot;===========Finally the chosen computer is : 1. $OPTIMAL_COMPUTER  2. $INFERIOR_COMPUTE.==============&quot;

for INSTANCE_NAME in $OTHER_NODE_LIST
        do
            UE_COMPUTE=`nova list --fields name,host,wrs-res:topology | grep $INSTANCE_NAME | awk &#39;{print $6}&#39;`
            CPUS_USED=`nova hypervisor-show $UE_COMPUTE | grep -i &quot;vcpus_used&quot; | awk &#39;{print $4}&#39; | head -1`
            echo__blue &quot;$UE_COMPUTE node&#39;s vcpus_used is :  $CPUS_USED&quot;
            if [[ $(echo &quot;$CPUS_USED == 8.0&quot;|bc) = 1 ]];then
                echo__blue &quot;Greate! $UE_COMPUTE is a optimal computer.&quot;
                OPTIMAL_COMPUTER=$UE_COMPUTE
                break
            else
                continue
            fi
        done
    echo__red &quot;All UE instance are not stand alone.&quot;

for INSTANCE_NAME in $UE_NODE_LIST
        do
            UE_COMPUTE=`nova list --fields name,host,wrs-res:topology | grep $INSTANCE_NAME | awk &#39;{print $6}&#39;`
            CPUS_USED=`nova hypervisor-show $UE_COMPUTE | grep -i &quot;vcpus_used&quot; | awk &#39;{print $4}&#39; | head -1`
            echo__blue &quot;$UE_COMPUTE node&#39;s vcpus_used is :  $CPUS_USED&quot;
            if [[ $(echo &quot;$CPUS_USED == 8.0&quot;|bc) = 1 ]];then
                echo__blue &quot;Greate! $UE_COMPUTE is a optimal computer.&quot;
                OPTIMAL_COMPUTER=$UE_COMPUTE
                break
            else
                continue
            fi
        done
    echo__red &quot;All other instance are not stand alone.&quot;

echo__green &quot;==============Begin to migrate UE node to $OPTIMAL_COMPUTER.=====================&quot;
if [[ -z &quot;$OPTIMAL_COMPUTER&quot; ]];then
    for UE_NODE in $UE_NODE_LIST
        do
            nova live-migration $UE_NODE $OPTIMAL_COMPUTER
            sleep 5
            if [ &quot;Running&quot; != &quot;$UE_NODE_STATE&quot; ];then
                echo &quot;Still migrating, please wait...&quot;
                sleep 5     
            fi
        done
else
    for UE_NODE in $UE_NODE_LIST
        do
            nova live-migration $UE_NODE $INFERIOR_COMPUTE
            sleep 5
            if [ &quot;Running&quot; != &quot;$UE_NODE_STATE&quot; ];then
                echo &quot;Still migrating, please wait...&quot;
                sleep 5     
            fi
        done   
fi

echo__green &quot;Live migration is successfully.&quot;
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python对象的浅拷贝与深拷贝]]></title>
    <link href="https://sparkbye.github.io/myBlog/15156751072902.html"/>
    <updated>2018-01-11T20:51:47+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15156751072902.html</id>
    <content type="html"><![CDATA[
<p>我们知道，对象赋值实际上是简单的对象引用。也就是说，当你创建了一个对象，然后把它赋值给另外一个变量的时候，Python并没有拷贝这个对象，而是拷贝了这个对象的引用。<br/>
举例说明：</p>

<pre><code class="language-python">x = 3.14
y = x
</code></pre>

<p>语句<code>x = 3.14</code>创建了一个浮点型对象并将其引用赋值给x。<br/>
x是第一个引用。<br/>
语句<code>y = x</code>创建了一个指向同一对象的别名y，而事实上并没有为y创建一个新对象(该对象引用计数变成了2)。<br/>
<img src="media/15156751072902/15156757071783.jpg" alt=""/></p>

<h3 id="toc_0">对象赋值</h3>

<p>直接看一段代码：</p>

<pre><code class="language-python">will = [&quot;Will&quot;, 28, [&quot;Python&quot;, &quot;C#&quot;, &quot;JavaScript&quot;]]
wilber = will
print id(will)
print will
print [id(ele) for ele in will]
print id(wilber)
print wilber
print [id(ele) for ele in wilber]

will[0] = &quot;Wilber&quot;
will[2].append(&quot;CSS&quot;)
print id(will)
print will
print [id(ele) for ele in will]
print id(wilber)
print wilber
print [id(ele) for ele in wilber]
</code></pre>

<p>代码的输出为：<br/>
<img src="media/15156751072902/15156770585054.png" alt=""/></p>

<p>下面来分析一下这段代码：</p>

<ul>
<li>首先，创建了一个名为will的变量，这个变量指向一个list对象，从第一张图中可以看到所有对象的地址（每次运行，结果可能不同）</li>
<li>然后，通过will变量对wilber变量进行赋值，那么wilber变量将指向will变量对应的对象（内存地址），也就是说&quot;wilber is will&quot;，&quot;wilber[i] is will[i]&quot;

<ul>
<li>可以理解为，Python中，对象的赋值都是进行对象引用（内存地址）传递</li>
</ul></li>
<li>第三张图中，由于will和wilber指向同一个对象，所以对will的任何修改都会体现在wilber上

<ul>
<li>这里需要注意的一点是，str是不可变类型，所以当修改的时候会替换旧的对象，产生一个新的地址39758496
<img src="media/15156751072902/15156771227464.png" alt=""/></li>
</ul></li>
</ul>

<h3 id="toc_1">浅拷贝</h3>

<p>下面就来看看浅拷贝的结果：</p>

<pre><code class="language-python">import copy

will = [&quot;Will&quot;, 28, [&quot;Python&quot;, &quot;C#&quot;, &quot;JavaScript&quot;]]
wilber = copy.copy(will)

print id(will)
print will
print [id(ele) for ele in will]
print id(wilber)
print wilber
print [id(ele) for ele in wilber]

will[0] = &quot;Wilber&quot;
will[2].append(&quot;CSS&quot;)
print id(will)
print will
print [id(ele) for ele in will]
print id(wilber)
print wilber
print [id(ele) for ele in wilber]
</code></pre>

<p>代码的输出结果如下：<br/>
<img src="media/15156751072902/15156771638072.png" alt=""/><br/>
分析一下这段代码：</p>

<ul>
<li>首先，依然使用一个will变量，指向一个list类型的对象</li>
<li>然后，通过copy模块里面的浅拷贝函数copy()，对will指向的对象进行浅拷贝，然后浅拷贝生成的新对象赋值给wilber变量

<ul>
<li>浅拷贝会创建一个新的对象，这个例子中&quot;wilber is not will&quot;</li>
<li>但是，对于对象中的元素，浅拷贝就只会使用原始元素的引用（内存地址），也就是说&quot;wilber[i] is will[i]&quot;</li>
</ul></li>
<li>当对will进行修改的时候

<ul>
<li>由于list的第一个元素是不可变类型，所以will对应的list的第一个元素会使用一个新的对象39758496</li>
<li>但是list的第三个元素是一个可不类型，修改操作不会产生新的对象，所以will的修改结果会相应的反应到wilber上
<img src="media/15156751072902/15156771821899.png" alt=""/>
总结一下，当我们使用下面的操作的时候，会产生浅拷贝的效果：</li>
</ul></li>
<li>使用切片[:]操作</li>
<li>使用工厂函数（如list/dir/set）</li>
<li>使用copy模块中的copy()函数
例如：</li>
</ul>

<pre><code class="language-python">will = [&quot;Will&quot;, 28, [&quot;Python&quot;, &quot;C#&quot;, &quot;JavaScript&quot;]]
willber = will[:]
wiww = list(will)
</code></pre>

<h3 id="toc_2">深拷贝</h3>

<p>最后来看看深拷贝：</p>

<pre><code class="language-python">import copy

will = [&quot;Will&quot;, 28, [&quot;Python&quot;, &quot;C#&quot;, &quot;JavaScript&quot;]]
wilber = copy.deepcopy(will)

print id(will)
print will
print [id(ele) for ele in will]
print id(wilber)
print wilber
print [id(ele) for ele in wilber]

will[0] = &quot;Wilber&quot;
will[2].append(&quot;CSS&quot;)
print id(will)
print will
print [id(ele) for ele in will]
print id(wilber)
print wilber
print [id(ele) for ele in wilber]
</code></pre>

<p>代码的输出结果如下：<br/>
<img src="media/15156751072902/15156773634373.png" alt=""/></p>

<p>分析一下这段代码：</p>

<ul>
<li>首先，同样使用一个will变量，指向一个list类型的对象</li>
<li>然后，通过copy模块里面的深拷贝函数deepcopy()，对will指向的对象进行深拷贝，然后深拷贝生成的新对象赋值给wilber变量

<ul>
<li>跟浅拷贝类似，深拷贝也会创建一个新的对象，这个例子中&quot;wilber is not will&quot; </li>
<li>但是，对于对象中的元素，深拷贝都会重新生成一份（有特殊情况，下面会说明），而不是简单的使用原始元素的引用（内存地址）

<ul>
<li>例子中will的第三个元素指向39737304，而wilber的第三个元素是一个全新的对象39773088，也就是说，&quot;wilber[2] is not will[2]&quot;</li>
</ul></li>
</ul></li>
<li>当对will进行修改的时候

<ul>
<li>由于list的第一个元素是不可变类型，所以will对应的list的第一个元素会使用一个新的对象39758496</li>
<li>但是list的第三个元素是一个可不类型，修改操作不会产生新的对象，但是由于&quot;wilber[2] is not will[2]&quot;，所以will的修改不会影响wilber
<img src="media/15156751072902/15156773891985.png" alt=""/></li>
</ul></li>
</ul>

<h3 id="toc_3">拷贝的特殊情况</h3>

<p>其实，对于拷贝有一些特殊情况：</p>

<ul>
<li>对于非容器类型（如数字、字符串、和其他&#39;原子&#39;类型的对象）没有拷贝这一说

<ul>
<li>也就是说，对于这些类型，&quot;obj is copy.copy(obj)&quot; 、&quot;obj is copy.deepcopy(obj)&quot;</li>
</ul></li>
<li>如果元祖变量只包含原子类型对象，则不能深拷贝，看下面的例子
<img src="media/15156751072902/15156774222287.png" alt=""/></li>
</ul>

<h3 id="toc_4">总结</h3>

<p>本文介绍了对象的赋值和拷贝，以及它们之间的差异：<br/>
* Python中对象的赋值都是进行对象引用（内存地址）传递<br/>
* 使用copy.copy()，可以进行对象的浅拷贝，它复制了对象，但对于对象中的元素，依然使用原始的引用.<br/>
* 如果需要复制一个容器对象，以及它里面的所有元素（包含元素的子元素），可以使用copy.deepcopy()进行深拷贝<br/>
* 对于非容器类型（如数字、字符串、和其他&#39;原子&#39;类型的对象）没有被拷贝一说<br/>
* 如果元祖变量只包含原子类型对象，则不能深拷贝.</p>

<p>文章引用：<br/>
<a href=""></a><a href="https://www.cnblogs.com/wilber2013/p/4645353.html">https://www.cnblogs.com/wilber2013/p/4645353.html</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pyhton变量变换原理]]></title>
    <link href="https://sparkbye.github.io/myBlog/15142967450536.html"/>
    <updated>2017-12-26T21:59:05+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15142967450536.html</id>
    <content type="html"><![CDATA[
<p>我们在C语言中实现变量交换，往往会使用到通过中间变量来交换两个变量的值：</p>

<pre><code class="language-C">tmp = x;
x = y;
y = tmp;
</code></pre>

<p>而在python中，则无需中间变量即可实现：</p>

<pre><code class="language-python">x , y = y, x
</code></pre>

<p>看起来很神奇，那么具体实现机制是什么呢？<br/>
将这个之前，我们先来了解python的多元赋值机制(《python核心编程3.2》)。通常形式是这样的：</p>

<pre><code class="language-python">x, y , z = 1, 2, &#39;a string&#39;
</code></pre>

<p>采取这种方式的赋值是，等号两边的对象其实都是元祖，即：</p>

<pre><code class="language-python">(x, y, z) = (1, 2, &#39;a string&#39;)
</code></pre>

<p>变量名x, y, z都是引用，内存开辟除了三个空间分别存储1, 2, &#39;a string&#39;，三个变量分别指向这三块地址。由这三个变量构造的元组tuple，<strong>它有三个元素，这三个元素并不是x,y,z这三个变量，而是这三个变量所指向的地址空间里的内容</strong>。如果此时再另x=4,此时在地址空间会另开辟出一块空间存储4，x进而指向这块空间，而元组内的三个值仍保持不变。<br/>
接着我们来解读x, y = y, x， 同样， 它等价于(x, y) = (y, x)。<br/>
运行时，首先构造一个元组(y, x)，然后构造另一个元组(x, y)，接着用元组(y, x)赋值给(x, y)，元组赋值过程从左到右，依次进行。假如x=1,y=2，先令x=y,此时x=2,然后令y=x,y等于1。<br/>
<img src="media/15142967450536/15142979681246.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Unittest与Mock]]></title>
    <link href="https://sparkbye.github.io/myBlog/15142936231027.html"/>
    <updated>2017-12-26T21:07:03+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15142936231027.html</id>
    <content type="html"><![CDATA[
<p><strong>unittest</strong><br/>
python内部自带了一个单元测试的模块，pyUnit也就是我们说的：unittest<br/>
python unittest的框架如下： <br/>
<img src="media/15142936231027/15142937307631.png" alt=""/><br/>
基本使用方法如下：</p>

<ol>
<li>import unittest module</li>
<li>定义一个继承自unittest.TestCase的测试用例类。</li>
<li>定义setUp和tearDown，在每个测试用例前后做一些辅助工作。</li>
<li>定义测试用例，名字需要以test开头。</li>
<li>一个测试用例原则上只测试一个方面，测试目的和测试内容应很明确。主要是调用assertEqual、assertRaises等断言方法判断程序执行结果和预期值是否相符。</li>
<li>调用unittest.main()启动测试</li>
<li>如果测试未通过，会输出相应的错误提示。如果测试全部通过则不显示任何东西，这时可以添加-v参数显示详细信息。</li>
</ol>

<p>这里举个简单的例子说明：<br/>
<img src="media/15142936231027/15142939572020.png" alt=""/></p>

<p>常用的断言：<br/>
<img src="media/15142936231027/15142939778044.png" alt=""/></p>

<p><strong>Mock</strong></p>

]]></content>
  </entry>
  
</feed>
