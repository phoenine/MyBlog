<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Ascetic in the deadlock]]></title>
  <link href="https://sparkbye.github.io/myBlog/atom.xml" rel="self"/>
  <link href="https://sparkbye.github.io/myBlog/"/>
  <updated>2020-06-22T18:08:10+08:00</updated>
  <id>https://sparkbye.github.io/myBlog/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[【pythonic】详解Python 3.8的海象算子]]></title>
    <link href="https://sparkbye.github.io/myBlog/15928352455072.html"/>
    <updated>2020-06-22T22:14:05+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15928352455072.html</id>
    <content type="html"><![CDATA[
<p>最近，Python 社区发布了该语言的 3.8 版本。作为 Python 语法糖的爱好者，我探索了发布说明，关注到了其中一个独特的算子。这个算子被称为「海象算子（Walrus Operator）」或「命名表达式算子（Named Expression operator）」，符号为「:=」。</p>

<h2 id="toc_0"><b>海象算子</b></h2>

<blockquote>
<p>官网介绍：Assignment expressions（赋值表达式）<br/>
There is new syntax := that assigns values to variables as part of a larger expression. It is affectionately known as “the walrus operator” due to its resemblance to the eyes and tusks of a walrus.</p>
</blockquote>

<p>这个新算子（:=）能让我们为表达式中的一个变量赋值。这个符号看起来颇有些类似于海象的眼睛和犬齿。</p>

<p>我们先来看看下面一段代码：</p>

<pre><code class="language-python">countries = [&quot;India&quot;, &quot;USA&quot;, &quot;France&quot;, &quot;Germany&quot;]
</code></pre>

<pre><code class="language-python">if len(countries) &lt; 5:
    print(&quot;Length of countries is {}&quot;.format(len(countries)))
</code></pre>

<pre><code>Length of countries is 4
</code></pre>

<p>在上面的代码段中，我们两次调用了函数 len()。我们可以避免重复计算以提升可读性吗？当然可以，我们可对这段代码进行如下改进：</p>

<pre><code class="language-python">country_size = len(countries)
if country_size &lt; 5:
    print (&quot;Length of countries is {}&quot;.format(country_size))
</code></pre>

<pre><code>Length of countries is 4
</code></pre>

<p>还有进一步改进的空间吗？我们可以不用单独一行来给「country_size」赋值吗？</p>

<pre><code class="language-python">if (country_size := len(countries)) &lt; 5 :
        print (&quot;Length of countries is {}&quot;.format(country_size))
</code></pre>

<pre><code>Length of countries is 4
</code></pre>

<p>这就是 Python 3.8 引入的海象算子的用武之地。我们可以在 if 语句之中直接执行声明和赋值操作。我们下面进一步探索该算子的能力。</p>

<h2 id="toc_1"><b>代码行数与复杂度的平衡</b></h2>

<p>先看看以下示例:</p>

<pre><code class="language-python">def get_count():
    &quot;Fetches count of records from a database&quot;
    return 100
    
powers = [get_count(), get_count()**2, get_count()**3]
print(powers)
</code></pre>

<pre><code>[100, 10000, 1000000]
</code></pre>

<p>上面的示例是通过多次调用一个高成本的函数 get_count() 来填充一个列表。 </p>

<p>有了海象算子的帮助，我们可以避免多次调用函数 get_count()，其具体的功能是将结果存储到一个变量中，然后我们可在后续的计算中复用同一个变量。下面演示了海象算子的用法：</p>

<pre><code class="language-python">powers =[result:= get_count(), result**2, result**3]
print(powers)
</code></pre>

<pre><code>[100, 10000, 1000000]
</code></pre>

<p>从上面的例子可以看到，海象算子可以减少代码行数，让代码更可读，因此能简化代码审查人员的工作。此外，这也能实现代码行数和代码复杂度的平衡。</p>

<h2 id="toc_2"><b>解决理解低效的问题</b></h2>

<p>看下面这个例子：</p>

<pre><code class="language-python">employees = []
employee_ids = {1:&quot;Tommy&quot;, 2:&quot;Tobey&quot;, 3:&quot;Evan&quot;, 4:&quot;Golf&quot;}
for key in employee_ids:
    employee = employee_ids[key]
    if employee:
        employees.append(employee)
print(employees)
</code></pre>

<pre><code>[&#39;Tommy&#39;, &#39;Tobey&#39;, &#39;Evan&#39;, &#39;Golf&#39;]
</code></pre>

<p>上面的示例需要多次执行循环。一开始，我们创建一个空列表，然后在 id 列表上迭代并通过检查结果是否有效来填充我们创建的列表。</p>

<p>我们可以简化上面的代码，将其浓缩为一行：</p>

<pre><code class="language-python">employees = [result for key in employee_ids if (result:= employee_ids[key])]
print(employees)
</code></pre>

<pre><code>[&#39;Tommy&#39;, &#39;Tobey&#39;, &#39;Evan&#39;, &#39;Golf&#39;]
</code></pre>

<h2 id="toc_3"><b>文件分块处理</b></h2>

<p>在处理大文件时，我们会将文件分块读取。每当读取一个分块时，都会检查它的值，并且该值也是 while 循环的终止条件。</p>

<pre><code class="language-python">chunk = file.read(256)

while chunk:
    process(chunk)
    chunk = file.read(256)
</code></pre>

<p>我们可以在 while 循环表达式中读取数据以及为要读取的数据赋值。由此我们就能避免在 while 循环之外显式地声明变量。如下示例：</p>

<pre><code class="language-python">while (chunk := file.read(256)):
    process(chunk)
</code></pre>

<h2 id="toc_4"><b>正则表达式匹配</b></h2>

<p>正则表达式匹配是一个两步式过程。第一步是检查是否有匹配，第二步是提取匹配的部分。</p>

<pre><code class="language-python">import re
obj = re.match(r&quot;(\d+)\.(\d+)&quot;, &quot;24.1632&quot;).group(1) if re.match(r&quot;(\d+)\.(\d+)&quot;, &quot;24.1632&quot;) else None
print(obj)
</code></pre>

<pre><code>24
</code></pre>

<p>从上面的代码可以观察到，我们在一次匹配中重复计算了 re.match(r&quot;(\d+).(\d+)&quot;, &quot;24.1632&quot;)。这会减慢该程序的执行速度，而且数据量越大减慢得越明显。上面的代码可以重写为如下形式，从而避免重复计算：</p>

<pre><code class="language-python">obj = match.group(1) if (match := re.match(r&quot;(\d+)\.(\d+)&quot;, &quot;24.1632&quot;)) else None
print(obj)
</code></pre>

<pre><code>24
</code></pre>

<h2 id="toc_5"><b>不能使用海象算子的地方</b></h2>

<h3 id="toc_6">为变量赋值</h3>

<pre><code class="language-python">a = 5 # 有效
a := 5 # 无效
</code></pre>

<pre><code>  File &quot;&lt;ipython-input-50-7471f449f795&gt;&quot;, line 2
    a := 5 # 无效
      ^
SyntaxError: invalid syntax
</code></pre>

<pre><code class="language-python">empty_list = [] # 有效
empty_list := [] # 无效
</code></pre>

<pre><code>  File &quot;&lt;ipython-input-51-c637bed9e3c4&gt;&quot;, line 2
    empty_list := [] # 无效
               ^
SyntaxError: invalid syntax
</code></pre>

<p>如上所示，我们不能使用 := 替代 =。海象算子只能是一个表达式的一部分。</p>

<h3 id="toc_7">加法/减法赋值</h3>

<pre><code class="language-python">a += 5 # 有效
a :+=5 # 无效
</code></pre>

<pre><code>  File &quot;&lt;ipython-input-52-d36dacdf957b&gt;&quot;, line 2
    a :+=5 # 无效
       ^
SyntaxError: invalid syntax
</code></pre>

<h3 id="toc_8">在 lambda 函数中为表达式赋值</h3>

<pre><code class="language-python">(lambda: a:= 5) # 无效
(lambda: (a := 5)) # 有效但无用
(var := lambda: 5) # 有效
</code></pre>

<pre><code>  File &quot;&lt;ipython-input-53-257421e1abae&gt;&quot;, line 1
    (lambda: a:= 5) # 无效
     ^
SyntaxError: cannot use named assignment with lambda
</code></pre>

<h3 id="toc_9">PEP-572 及其争议</h3>

<p>海象算子是作为 PEP-572（Python 改进提议）的一部分而引入的。如果要为 Python 语言引入一项新功能，总是需要经由 PEP 来实现，而且必须得到 Python 的发明者 Guido van Rossum 或他选择的代表的批准。</p>

<p>围绕海象算子的争议非常多，而且由此引发的「战争」导致了 Python 之父 Guido van Rossum 告退，不再担任 Python 社区的终身仁慈独裁者（BDFL）。海象算子的争议点有很多，下面是其中几个：</p>

<ul>
<li>句法变化问题：开发者们为 := 提议了多种替代方案，比如「表达式 -&gt; NAME」、「NAME -&gt; 表达式」、「{表达式} NAME」等等。少数人建议使用现有的关键字，其他人则使用了新的算子。</li>
<li>后向兼容问题：这个特性无法向后兼容，也无法运行在之前的 Python 版本上。</li>
<li>算子名称问题：人们建议不要使用「海象算子」这样的代号，而是使用「赋值算子」、「命名表达式算子」、「成为算子」等术语，以免人们不明白。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift基本语法]]></title>
    <link href="https://sparkbye.github.io/myBlog/15726710349835.html"/>
    <updated>2019-11-02T13:03:54+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15726710349835.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">1. Swift交互式解释器</h3>

<h4 id="toc_1">1.1 Terminal上运行swift进入REPL解释器</h4>

<pre><code class="language-swift">  1&gt; let a = &quot;100&quot;
a: String = &quot;100&quot;
  2&gt; Int(a)
$R0: Int? = 100
  3&gt; let b = $R0 + 50
error: repl.swift:3:9: error: value of optional type &#39;Int?&#39; must be unwrapped to a value of type &#39;Int&#39;
let b = $R0 + 50
        ^

repl.swift:3:9: note: coalesce using &#39;??&#39; to provide a default when the optional value contains &#39;nil&#39;
let b = $R0 + 50
        ^
        (   ?? &lt;#default value#&gt;)

repl.swift:3:9: note: force-unwrap using &#39;!&#39; to abort execution if the optional value contains &#39;nil&#39;
let b = $R0 + 50
        ^
           !
  3&gt; let b = $R0! + 50
b: Int = 150
</code></pre>

<blockquote>
<p>$R0 : Int?  </p>
</blockquote>

<p>可选值， 需要解包</p>

<h4 id="toc_2">1.2 swift palyground 学习的乐园</h4>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[]]></title>
    <link href="https://sparkbye.github.io/myBlog/15726710075785.html"/>
    <updated>2019-11-02T13:03:27+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15726710075785.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Modules - 03 - Python itertools]]></title>
    <link href="https://sparkbye.github.io/myBlog/15662172714318.html"/>
    <updated>2019-08-19T20:21:11+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15662172714318.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">Module-1: itertools 模块总结</h4>

<p>我们知道，迭代器的特点是：惰性求值（Lazy evaluation），即只有当迭代至某个值时，它才会被计算，这个特点使得迭代器特别适合于遍历大文件或无限集合等，因为我们不用一次性将它们存储在内存中。</p>

<p>Python 内置的 itertools 模块包含了一系列用来产生不同类型迭代器的函数或类，这些函数的返回都是一个迭代器，我们可以通过 for 循环来遍历取值，也可以使用 next() 来取值。<br/><br/>
itertools 模块提供的迭代器函数有以下几种类型：<br/>
- 无限迭代器：生成一个无限序列，比如自然数序列 1, 2, 3, 4, ...；<br/>
- 有限迭代器：接收一个或多个序列（sequence）作为参数，进行组合、分组和过滤等；<br/>
- 组合生成器：序列的排列、组合，求序列的笛卡儿积等；</p>

<pre><code class="language-python">import itertools
</code></pre>

<p><b>无限迭代器</b></p>

<p>itertools 模块提供了三个函数（事实上，它们是类）用于生成一个无限序列迭代器：<br/>
- count(firstval=0, step=1)创建一个从 firstval (默认值为 0) 开始，以 step (默认值为 1) 为步长的的无限整数迭代器<br/>
- cycle(iterable)对 iterable 中的元素反复执行循环，返回迭代器<br/>
- repeat(object [,times]反复生成 object，如果给定 times，则重复次数为 times，否则为无限</p>

<ol>
<li><b>count</b></li>
</ol>

<p>count() 接收两个参数，第一个参数指定开始值，默认为 0，第二个参数指定步长，默认为 1：</p>

<pre><code class="language-python">nums = itertools.count()
for i in nums:
    if i &gt; 5:
        break
    print(i)
</code></pre>

<pre><code>0
1
2
3
4
5
</code></pre>

<pre><code class="language-python">nums = itertools.count(10, 2)
for i in nums:
    if i &gt; 20:
        break
    print(i)
</code></pre>

<pre><code>10
12
14
16
18
20
</code></pre>

<ol>
<li><b>cycle</b></li>
</ol>

<p>cycle() 用于对 iterable 中的元素反复执行循环：</p>

<pre><code class="language-python">cycle_strings = itertools.cycle(&#39;ABC&#39;)
i = 1
for string in cycle_strings:
    if i == 10:
        break
    print(i, string)
    i += 1
</code></pre>

<pre><code>1 A
2 B
3 C
4 A
5 B
6 C
7 A
8 B
9 C
</code></pre>

<ol>
<li><b>repeat</b></li>
</ol>

<p>repeat() 用于反复生成一个 object：</p>

<pre><code class="language-python">for item in itertools.repeat(&#39;hello world&#39;, 3):
    print(item)
</code></pre>

<pre><code>hello world
hello world
hello world
</code></pre>

<p><b>有限迭代器</b></p>

<p>itertools 模块提供了多个函数（类），接收一个或多个迭代对象作为参数，对它们进行组合、分组和过滤等：<br/>
- chain()<br/>
- compress()<br/>
- dropwhile()<br/>
- groupby()<br/>
- ifilter()<br/>
- ifilterfalse()<br/>
- islice()<br/>
- imap()<br/>
- starmap()<br/>
- tee()<br/>
- takewhile()<br/>
- izip()<br/>
- izip_longest()</p>

<ol>
<li><b>chain</b></li>
</ol>

<p>chain 的使用形式如下：</p>

<blockquote>
<p>chain(iterable1, iterable2, iterable3, ...)     </p>
</blockquote>

<p>chain 接收多个可迭代对象作为参数，将它们『连接』起来，作为一个新的迭代器返回。</p>

<pre><code class="language-python">from itertools import chain
for item in chain([1, 2, 3], [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]):
    print(item)
</code></pre>

<pre><code>1
2
3
a
b
c
</code></pre>

<p>chain 还有一个常见的用法：</p>

<blockquote>
<p>chain.from_iterable(iterable)</p>
</blockquote>

<p>接收一个可迭代对象作为参数，返回一个迭代器：</p>

<pre><code class="language-python">#扁平列表
a = [[1, 2], [3, 4], [5, 6]]
b = list(chain.from_iterable(a))
print(b)

#还有个更有意思的扁平列表
print(sum(a, []))

str = chain.from_iterable(&#39;ABCDEF&#39;)
# 注意python3是next(), python2是.next()
print(next(str))
</code></pre>

<pre><code>[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
A
</code></pre>

<ol>
<li><b>compress</b></li>
</ol>

<p>compress 的使用形式如下：</p>

<blockquote>
<p>compress(data, selectors)</p>
</blockquote>

<p>compress 可用于对数据进行筛选，当 selectors 的某个元素为 true 时，则保留 data 对应位置的元素，否则去除：</p>

<pre><code class="language-python">from itertools import compress
a = list(compress(&#39;ABCDEF&#39;, [1, 1, 0, 1, 0, 1]))
print(a)
b = list(compress(&#39;ABCDEF&#39;, [1, 1, 0, 1]))
print(b)
c = list(compress(&#39;ABCDEF&#39;, [True, False, True]))
print(c)
</code></pre>

<pre><code>[&#39;A&#39;, &#39;B&#39;, &#39;D&#39;, &#39;F&#39;]
[&#39;A&#39;, &#39;B&#39;, &#39;D&#39;]
[&#39;A&#39;, &#39;C&#39;]
</code></pre>

<ol>
<li><b>dropwhile</b></li>
</ol>

<p>dropwhile 的使用形式如下：</p>

<blockquote>
<p>dropwhile(predicate, iterable)</p>
</blockquote>

<p>其中，predicate 是函数，iterable 是可迭代对象。对于 iterable 中的元素，如果 predicate(item) 为 true，则丢弃该元素，否则返回该项及所有后续项。<br/><br/>
predicate 断言，断定。 注意其返回项是丢弃元素判定失败后的后续项</p>

<pre><code class="language-python">from itertools import dropwhile
a = list(dropwhile(lambda x: x &lt; 5, [1, 3, 6, 2, 1]))
print(a)
b = list(dropwhile(lambda x: x &gt; 3, [2, 1, 6, 5, 4]))
print(b)
</code></pre>

<pre><code>[6, 2, 1]
[2, 1, 6, 5, 4]
</code></pre>

<ol>
<li><b>groupby</b></li>
</ol>

<p>groupby 用于对序列进行分组，它的使用形式如下：</p>

<blockquote>
<p>groupby(iterable[, keyfunc])</p>
</blockquote>

<p>其中，iterable 是一个可迭代对象，keyfunc 是分组函数，用于对 iterable 的连续项进行分组，如果不指定，则默认对 iterable 中的连续相同项进行分组，返回一个 (key, sub-iterator) 的迭代器。</p>

<pre><code class="language-python">from itertools import groupby
for key, value_iter in groupby(&#39;aaabbbaaccd&#39;):
    print(key, &#39;:&#39;, list(value_iter))
print(&quot;================================&quot;)
data = [&#39;a&#39;, &#39;bb&#39;, &#39;ccc&#39;, &#39;dd&#39;, &#39;eee&#39;, &#39;f&#39;]
for key, value_iter in groupby(data, len):   # 使用 len 函数作为分组函数
    print(key, &#39;:&#39;, list(value_iter))
print(&quot;================================&quot;)
data = [&#39;a&#39;, &#39;bb&#39;, &#39;cc&#39;, &#39;ddd&#39;, &#39;eee&#39;, &#39;f&#39;]
for key, value_iter in groupby(data, len):
    print(key, &#39;:&#39;, list(value_iter))
</code></pre>

<pre><code>a : [&#39;a&#39;, &#39;a&#39;, &#39;a&#39;]
b : [&#39;b&#39;, &#39;b&#39;, &#39;b&#39;]
a : [&#39;a&#39;, &#39;a&#39;]
c : [&#39;c&#39;, &#39;c&#39;]
d : [&#39;d&#39;]
================================
1 : [&#39;a&#39;]
2 : [&#39;bb&#39;]
3 : [&#39;ccc&#39;]
2 : [&#39;dd&#39;]
3 : [&#39;eee&#39;]
1 : [&#39;f&#39;]
================================
1 : [&#39;a&#39;]
2 : [&#39;bb&#39;, &#39;cc&#39;]
3 : [&#39;ddd&#39;, &#39;eee&#39;]
1 : [&#39;f&#39;]
</code></pre>

<ol>
<li><b>ifilter</b> (Python3已不再提供)</li>
</ol>

<p>ifilter 的使用形式如下：</p>

<blockquote>
<p>ifilter(function or None, sequence)</p>
</blockquote>

<p>将 iterable 中 function(item) 为 True 的元素组成一个迭代器返回，如果 function 是 None，则返回 iterable 中所有计算为 True 的项。</p>

<pre><code class="language-python">#from itertools import ifilter          # Python3已经不再提供，python3使用filter()

#a = list(ifilter(lambda x: x &lt; 6, range(10)))
a = list(filter(lambda x: x &lt; 6, range(10)))
print(a)
#b = list(ifilter(None, [0, 1, 2, 0, 3, 4]))
b = list(filter(None, [0, 1, 2, 0, 3, 4]))
print(b)
</code></pre>

<pre><code>[0, 1, 2, 3, 4, 5]
[1, 2, 3, 4]
</code></pre>

<ol>
<li><b>ifilterfalse</b> (Python3已不再提供)</li>
</ol>

<p>ifilterfalse 的使用形式和 ifilter 类似，它将 iterable 中 function(item) 为 False 的元素组成一个迭代器返回，如果 function 是 None，则返回 iterable 中所有计算为 False 的项。</p>

<pre><code class="language-python">#from itertools import ifilterfalse
#list(ifilterfalse(lambda x: x &lt; 6, range(10)))
#[6, 7, 8, 9]
#list(ifilter(None, [0, 1, 2, 0, 3, 4]))
#[0, 0]
</code></pre>

<ol>
<li><b>islice</b></li>
</ol>

<p>islice 是切片选择，它的使用形式如下：</p>

<blockquote>
<p>islice(iterable, [start,] stop [, step])</p>
</blockquote>

<p>其中，iterable 是可迭代对象，start 是开始索引，stop 是结束索引，step 是步长，start 和 step 可选。</p>

<pre><code class="language-python">from itertools import count, islice
a = list(islice([10, 6, 2, 8, 1, 3, 9], 5))
print(a)
b = list(islice(count(), 6))
print(b)
c = list(islice(count(), 3, 10))
print(c)
d = list(islice(count(), 3, 10 ,2))
print(d)
</code></pre>

<pre><code>[10, 6, 2, 8, 1]
[0, 1, 2, 3, 4, 5]
[3, 4, 5, 6, 7, 8, 9]
[3, 5, 7, 9]
</code></pre>

<ol>
<li><b>imap</b> (Python3已不再提供) </li>
</ol>

<p>imap 类似 map 操作，它的使用形式如下：</p>

<blockquote>
<p>imap(func, iter1, iter2, iter3, ...)</p>
</blockquote>

<p>imap 返回一个迭代器，元素为 func(i1, i2, i3, ...)，i1，i2 等分别来源于 iter, iter2。</p>

<pre><code class="language-python">#from itertools import imap
#print(imap(str, [1, 2, 3, 4]))
#&lt;itertools.imap object at 0x10556d050&gt;
#print(list(imap(str, [1, 2, 3, 4])))
#[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;]
#print(list(imap(pow, [2, 3, 10], [4, 2, 3])))
#[16, 9, 1000]
</code></pre>

<ol>
<li><b>tee</b></li>
</ol>

<p>tee 的使用形式如下：</p>

<blockquote>
<p>tee(iterable [,n])</p>
</blockquote>

<p>tee 用于从 iterable 创建 n 个独立的迭代器，以元组的形式返回，n 的默认值是 2。</p>

<pre><code class="language-python">from itertools import tee
print(tee(&#39;abcd&#39;))   # n 默认为 2，创建两个独立的迭代器
iter1, iter2 = tee(&#39;abcde&#39;)
print(list(iter1))
print(list(iter2))
print(tee(&#39;abc&#39;, 3))  # 创建三个独立的迭代器
</code></pre>

<pre><code>(&lt;itertools._tee object at 0x000001F91721CF88&gt;, &lt;itertools._tee object at 0x000001F917221788&gt;)
[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]
[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]
(&lt;itertools._tee object at 0x000001F917221848&gt;, &lt;itertools._tee object at 0x000001F917221608&gt;, &lt;itertools._tee object at 0x000001F917221888&gt;)
</code></pre>

<ol>
<li><b>takewhile</b></li>
</ol>

<p>takewhile 的使用形式如下：</p>

<blockquote>
<p>takewhile(predicate, iterable)</p>
</blockquote>

<p>其中，predicate 是函数，iterable 是可迭代对象。对于 iterable 中的元素，如果 predicate(item) 为 true，则保留该元素，只要 predicate(item) 为 false，则立即停止迭代。</p>

<pre><code class="language-python">from itertools import takewhile
a = list(takewhile(lambda x: x &lt; 5, [1, 3, 6, 2, 1]))
print(a)
b = list(takewhile(lambda x: x &gt; 3, [2, 1, 6, 5, 4]))
print(b)
</code></pre>

<pre><code>[1, 3]
[]
</code></pre>

<ol>
<li><b>zip</b> (Python3已不再提供) </li>
</ol>

<p>izip 用于将多个可迭代对象对应位置的元素作为一个元组，将所有元组『组成』一个迭代器，并返回。它的使用形式如下：</p>

<blockquote>
<p>izip(iter1, iter2, ..., iterN)</p>
</blockquote>

<p>如果某个可迭代对象不再生成值，则迭代停止。</p>

<pre><code class="language-python">#from itertools import izip
#for item in izip(&#39;ABCD&#39;, &#39;xy&#39;):
#    print(item)    
#for item in izip([1, 2, 3], [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]):
#    print(item)
</code></pre>

<ol>
<li><b>izip_longest</b> (Python3已不再提供) </li>
</ol>

<p>izip_longest 跟 izip 类似，但迭代过程会持续到所有可迭代对象的元素都被迭代完。它的形式如下：</p>

<blockquote>
<p>izip_longest(iter1, iter2, ..., iterN, [fillvalue=None])</p>
</blockquote>

<p>如果有指定 fillvalue，则会用其填充缺失的值，否则为 None。</p>

<pre><code class="language-python">#from itertools import izip_longest
#for item in izip_longest(&#39;ABCD&#39;, &#39;xy&#39;):
#    print(item)
#for item in izip_longest(&#39;ABCD&#39;, &#39;xy&#39;, fillvalue=&#39;-&#39;):
#    print(item)

####output:
#(&#39;A&#39;, &#39;x&#39;)
#(&#39;B&#39;, &#39;y&#39;)
#(&#39;C&#39;, None)
#(&#39;D&#39;, None)

#(&#39;A&#39;, &#39;x&#39;)
#(&#39;B&#39;, &#39;y&#39;)
#(&#39;C&#39;, &#39;-&#39;)
#(&#39;D&#39;, &#39;-&#39;)
</code></pre>

<p><b>组合生成器</b></p>

<p>itertools 模块还提供了多个组合生成器函数，用于求序列的排列、组合等：<br/><br/>
- product<br/>
- permutations<br/>
- combinations<br/>
- combinations_with_replacement    </p>

<p>这些都是排列组合必备良方</p>

<ol>
<li><b>product</b></li>
</ol>

<p>product 用于求多个可迭代对象的笛卡尔积，它跟嵌套的 for 循环等价。它的一般使用形式如下：</p>

<blockquote>
<p>product(iter1, iter2, ... iterN, [repeat=1])</p>
</blockquote>

<p>其中，repeat 是一个关键字参数，用于指定重复生成序列的次数，</p>

<pre><code class="language-python">from itertools import product
for item in product(&#39;ABCD&#39;, &#39;xy&#39;):
    print(item)
</code></pre>

<pre><code>(&#39;A&#39;, &#39;x&#39;)
(&#39;A&#39;, &#39;y&#39;)
(&#39;B&#39;, &#39;x&#39;)
(&#39;B&#39;, &#39;y&#39;)
(&#39;C&#39;, &#39;x&#39;)
(&#39;C&#39;, &#39;y&#39;)
(&#39;D&#39;, &#39;x&#39;)
(&#39;D&#39;, &#39;y&#39;)
</code></pre>

<pre><code class="language-python">a = list(product(&#39;ab&#39;, range(3)))
print(a)
</code></pre>

<pre><code>[(&#39;a&#39;, 0), (&#39;a&#39;, 1), (&#39;a&#39;, 2), (&#39;b&#39;, 0), (&#39;b&#39;, 1), (&#39;b&#39;, 2)]
</code></pre>

<pre><code class="language-python">b = list(product((0,1), (0,1), (0,1)))
print(b)
</code></pre>

<pre><code>[(0, 0, 0), (0, 0, 1), (0, 1, 0), (0, 1, 1), (1, 0, 0), (1, 0, 1), (1, 1, 0), (1, 1, 1)]
</code></pre>

<pre><code class="language-python">c = list(product(&#39;ABC&#39;, repeat=2))
print(c)
</code></pre>

<pre><code>[(&#39;A&#39;, &#39;A&#39;), (&#39;A&#39;, &#39;B&#39;), (&#39;A&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;A&#39;), (&#39;B&#39;, &#39;B&#39;), (&#39;B&#39;, &#39;C&#39;), (&#39;C&#39;, &#39;A&#39;), (&#39;C&#39;, &#39;B&#39;), (&#39;C&#39;, &#39;C&#39;)]
</code></pre>

<ol>
<li><b>permutations</b></li>
</ol>

<p>permutations 用于生成一个排列，它的一般使用形式如下：</p>

<blockquote>
<p>permutations(iterable[, r])</p>
</blockquote>

<p>其中，r 指定生成排列的元素的长度，如果不指定，则默认为可迭代对象的元素长度。</p>

<pre><code class="language-python">from itertools import permutations
a = permutations(&#39;ABC&#39;, 2)
print(a)
b = list(permutations(&#39;ABC&#39;, 2))
print(b)
c = list(permutations(&#39;ABC&#39;))
print(c)
</code></pre>

<pre><code>&lt;itertools.permutations object at 0x000001F9171C7DB0&gt;
[(&#39;A&#39;, &#39;B&#39;), (&#39;A&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;A&#39;), (&#39;B&#39;, &#39;C&#39;), (&#39;C&#39;, &#39;A&#39;), (&#39;C&#39;, &#39;B&#39;)]
[(&#39;A&#39;, &#39;B&#39;, &#39;C&#39;), (&#39;A&#39;, &#39;C&#39;, &#39;B&#39;), (&#39;B&#39;, &#39;A&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;C&#39;, &#39;A&#39;), (&#39;C&#39;, &#39;A&#39;, &#39;B&#39;), (&#39;C&#39;, &#39;B&#39;, &#39;A&#39;)]
</code></pre>

<ol>
<li><b>combinations</b></li>
</ol>

<p>combinations 用于求序列的组合，它的使用形式如下：</p>

<blockquote>
<p>combinations(iterable, r)</p>
</blockquote>

<p>其中，r 指定生成组合的元素的长度。</p>

<pre><code class="language-python">from itertools import combinations
list(combinations(&#39;ABC&#39;, 2))
</code></pre>

<pre><code>[(&#39;A&#39;, &#39;B&#39;), (&#39;A&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;C&#39;)]
</code></pre>

<ol>
<li><b>combinations_with_replacement</b></li>
</ol>

<p>combinations_with_replacement 和 combinations 类似，但它生成的组合包含自身元素。</p>

<pre><code class="language-python">from itertools import combinations_with_replacement
list(combinations_with_replacement(&#39;ABC&#39;, 2))
</code></pre>

<pre><code>[(&#39;A&#39;, &#39;A&#39;), (&#39;A&#39;, &#39;B&#39;), (&#39;A&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;B&#39;), (&#39;B&#39;, &#39;C&#39;), (&#39;C&#39;, &#39;C&#39;)]
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Modules - 02 - Python collections]]></title>
    <link href="https://sparkbye.github.io/myBlog/15662171970710.html"/>
    <updated>2019-08-19T20:19:57+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15662171970710.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">Module-1: collections 模块总结</h4>

<p>Python为我们提供了4种基本的数据结构：list, tuple, dict, set，但是在处理数据量较大的情形的时候，这4种数据结构就明显过于单一了，比如list作为单向链表在某些情形插入的效率会比较低，有时候我们也需要维护一个有序的dict。所以这个时候我们就要用到Python标准库为我们提供的collections包了，它提供了多个有用的集合类，熟练掌握这些集合类，不仅可以让我们让写出的代码更加Pythonic，也可以提高我们程序的运行效率。</p>

<ol>
<li><b>defaultdict的使用</b></li>
</ol>

<p>defaultdict(default_factory)在普通的dict(字典)之上添加了default_factory，使得key(键)不存在时会自动生成相应类型的value(值)，default_factory参数可以指定成list, set, int等各种合法类型。</p>

<pre><code class="language-python">from collections import defaultdict
s = [(&#39;red&#39;, 1), (&#39;blue&#39;, 2), (&#39;red&#39;, 3), (&#39;blue&#39;, 4), (&#39;red&#39;, 1), (&#39;blue&#39;, 4)]
</code></pre>

<p>我们现在有上面这样一组list(列表)，虽然我们有6组数据，但是仔细观察后发现其实我们只有两种color(颜色)，但是每一个color对应多个值。现在我们想要将这个list转换成一个dict(字典)，这个dict的key(键)对应一种color，dict的value(值)设置为一个list存放color对应的多个值。我们可以使用defaultdict(list)来解决这个问题。</p>

<pre><code class="language-python">d = defaultdict(list)
for k, v in s:
    d[k].append(v)
print(d)
</code></pre>

<pre><code>defaultdict(&lt;class &#39;list&#39;&gt;, {&#39;red&#39;: [1, 3, 1], &#39;blue&#39;: [2, 4, 4]})
</code></pre>

<p>上面这个例子中有一些不完美的地方，比如说{‘blue’: [2, 4, 4], ‘red’: [1, 3, 1]}这个defaultdict中blue颜色中包含两个4，red颜色中包含两个1，但是我们不希望含有重复的元素，这个时候可以考虑使用defaultdict(set)来解决这个问题。set(集合)相比list(列表)的不同之处在于set中不允许存在相同的元素。</p>

<pre><code class="language-python">d = defaultdict(set)
for k, v in s:
    d[k].add(v)
print(d) 
</code></pre>

<pre><code>defaultdict(&lt;class &#39;set&#39;&gt;, {&#39;red&#39;: {1, 3}, &#39;blue&#39;: {2, 4}})
</code></pre>

<p>通过使用defaultdict(int)的形式我们来统计一个字符串中每个字符出现的个数。</p>

<pre><code class="language-python">s = &#39;hello world&#39;
d = defaultdict(int)
for k in s:
    d[k] += 1
print(d)
</code></pre>

<pre><code>defaultdict(&lt;class &#39;int&#39;&gt;, {&#39;h&#39;: 1, &#39;e&#39;: 1, &#39;l&#39;: 3, &#39;o&#39;: 2, &#39; &#39;: 1, &#39;w&#39;: 1, &#39;r&#39;: 1, &#39;d&#39;: 1})
</code></pre>

<ol>
<li><b>OrderedDict的使用</b></li>
</ol>

<p>我们知道默认的dict(字典)是无序的，但是在某些情形我们需要保持dict的有序性，这个时候可以使用OrderedDict，它是dict的一个subclass(子类)，但是在dict的基础上保持了dict的有序型，下面我们来看一下使用方法。</p>

<pre><code class="language-python">from collections import OrderedDict
d = {&#39;banana&#39;: 3, &#39;apple&#39;: 4, &#39;pear&#39;: 1, &#39;orange&#39;: 2}
</code></pre>

<p>这是一个无序的dict(字典)，现在我们可以使用OrderedDict来让这个dict变得有序。</p>

<pre><code class="language-python"># 将d按照key来排序
a = OrderedDict(sorted(d.items(), key=lambda t: t[0]))
print(a)
# 将d按照value来排序
b = OrderedDict(sorted(d.items(), key=lambda t: t[1]))
print(b)
# 将d按照key的长度来排序
c = OrderedDict(sorted(d.items(), key=lambda t: len(t[0])))
print(c)
</code></pre>

<pre><code>OrderedDict([(&#39;apple&#39;, 4), (&#39;banana&#39;, 3), (&#39;orange&#39;, 2), (&#39;pear&#39;, 1)])
OrderedDict([(&#39;pear&#39;, 1), (&#39;orange&#39;, 2), (&#39;banana&#39;, 3), (&#39;apple&#39;, 4)])
OrderedDict([(&#39;pear&#39;, 1), (&#39;apple&#39;, 4), (&#39;banana&#39;, 3), (&#39;orange&#39;, 2)])
</code></pre>

<p>使用popitem(last=True)方法可以让我们按照LIFO(先进后出)的顺序删除dict中的key-value，即删除最后一个插入的键值对，如果last=False就按照FIFO(先进先出)删除dict中key-value。</p>

<pre><code class="language-python">d = {&#39;banana&#39;: 3, &#39;apple&#39;: 4, &#39;pear&#39;: 1, &#39;orange&#39;: 2}
# 将d按照key来排序
d = OrderedDict(sorted(d.items(), key=lambda t: t[0]))
print(d)
# 使用popitem()方法来移除最后一个key-value对
print(d.popitem())
# 使用popitem(last=False)来移除第一个key-value对
print(d.popitem(last=False))
</code></pre>

<pre><code>OrderedDict([(&#39;apple&#39;, 4), (&#39;banana&#39;, 3), (&#39;orange&#39;, 2), (&#39;pear&#39;, 1)])
(&#39;pear&#39;, 1)
(&#39;apple&#39;, 4)
</code></pre>

<p>使用move_to_end(key, last=True)来改变有序的OrderedDict对象的key-value顺序，通过这个方法我们可以将排序好的OrderedDict对象中的任意一个key-value插入到字典的开头或者结尾。</p>

<pre><code class="language-python">d = OrderedDict.fromkeys(&#39;abcde&#39;)
print(d)
# 将key为b的key-value对移动到dict的最后
d.move_to_end(&#39;b&#39;)
print(d)
print(&#39;&#39;.join(d.keys()))
# 将key为b的key-value对移动到dict的最前面
d.move_to_end(&#39;b&#39;, last=False)
print(&#39;&#39;.join(d.keys()))
</code></pre>

<pre><code>OrderedDict([(&#39;a&#39;, None), (&#39;b&#39;, None), (&#39;c&#39;, None), (&#39;d&#39;, None), (&#39;e&#39;, None)])
OrderedDict([(&#39;a&#39;, None), (&#39;c&#39;, None), (&#39;d&#39;, None), (&#39;e&#39;, None), (&#39;b&#39;, None)])
acdeb
bacde
</code></pre>

<ol>
<li><b>deque的使用</b></li>
</ol>

<p>list存储数据的优势在于按找索引查找元素会很快，但是插入和删除元素就很慢了，因为它是是单链表的数据结构。deque是为了高效实现插入和删除操作的双向列表，适合用于队列和栈，而且线程安全。</p>

<p>list只提供了append和pop方法来从list的尾部插入/删除元素，但是deque新增了appendleft/popleft允许我们高效的在元素的开头来插入/删除元素。而且使用deque在队列两端添加（append）或弹出（pop）元素的算法复杂度大约是O(1)，但是对于list对象改变列表长度和数据位置的操作例如 pop(0)和insert(0, v)操作的复杂度高达O(n)。由于对deque的操作和list基本一致，这里就不重复了。</p>

<pre><code class="language-python">from collections import deque
d1=deque()
d1.extend(&#39;abcdefg&#39;)
print(&#39;extend: %s&#39;% d1)
d1.append(&#39;h&#39;)
print(&#39;append: %s&#39;% d1)

d2=deque()
d2.extendleft(range(6))
print(&#39;extendleft: %s&#39;% d2)
d2.appendleft(6)
print(&#39;appendleft: %s&#39;% d2)
</code></pre>

<pre><code>extend: deque([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;])
append: deque([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;])
extendleft: deque([5, 4, 3, 2, 1, 0])
appendleft: deque([6, 5, 4, 3, 2, 1, 0])
</code></pre>

<p>从输出的结果，我们可以看到，append默认从集合的右边增加数组元素，而另一个appendleft可以从集合的左边增加元素</p>

<p>与append和appendleft方法对应的还有pop和popleft方法分别用于从集合中取出元素，看下面的例子:</p>

<pre><code class="language-python">print(&quot;From the right:&quot;)  
d = deque(&#39;abcdefg&#39;)  
while True:  
    try:  
        print(d.pop())
    except IndexError:  
        break  

print(&#39;\n From the left:&#39;)  
d = deque(range(6))  
while True:  
    try:  
        print(d.popleft())  
    except IndexError:  
        break  
</code></pre>

<pre><code>From the right:
g
f
e
d
c
b
a

 From the left:
0
1
2
3
4
5
</code></pre>

<p>最后值得一提的是，deque是线程安全的，也就是说你可以同时从deque集合的左边和右边进行操作而不会有影响，看下面的代码：</p>

<pre><code class="language-python">import collections  
import threading  
import time  
candle = collections.deque(range(5))  
def burn(direction,nextSource):  
    while True:  
        try:  
            next=nextSource()  
        except IndexError:  
            break  
        else:  
            print(&#39;%s : %s&#39; % (direction,next))  
            time.sleep(0.1)  
    print(&quot;done %s&quot; % direction)  
    return  

left=threading.Thread(target=burn,args=(&#39;left&#39;,candle.popleft))  
right=threading.Thread(target=burn,args=(&#39;right&#39;,candle.pop))  
  
left.start()  
right.start() 

left.join()  
right.join()
</code></pre>

<pre><code>left : 0
right : 4
left : 1
right : 3
left : 2
done right
done left
</code></pre>

<ol>
<li><b>ChainMap的使用</b></li>
</ol>

<p>ChainMap用来将多个dict(字典)组成一个list(只是比喻)，可以理解成合并多个字典，但和update不同，而且效率更高。  </p>

<pre><code class="language-python">from collections import ChainMap
a = {&quot;x&quot;:1, &quot;z&quot;:3}
b = {&quot;y&quot;:2, &quot;z&quot;:4}
# 构造一个ChainMap对象
m = ChainMap(a, b)
print(m)
print(&quot;x: {}, y: {}, z: {}&quot;.format(m[&quot;x&quot;], m[&quot;y&quot;], m[&quot;z&quot;]))

# 将m变成一个list
print(m.maps)

# ChainMap进行修改的时候总是只会对第一个字典进行修改
m[&quot;z&quot;] = 4
print(m)
m.pop(&#39;z&#39;)
print(m)

# 从m复制一个ChainMap对象，更新这个复制的对象并不会对m造成影响
m2 = m.new_child()
m2[&#39;z&#39;] = &#39;f&#39;
print(m[&#39;z&#39;])
print(m2.parents)
</code></pre>

<pre><code>ChainMap({&#39;x&#39;: 1, &#39;z&#39;: 3}, {&#39;y&#39;: 2, &#39;z&#39;: 4})
x: 1, y: 2, z: 3
[{&#39;x&#39;: 1, &#39;z&#39;: 3}, {&#39;y&#39;: 2, &#39;z&#39;: 4}]
ChainMap({&#39;x&#39;: 1, &#39;z&#39;: 4}, {&#39;y&#39;: 2, &#39;z&#39;: 4})
ChainMap({&#39;x&#39;: 1}, {&#39;y&#39;: 2, &#39;z&#39;: 4})
4
ChainMap({&#39;x&#39;: 1}, {&#39;y&#39;: 2, &#39;z&#39;: 4})
</code></pre>

<p>从原理上面讲，ChainMap实际上是把放入的字典存储在一个队列中，当进行字典的增加删除等操作只会在第一个字典上进行，当进行查找的时候会依次查找，new_child()方法实质上是在列表的第一个元素前放入一个字典，默认是{}，而parents是去掉了列表开头的元素。也正是因为底层是列表实现的，所以实际上ChainMap查询的字典实际上还是原来的字典的引用</p>

<pre><code class="language-python">a = {&quot;x&quot;:1, &quot;z&quot;:3}
b = {&quot;y&quot;:2, &quot;z&quot;:4}
c = ChainMap(a,b)
print(c)
print(c.maps)
print(c.parents)
print(c.parents.maps)
print(c.parents.parents)
</code></pre>

<pre><code>ChainMap({&#39;x&#39;: 1, &#39;z&#39;: 3}, {&#39;y&#39;: 2, &#39;z&#39;: 4})
[{&#39;x&#39;: 1, &#39;z&#39;: 3}, {&#39;y&#39;: 2, &#39;z&#39;: 4}]
ChainMap({&#39;y&#39;: 2, &#39;z&#39;: 4})
[{&#39;y&#39;: 2, &#39;z&#39;: 4}]
ChainMap({})
</code></pre>

<ol>
<li><b>Counter的使用</b></li>
</ol>

<p>Counter也是dict的一个subclass，它是一个无序容器，可以看做一个计数器，用来统计相关元素出现的个数。</p>

<pre><code class="language-python">from collections import Counter
cnt = Counter()
# 统计列表中元素出现的个数
for word in [&#39;red&#39;, &#39;blue&#39;, &#39;red&#39;, &#39;green&#39;, &#39;blue&#39;, &#39;blue&#39;]:
    cnt[word] += 1
print(cnt)

# 统计字符串中元素出现的个数
cnt = Counter()
for ch in &#39;hello&#39;:
    cnt[ch] = cnt[ch] + 1
print(cnt)
</code></pre>

<pre><code>Counter({&#39;blue&#39;: 3, &#39;red&#39;: 2, &#39;green&#39;: 1})
Counter({&#39;l&#39;: 2, &#39;h&#39;: 1, &#39;e&#39;: 1, &#39;o&#39;: 1})
</code></pre>

<p>使用elements()方法按照元素的出现次数返回一个iterator(迭代器)，元素以任意的顺序返回，如果元素的计数小于1，将忽略它。</p>

<pre><code class="language-python">c = Counter(a=4, b=2, c=0, d=-2)
print(c)
d = c.elements()
print(next(d))
print(sorted(c.elements()))
</code></pre>

<pre><code>Counter({&#39;a&#39;: 4, &#39;b&#39;: 2, &#39;c&#39;: 0, &#39;d&#39;: -2})
a
[&#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;]
</code></pre>

<p>使用most_common(n)返回一个list, list中包含Counter对象中出现最多前n个元素。</p>

<pre><code class="language-python">c = Counter(&#39;abracadabra&#39;)
print(c)
print(c.most_common(3))
</code></pre>

<pre><code>Counter({&#39;a&#39;: 5, &#39;b&#39;: 2, &#39;r&#39;: 2, &#39;c&#39;: 1, &#39;d&#39;: 1})
[(&#39;a&#39;, 5), (&#39;b&#39;, 2), (&#39;r&#39;, 2)]
</code></pre>

<ol>
<li><b>namedtuple的使用</b></li>
</ol>

<p>Python中存储系列数据，比较常见的数据类型有list，除此之外，还有tuple数据类型。相比与list，tuple中的元素不可修改，在映射中可以当键使用。tuple元组的item只能通过index访问，collections模块的namedtuple子类不仅可以使用item的index访问item，还可以通过item的name进行访问。可以将namedtuple理解为c中的struct结构，其首先将各个item命名，然后对每个item赋予数据。<br/><br/>
使用namedtuple(typename, field_names)命名tuple中的元素来使程序更具可读性。</p>

<pre><code class="language-python">from collections import namedtuple
Point = namedtuple(&#39;PointExtension&#39;, [&#39;x&#39;, &#39;y&#39;])
p = Point(1, 2)
print(p.__class__.__name__)
print(p.x)
print(p.y)
</code></pre>

<pre><code>PointExtension
1
2
</code></pre>

<pre><code class="language-python">from collections import namedtuple  
  
websites = [  
    (&#39;Sohu&#39;, &#39;http://www.sohu.com/&#39;, u&#39;Zhang Chaoyang&#39;),  
    (&#39;Sina&#39;, &#39;http://www.sina.com.cn/&#39;, u&#39;Wang Zhidong&#39;),  
    (&#39;163&#39;, &#39;http://www.163.com/&#39;, u&#39;Ding Lei&#39;)  
]  
  
Website = namedtuple(&#39;Website&#39;, [&#39;name&#39;, &#39;url&#39;, &#39;founder&#39;])
  
for website in websites:  
    website = Website._make(website)  
    print(website)
    print(website.name)
</code></pre>

<pre><code>Website(name=&#39;Sohu&#39;, url=&#39;http://www.sohu.com/&#39;, founder=&#39;Zhang Chaoyang&#39;)
Sohu
Website(name=&#39;Sina&#39;, url=&#39;http://www.sina.com.cn/&#39;, founder=&#39;Wang Zhidong&#39;)
Sina
Website(name=&#39;163&#39;, url=&#39;http://www.163.com/&#39;, founder=&#39;Ding Lei&#39;)
163
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Modules - 01 - Python random]]></title>
    <link href="https://sparkbye.github.io/myBlog/15662171354673.html"/>
    <updated>2019-08-19T20:18:55+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15662171354673.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">Module-1: random 模块总结</h4>

<p>Python中的random模块用于生成随机数。下面介绍一下random模块中最常用的几个函数。</p>

<pre><code class="language-python">import random
</code></pre>

<ol>
<li><b>random.random</b></li>
</ol>

<p>random.random()用于生成一个0到1的随机符点数: 0 &lt;= n &lt; 1.0</p>

<pre><code class="language-python">a = random.random()
print(a)
</code></pre>

<pre><code>0.6898048215526792
</code></pre>

<ol>
<li><b>random.uniform</b></li>
</ol>

<p>random.uniform的函数原型为：random.uniform(a, b)，用于生成一个指定范围内的随机符点数，两个参数其中一个是上限，一个是下限。如果a &gt; b，则生成的随机数n: b &lt;= n &lt;= a。如果 a &lt;b， 则 a &lt;= n &lt;= b。</p>

<pre><code class="language-python">a = random.uniform(1000, 18888)
print(a)
b = random.uniform(1000, 18888)
print(b)
</code></pre>

<pre><code>8052.755100232027
2137.3131503870227
</code></pre>

<ol>
<li><b>random.randint</b></li>
</ol>

<p>random.randint()的函数原型为：random.randint(a, b)，用于生成一个指定范围内的整数。其中参数a是下限，参数b是上限，生成的随机数n: a &lt;= n &lt;= b</p>

<pre><code class="language-python">a = random.randint(10, 20)
print(a)
</code></pre>

<pre><code>18
</code></pre>

<ol>
<li><b>random.randrange</b></li>
</ol>

<p>random.randrange的函数原型为：random.randrange(start, stop, step)，从指定范围内，按指定基数递增的集合中获取一个随机数。   </p>

<pre><code class="language-python">a = random.randrange(10, 20, 3)         #在[10，13， 16， 19]中选择
print(a)
</code></pre>

<pre><code>10
</code></pre>

<ol>
<li><b>random.choice</b></li>
</ol>

<p>random.choice从序列中获取一个随机元素。其函数原型为：random.choice(sequence)，参数sequence表示一个有序类型。<br/><br/>
这里要说明 一下：sequence在python不是一种特定的类型，而是泛指一系列的类型。list, tuple, 字符串都属于sequence。</p>

<pre><code class="language-python">a = &quot;mylittlepolly&quot;
print(random.choice(a))
b = [&#39;sun&#39;, &#39;moon&#39;, &#39;star&#39;]
print(random.choice(b))
</code></pre>

<pre><code>l
moon
</code></pre>

<ol>
<li><b>random.shuffle</b></li>
</ol>

<p>random.shuffle的函数原型为：random.shuffle(x[, random])，用于将一个列表中的元素打乱。</p>

<pre><code class="language-python">a = [&quot;Python&quot;, &quot;is&quot;, &quot;powerful&quot;, &quot;simple&quot;, &quot;and so on...&quot;]
random.shuffle(a)
print(a)
</code></pre>

<pre><code>[&#39;and so on...&#39;, &#39;simple&#39;, &#39;powerful&#39;, &#39;Python&#39;, &#39;is&#39;]
</code></pre>

<ol>
<li><b>random.sample</b></li>
</ol>

<p>random.sample的函数原型为：random.sample(sequence, k)，从指定序列中随机获取指定长度的片断。sample函数不会修改原有序列。</p>

<pre><code class="language-python">a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
b = random.sample(a, 5)
print(b)
</code></pre>

<pre><code>[9, 8, 1, 7, 3]
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python常见的错误<十六>]]></title>
    <link href="https://sparkbye.github.io/myBlog/15662167164116.html"/>
    <updated>2019-08-19T20:11:56+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15662167164116.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">常见错误16: Python 特殊方法</h4>

<p>我写了一个通过重载 <b> new </b> 方法来实现单例模式的类。</p>

<pre><code class="language-python">class Singleton(object):
    _instance = None
    def __new__(cls, *args, **kwargs):
        if cls._instance:
            return cls._instance
        cls._isntance = cv = object.__new__(cls, *args, **kwargs)
        return cv
</code></pre>

<pre><code class="language-python">sin1 = Singleton()
sin2 = Singleton()
print(sin1 is sin2)
</code></pre>

<pre><code>False
</code></pre>

<p>现在我有一堆类要实现为单例模式，所以我打算照葫芦画瓢写一个<b>元类</b>，这样可以让代码复用：</p>

<pre><code class="language-python">class SingleMeta(type):
    def __init__(cls, name, bases, dict):
        cls._instance = None
        __new__o = cls.__new__
        def __new__(cls, *args, **kwargs):
            if cls._instance:
                return cls._instance
        cls._instance = cv = __new__o(cls, *args, **kwargs)
        return cv
    
    cls.__new__ = __new__
    
class A(object):
    __metaclass__ = SingleMeta

a1 = A()
</code></pre>

<pre><code>---------------------------------------------------------------------------

NameError                                 Traceback (most recent call last)

&lt;ipython-input-12-f4e661bbbe74&gt; in &lt;module&gt;
----&gt; 1 class SingleMeta(type):
      2     def __init__(cls, name, bases, dict):
      3         cls._instance = None
      4         __new__o = cls.__new__
      5         def __new__(cls, *args, **kwargs):


&lt;ipython-input-12-f4e661bbbe74&gt; in SingleMeta()
      9         return cv
     10 
---&gt; 11     cls.__new__ = __new__
     12 
     13 class A(object):


NameError: name &#39;__new__&#39; is not defined
</code></pre>

<p>哎呀，好气啊，为啥这会报错啊，我明明之前用这种方法给 <strong>getattribute</strong> 打补丁的，下面这段代码能够捕获一切属性调用并打印参数</p>

<pre><code class="language-python">class TraceAttribute(type):
    def __init__(cls, name, bases, dict):
        __getattribute__o = cls.__getattribute__
        def __getattribute__(self, *args, **kwargs):
            print(&#39;__getattribute__:&#39;, args, kwargs)
            return __getattribute__o(self, *args, **kwargs)
        cls.__getattribute__ = __getattribute__

class A(object):
    __metaclass__ = TraceAttribute
    a = 1
    b = 2

a = A()
print(a.a)
print(a.b)
</code></pre>

<pre><code>1
2
</code></pre>

<p>试解释为什么给 <b> getattribute </b> 打补丁成功，而 <b> new </b> 打补丁失败。 如果我坚持使用元类给 <b> new </b> 打补丁来实现单例模式，应该怎么修改？ </p>

<p>其实这是最气人的一点，类里的 <strong>new</strong> 是一个 staticmethod 因此替换的时候必须以 staticmethod 进行替换。答案如下：</p>

<pre><code class="language-python">class SingleMeta(type):
    def __init__(cls, name, bases, dict):
        cls._instance = None
        __new__o = cls.__new__
    
        @staticmethod
        def __new__(cls, *args, **kwargs):
            if cls._instance:
                return cls._instance
            cls._instance = cv = __new__o(cls, *args, **kwargs)
            return cv
        cls.__new__ = __new__
    
class A(object):
    __metaclass__ = SingleMeta

print(A() is A())
</code></pre>

<pre><code>False
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python常见的错误<十五>]]></title>
    <link href="https://sparkbye.github.io/myBlog/15662166109209.html"/>
    <updated>2019-08-19T20:10:10+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15662166109209.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">常见错误15: 描述符的坑</h4>

<p>我想写一个 Exam 类，其属性 math 为 [0,100] 的整数，若赋值时不在此范围内则抛出异常，我决定用描述符来实现这个需求。</p>

<pre><code class="language-python">class Grade(object):
    def __init__(self):
        self._score = 0
    def __get__(self, instance, owner):
        return self._score
    def __set__(self, instance, value):
        if 0 &lt;= value &lt;= 100:
            self._score = value
        else:
            raise ValueError(&#39;grade must be between 0 and 100.&#39;)
</code></pre>

<pre><code class="language-python">class Exam(object):
    math = Grade()
    def __init__(self, math):
        self.math = math
</code></pre>

<pre><code class="language-python">lucy = Exam(math=90)
print(lucy.math)
snake = Exam(math=75)
print(snake.math)
snake.math = 120
</code></pre>

<pre><code>90
75



---------------------------------------------------------------------------

ValueError                                Traceback (most recent call last)

&lt;ipython-input-9-d59603acfa1c&gt; in &lt;module&gt;
      3 snake = Exam(math=75)
      4 print(snake.math)
----&gt; 5 snake.math = 120


&lt;ipython-input-7-edf3703e2b81&gt; in __set__(self, instance, value)
      8             self._score = value
      9         else:
---&gt; 10             raise ValueError(&#39;grade must be between 0 and 100.&#39;)


ValueError: grade must be between 0 and 100.
</code></pre>

<p>看起来一切正常。不过这里面有个巨大的问题，尝试说明是什么问题？<br/><br/>
为了解决这个问题，我改写了 Grade 描述符如下：<br/><br/>
不过这样会导致更大的问题，请问该怎么解决这个问题？</p>

<pre><code class="language-python">class Gradee(object):
    def __init__(self):
        self._grade_pool = {}
    def __get__(self, instance, owner):
        return self._grade_pool.get(instance, None)
    def __set__(self, instance, value):
        if 0 &lt;= value &lt;= 100:
            _grade_pool = self.__dict__.setdefault(&#39;_grade_pool&#39;, {})
            _grade_pool[instance] = value
        else:
            raise ValueError(&#39;fuuuuuuuuuck!!&#39;)
</code></pre>

<pre><code class="language-python">class Exam(object):
    grammer = Gradee()
    def __init__(self, grammer):
        self.grammer = grammer
</code></pre>

<pre><code class="language-python">lucy = Exam(grammer=90)
print(lucy.grammer)
snake = Exam(grammer=75)
print(snake.grammer)
snake.grammer = 120
</code></pre>

<pre><code>90
75



---------------------------------------------------------------------------

ValueError                                Traceback (most recent call last)

&lt;ipython-input-12-1302d1b3a522&gt; in &lt;module&gt;
      3 snake = Exam(grammer=75)
      4 print(snake.grammer)
----&gt; 5 snake.grammer = 120


&lt;ipython-input-10-aa15607fb158&gt; in __set__(self, instance, value)
      9             _grade_pool[instance] = value
     10         else:
---&gt; 11             raise ValueError(&#39;fuuuuuuuuuck!!&#39;)


ValueError: fuuuuuuuuuck!!
</code></pre>

<ol>
<li><p>第一个问题的其实很简单，如果你再运行一次 print ( lucy.math ) 你就会发现，输出值是 75 ，那么这是为什么呢？这就要先从 Python 的调用机制说起了。<br/><br/>
我们如果调用一个属性，那么其顺序是优先从实例的 __dict__ 里查找，然后如果没有查找到的话，那么一次查询类字典，父类字典，直到彻底查不到为止。<br/><br/>
好的，现在回到我们的问题。<br/><br/>
我们发现，在我们的类 Exam 中，其 self.math 的调用过程是，首先在实例化后的实例的 __dict__ 中进行查找，没有找到，接着往上一级，在我们的类 Exam 中进行查找，好的找到了，返回。<br/><br/>
那么这意味着，我们对于 self.math 的所有操作都是对于类变量 math 的操作。因此造成变量污染的问题。那么该则怎么解决呢？<br/><br/>
很多同志可能会说，恩，在 __set__ 函数中将值设置到具体的实例字典不就行了。<br/><br/>
那么这样可不可以呢？<br/><br/>
答案是，很明显不得行啊，至于为什么，就涉及到我们 Python 描述符的机制了，描述符指的是实现了描述符协议的特殊的类，三个描述符协议指的是 __get__ , __set__ , __delete__ 以及 Python 3.6 中新增的 __set_name__ 方法，其中实现了__get__ 以及 __set__ / __delete__ / __set_name__ 的是 <b>Data descriptors</b> ，而只实现了 __get__ 的是 <b>Non-Data descriptor</b> 。<br/><br/>
那么有什么区别呢，前面说了， <b>我们如果调用一个属性，那么其顺序是优先从实例的 <strong>dict</strong> 里查找，然后如果没有查找到的话，那么一次查询类字典，父类字典，直到彻底查不到为止。</b><br/><br/>
但是，这里没有考虑描述符的因素进去，如果将描述符因素考虑进去，那么正确的表述应该是我们如果调用一个属性，那么其顺序是优先从实例的 __dict__ 里查找，然后如果没有查找到的话，那么一次查询类字典，父类字典，直到彻底查不到为止。其中如果在类实例字典中的该属性是一个 Data descriptors ，那么无论实例字典中存在该属性与否，无条件走描述符协议进行调用，在类实例字典中的该属性是一个 Non - Data descriptors ，那么优先调用实例字典中的属性值而不触发描述符协议，如果实例字典中不存在该属性值，那么触发 Non - Data descriptor 的描述符协议。回到之前的问题，我们即使在 __set__ 将具体的属性写入实例字典中，但是由于类字典中存在着 Data descriptors，因此，我们在调用 math 属性时，依旧会触发描述符协议。</p></li>
<li><p>经过改良的做法，利用 dict 的 key 唯一性，将具体的值与实例进行绑定，但是同时带来了内存泄露的问题。<br/><br/>
那么为什么会造成内存泄露呢，首先复习下我们的 dict 的特性， dict 最重要的一个特性，就是凡可 hash 的对象皆可为 key ， dict 通过利用的 hash 值的唯一性（严格意义上来讲并不是唯一，而是其 hash 值碰撞几率极小，近似认定其唯一）来保证 key 的不重复性。<br/><br/>
同时（敲黑板，重点来了），<br/><br/>
dict 中的 key 引用是强引用类型，会造成对应对象的引用计数的增加，可能造成对象无法被 gc ，从而产生内存泄露。<br/><br/>
那么这里该怎么解决呢？两种方法 第一种：  </p></li>
</ol>

<pre><code class="language-python">class Grad(object):
    def __init__(self):
        import weakref
        self._grade_pool = weakref.WeakKeyDictionary()
    def __get__(self, instance, owner):
        return self._grade_pool.get(instance, None)
    def __set__(self, instance, value):
        if 0 &lt;= value &lt;= 100:
            _grade_pool = self.__dict__.setdefault(&#39;_grade_pool&#39;, {})
            _grade_pool[instance] = value
        else:
            raise ValueError(&#39;fuuuuuuuuuck!!&#39;)
</code></pre>

<p>weakref 库中的 WeakKeyDictionary 所产生的字典的 key 对于对象的引用是弱引用类型，其不会造成内存引用计数的增加，因此不会造成内存泄露。<br/><br/>
同理，如果我们为了避免 value 对于对象的强引用，我们可以使用 WeakValueDictionary 。 </p>

<p>第二种：在 Python 3.6 中，实现的 PEP 487 提案，为描述符新增加了一个协议，我们可以用其来绑定对应的对象：</p>

<pre><code class="language-python">class Grad(object):
    def __get__(self, instance, owner):
        return instance.__dict__[self.key]
    def __set__(self, instance, value):
        if 0 &lt;= value &lt;= 100:
            instance.__dict__[self.key] = value
        else:
            raise ValueError(&#39;fuuuuuuuuuck!!&#39;)
    def __set_name__(self, owner, name):
        self.key = name
</code></pre>

<p>这道题涉及的东西比较多，这里给出一点参考链接， invoking-descriptors , Descriptor HowTo Guide , PEP 487 , what`s new in Python 3.6 。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python常见的错误<十四>]]></title>
    <link href="https://sparkbye.github.io/myBlog/15662165783528.html"/>
    <updated>2019-08-19T20:09:38+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15662165783528.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">常见错误14: Python 调用机制</h4>

<p>我们知道 __call__ 方法可以用来重载圆括号调用，好的，以为问题就这么简单？ Naive ！</p>

<pre><code class="language-python">class A(object):
    def __call__(self):
        print(&quot;invoking __call__ from A!&quot;)
</code></pre>

<pre><code class="language-python">a = A()
a()
</code></pre>

<pre><code>invoking __call__ from A!
</code></pre>

<p>现在我们可以看到 a() 似乎等价于 a.__call__() ,看起来很 Easy 对吧，好的，我现在想作死，又写出了如下的代码:</p>

<pre><code class="language-python">a.__call__ = lambda: &quot;invoking __call__ from lambda&quot;
print(a.__call__())
a()
</code></pre>

<pre><code>invoking __call__ from lambda
invoking __call__ from A!
</code></pre>

<p>为什么 a() 没有调用出 a.__call__()</p>

<p>原因在于，在 Python 中，新式类（ new class  )的内建特殊方法，和实例的属性字典是相互隔离的，具体可以看看 Python 官方文档对于这一情况的说明:</p>

<blockquote>
<p>For new - style classes , implicit invocations of special methods are only guaranteed to work correctly if defined on an object &#39; s type , not in the object &#39; s instance dictionary. <br/>
That behaviour is the reason why the following code raises an exception  ( unlike the equivalent example with old - style classes ):</p>
</blockquote>

<p>同时官方也给出了一个例子：</p>

<pre><code class="language-python">class C(object):
    pass

c = C()
c.__len__ = lambda: 5
len(c)
</code></pre>

<pre><code>---------------------------------------------------------------------------

TypeError                                 Traceback (most recent call last)

&lt;ipython-input-4-7039f902a29c&gt; in &lt;module&gt;
      4 c = C()
      5 c.__len__ = lambda: 5
----&gt; 6 len(c)


TypeError: object of type &#39;C&#39; has no len()
</code></pre>

<pre><code class="language-python">c.__len__()
</code></pre>

<pre><code>5
</code></pre>

<p>回到我们的例子上来，当我们在执行 a.__call__ = lambda :&quot; invoking __call__ from lambda &quot; 时，的确在我们在 a.__dict__ 中新增加了一个 key 为 __call__ 的 item ，但是当我们执行 a () 时，因为涉及特殊方法的调用，因此我们的调用过程不会从 a.__dict__ 中寻找属性，而是从 tyee ( a ). __dict__ 中寻找属性。因此，就会出现如上所述的情况。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python常见的错误<十三>]]></title>
    <link href="https://sparkbye.github.io/myBlog/15662165446488.html"/>
    <updated>2019-08-19T20:09:04+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15662165446488.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">常见错误13: 装饰器</h4>

<p>我想写一个类装饰器用来度量函数/方法运行时间：</p>

<pre><code class="language-python">import time

class Timeit(object):
    def __init__(self, func):
        self._wrapped = func
    
    def __call__(self, *args, **kws):
        start_time = time.time()
        result = self._wrapped(*args, **kws)
        print(&quot;elapsed time is %s &quot; % (time.time() - start_time))
        return result
</code></pre>

<p>希望这个装饰器能够运行在普通函数上：</p>

<pre><code class="language-python">@Timeit
def func():
    time.sleep(1)
    return &quot;invoking function func&quot;
</code></pre>

<p>这个装饰器能够运行在普通函数上：</p>

<pre><code class="language-python">func()
</code></pre>

<pre><code>elapsed time is 1.0005531311035156 





&#39;invoking function func&#39;
</code></pre>

<p>但是运行在方法上会报错，为什么？</p>

<pre><code class="language-python">class A(object):
    @Timeit
    def func(self):
        time.sleep(1)
        return &#39;invoking method func&#39;
</code></pre>

<pre><code class="language-python">a = A()
a.func()
</code></pre>

<pre><code>---------------------------------------------------------------------------

TypeError                                 Traceback (most recent call last)

&lt;ipython-input-27-27f4a5f7197a&gt; in &lt;module&gt;
      1 a = A()
----&gt; 2 a.func()


&lt;ipython-input-25-0a38ed0ff6ce&gt; in __call__(self, *args, **kws)
      7     def __call__(self, *args, **kws):
      8         start_time = time.time()
----&gt; 9         result = self._wrapped(*args, **kws)
     10         print(&quot;elapsed time is %s &quot; % (time.time() - start_time))
     11         return result


TypeError: func() missing 1 required positional argument: &#39;self&#39;
</code></pre>

<p>使用类装饰器后，在调用 func 函数的过程中其对应的 instance 并不会传递给 __call__ 方法，造成其 mehtod unbound ,那么解决方法是什么呢？</p>

<pre><code class="language-python">class Timeite(object):
    def __init__(self, func):
        self.func = func
    def __call__(self, *args, **kws):
        print(&#39;invoking Timer&#39;)
    def __get__(self, instance, owner):
        return lambda *args, **kws: self.func(instance, *args, **kws)
</code></pre>

<pre><code class="language-python">class A(object):
    @Timeite
    def func(self):
        time.sleep(1)
        return &#39;invoking method func&#39;
    
a = A()
a.func()
</code></pre>

<pre><code>&#39;invoking method func&#39;
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python常见的错误<十二>]]></title>
    <link href="https://sparkbye.github.io/myBlog/15657075853367.html"/>
    <updated>2019-08-13T22:46:25+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15657075853367.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">常见错误12: 链式赋值的坑</h4>

<p>在我们使用Python的过程中, 经常遇到赋值语句, 就像下面的那样:<br/><br/>
a = 3<br/><br/>
b = 3<br/><br/>
而链式赋值是同时对几个变量进行赋值，如：<br/><br/>
a = b = c = 3<br/><br/>
我们来看看这段代码输出的是什么？</p>

<pre><code class="language-python">s = [1, 2, 3, 4, 5, 6]
i = 0
i = s[i] = 3
print(i)
print(s)
</code></pre>

<pre><code>3
[1, 2, 3, 3, 5, 6]
</code></pre>

<p>i 的值: 3<br/><br/>
---这个好解释<br/><br/>
s 的值: [1, 2, 3, 3, 5, 6]<br/><br/>
？？？<br/><br/>
s的列表, 并没有像我们想象中的那样, 就i=0位置上的元素, 变成3, 而是将i=3位置的元素改成3了, 为什么会这样? 一起来解析下吧, 上dis大杀器!</p>

<pre><code class="language-python">def test():
    s = [1, 2, 3, 4, 5, 6] 
    i = 0
    i = s[i] = 3
    print(i)
    print(s)

import dis
dis.dis(test)
</code></pre>

<pre><code>  2           0 LOAD_CONST               1 (1)
              2 LOAD_CONST               2 (2)
              4 LOAD_CONST               3 (3)
              6 LOAD_CONST               4 (4)
              8 LOAD_CONST               5 (5)
             10 LOAD_CONST               6 (6)
             12 BUILD_LIST               6
             14 STORE_FAST               0 (s)

  3          16 LOAD_CONST               7 (0)
             18 STORE_FAST               1 (i)

  4          20 LOAD_CONST               3 (3)
             22 DUP_TOP
             24 STORE_FAST               1 (i)
             26 LOAD_FAST                0 (s)
             28 LOAD_FAST                1 (i)
             30 STORE_SUBSCR

  5          32 LOAD_GLOBAL              0 (print)
             34 LOAD_FAST                1 (i)
             36 CALL_FUNCTION            1
             38 POP_TOP

  6          40 LOAD_GLOBAL              0 (print)
             42 LOAD_FAST                0 (s)
             44 CALL_FUNCTION            1
             46 POP_TOP
             48 LOAD_CONST               0 (None)
             50 RETURN_VALUE
</code></pre>

<p>解释如下：<br/><br/>
第一列的数字, 代表中间的字节码是属于哪一行代码的.<br/><br/>
第1~2行简单解释下:<br/><br/>
分别LOAD_CONST5个数字, 组成一个列表, 赋值给s,再取一个0, 赋值给i.接下来的就是我们关心的, 也是带给我们意外的代码.<br/><br/>
第3行:<br/><br/>
LOAD_CONST取出常量3, 它并不是像上面执行STORE_NAME, 而是采用DUP_TOP, 这是什么鬼, 我们这要去看下这指令具体是干嘛的:<br/><br/>
//取自 python/ceval.c <br/>
PyEval_EvalFrameEx(PyFrameObject *f, int throwflag)<br/><br/>
{<br/>
        ... (省略)<br/><br/>
        TARGET_NOARG(DUP_TOP)<br/><br/>
        {<br/><br/>
            v = TOP();    // 复制运行栈帧的顶部值<br/><br/>
            Py_INCREF(v); // 增加引用计数<br/><br/>
            PUSH(v);      // 再压入运行栈帧<br/><br/>
            FAST_DISPATCH();<br/><br/>
        }<br/><br/>
        ... (省略)<br/><br/>
}<br/><br/>
DUP_TOP指令说白了, 就是将刚才LOAD_CONST指令取出的常量3, 复制一份给v,然后再压回去运行栈帧, 这样就有两个3了, 为什么要这么做, 可能个大家已经猜到了, 不过我们还是得继续看具体是不是像我们想的那样, 继续看会字节码:<br/>
             24 STORE_FAST               1 (i)<br/>
             26 LOAD_FAST                0 (s)<br/>
             28 LOAD_FAST                1 (i)<br/>
             30 STORE_SUBSCR<br/>
果然不出我们所料, 开始将这些3通过STORE_NAME赋值给i, 而对于s, 它反而是, 再一次LOAD_NAME取出i的值, 此时i的值是3, 不是一开始的0了, 在通过STORE_SUBSCR指令, 将刚才压入运行时时栈的3赋值给位置是3的元素, 具体的源码就不再看, 到这就够了.</p>

<p>所以看到这, 相信大家都能清楚, 为什么结果是 [1, 2, 3, 3, 5, 6]<br/><br/>
这跟我们想象中的链式赋值很不同, 我们以前总是觉得, 赋值要从右到左依次执行, 先执行 s[i] = 3, 再执行 i=3, 然而这些是类似c语言这类支持表达式赋值才允许的. 在c语言中, s = 3表达式是有返回值的. 它会返回赋值的结果3, 所以在它们的链式赋值中, 是将右边表达式的返回值, 再赋值给左边的, 例如:  </p>

<p>a = s = 3<br/><br/>
等价于:<br/><br/>
a = (s = 3)<br/><br/>
也就是 s=3 返回3, 再赋值给a  </p>

<p>而在python是不支持这种表达式赋值的, 也就是表达式是没有返回值的, 如果硬要a = (s = 3)只会触发SyntaxError: invalid syntax<br/><br/>
希望大家以后在用到这种链式赋值时, 尽量避免这些问题哦.</p>

<p>支持表达式赋值是Python语言的核心，比如a = b + 3。这里的 b + 3 就是表达式。如果不支持表达式赋值就没法继续下去了。<br/><br/>
a = (s = 3)出错的原因是因为s = 3是赋值语句，而不是表达式。<br/><br/>
Python的表达式是由操作符连接而成的，但“=”在Python中并不是操作符（Operator），只是语法分隔符（Delimiters）。<br/><br/>
参见：<a href="https://docs.python.org/release/3.6.1/reference/lexical_analysis.html">https://docs.python.org/release/3.6.1/reference/lexical_analysis.html</a>  </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python常见的错误<十一>]]></title>
    <link href="https://sparkbye.github.io/myBlog/15657061085965.html"/>
    <updated>2019-08-13T22:21:48+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15657061085965.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">常见错误11: 列表的缺陷</h4>

<p>来看看下面代码的输出结果将是什么？</p>

<pre><code class="language-python">list = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]
print(list[10:])
print(list[10])
</code></pre>

<pre><code>[]



---------------------------------------------------------------------------

IndexError                                Traceback (most recent call last)

&lt;ipython-input-5-7b4a48b0e416&gt; in &lt;module&gt;
      1 list = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]
      2 print(list[10:])
----&gt; 3 print(list[10])


IndexError: list index out of range
</code></pre>

<p>上面的代码将输出[]，不会产生IndexError错误。就像所期望的那样，尝试用超出成员的个数的index来获取某个列表的成员。<br/><br/>
例如，尝试获取list[10]和之后的成员，会导致IndexError。<br/><br/>
然而，尝试获取列表的切片，开始的index超过了成员个数不会产生IndexError,而是仅仅返回一个空列表。<br/><br/>
这成为特别让人恶心的疑难杂症，因为运行的时候没有错误产生，导致bug很难被追踪到。 </p>

<p>我们再来看看这段代码，猜想一下，输出是什么？</p>

<pre><code class="language-python">list = [ [ ] ] * 5
print(list)  # output?
list[0].append(10)
print(list)  # output?
list[1].append(20)
print(list)   # output?
list.append(30)
print(list)   # output?
</code></pre>

<pre><code>[[], [], [], [], []]
[[10], [10], [10], [10], [10]]
[[10, 20], [10, 20], [10, 20], [10, 20], [10, 20]]
[[10, 20], [10, 20], [10, 20], [10, 20], [10, 20], 30]
</code></pre>

<p>解释如下：<br/><br/>
第一行的输出结果直觉上很容易理解，例如 list = [ [ ] ] * 5 就是简单的创造了5个空列表。<br/><br/>
然而，理解表达式list=[ [ ] ] * 5的关键一点是它不是创造一个包含五个独立列表的列表，而是它是一个<b>创建了包含对同一个列表五次引用的列表。</b><br/><br/>
只有了解了这一点，我们才能更好的理解接下来的输出结果。<br/><br/>
list[0].append(10) 将10附加在第一个列表上。<br/>
但由于所有5个列表是引用的同一个列表，所以这个结果将是：<br/><br/>
[[10], [10], [10], [10], [10]]。<br/><br/>
同理，list[1].append(20)将20附加在第二个列表上。但同样由于5个列表是引用的同一个列表，所以输出结果现在是：<br/><br/>
[[10, 20], [10, 20], [10, 20], [10, 20], [10, 20]]<br/><br/>
作为对比， list.append(30)是将整个新的元素附加在外列表上，因此产生的结果是：[[10, 20], [10, 20], [10, 20], [10, 20], [10, 20], 30]。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python常见的错误<十>]]></title>
    <link href="https://sparkbye.github.io/myBlog/15656215590319.html"/>
    <updated>2019-08-12T22:52:39+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15656215590319.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">常见错误10: 浮点与整除</h4>

<p>下面这段代码在Python2下输出结果将是什么？请解释。</p>

<pre><code class="language-python">def div1(x,y):
    print(&quot;%s/%s = %s&quot; % (x, y, x/y))
def div2(x,y):
    print(&quot;%s//%s = %s&quot; % (x, y, x//y))
div1(5,2)
div1(5.,2)
div2(5,2)
div2(5.,2.)
</code></pre>

<pre><code>5/2 = 2.5
5.0/2 = 2.5
5//2 = 2
5.0//2.0 = 2.0
</code></pre>

<p>在Python3下结果会有怎样的不同？<br/><br/>
在Python2中，上述代码输出将是<br/><br/>
5/2 = 2<br/><br/>
5.0/2 = 2.5<br/><br/>
5//2 = 2<br/><br/>
5.0//2.0 = 2.0  </p>

<p>默认情况下，Python 2 自动执行整形计算如果两者都是整数。因此,5/2 结果是2，而5./2结果是2.5。<br/><br/>
注意，在Python2中，你可以通过增加以下引用来覆写这个行为。  </p>

<pre><code class="language-python">from future import division
</code></pre>

<p>同时要注意的是，//操作符将总是执行整形除法，不管操作符的类型。这就是为什么即使在Python 2中5.0//2.0的结果是2.0。<br/><br/>
然而在Python3中，没有此类特性。例如，在两端都是整形的情况下，它不会执行整形除法。<br/><br/>
因此，在Python3中，将会是如下结果：<br/><br/>
5/2 = 2.5<br/><br/>
5.0/2 = 2.5<br/><br/>
5//2 = 2<br/><br/>
5.0//2.0 = 2.0  </p>

<p>注：在 Python 3 中，/ 操作符是做浮点除法，而 // 是做整除（即商没有余数，比如 10 // 3 其结果就为 3，余数会被截除掉，而 (-7) // 3 的结果却是 -3。这个算法与其它很多编程语言不一样，需要注意，它们的整除运算会向0的方向取值。而在 Python 2 中，/ 就是整除，即和 Python 3 中的 // 操作符一样）</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python常见的错误<九>]]></title>
    <link href="https://sparkbye.github.io/myBlog/15655124741455.html"/>
    <updated>2019-08-11T16:34:34+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15655124741455.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">常见错误8: 未能解决Python 2和Python 3之间的差异</h4>

<p>请看下面这个 filefoo.py:</p>

<pre><code class="language-python">import sys

def bar(i):
    if i == 1:
        raise KeyError(1)
    if i == 2:
        raise ValueError(2)

def bad():
    e = None
    try:
        bar(int(sys.argv[1]))
    except KeyError as e:
        print(&#39;key error&#39;)
    except ValueError as e:
        print(&#39;value error&#39;)
    print(e)

bad()
</code></pre>

<p>在Python 2中运行正常：</p>

<pre><code class="language-python">$ python foo.py 1
key error
1
$ python foo.py 2
value error
2
</code></pre>

<p>但是，现在让我们把它在Python 3中运行一下：</p>

<pre><code class="language-python">&gt;&gt;&gt; python3 foo.py 1
key error
Traceback (most recent call last):
  File &quot;foo.py&quot;, line 19, in &lt;module&gt;
    bad()
  File &quot;foo.py&quot;, line 17, in bad
    print(e)
UnboundLocalError: local variable &#39;e&#39; referenced before assignment
</code></pre>

<p>出什么问题了？ “问题”就是，在 Python 3 中，异常的对象在 except 代码块之外是不可见的。（这样做的原因是，它将保存一个对内存中堆栈帧的引用周期，直到垃圾回收器运行并且从内存中清除掉引用。了解更多技术细节请参考）</p>

<p><a href="https://docs.python.org/3/reference/compound_stmts.html#except">https://docs.python.org/3/reference/compound_stmts.html#except</a></p>

<p>一种解决办法是在 except 代码块的外部作用域中定义一个对异常对象的引用，以便访问。下面的例子使用了该方法，因此最后的代码可以在Python 2 和 Python 3中运行良好。</p>

<pre><code class="language-python">import sys

def bar(i):
    if i == 1:
        raise KeyError(1)
    if i == 2:
        raise ValueError(2)
        
def good():
    exception = None
    try:
        bar(int(sys.argv[1]))
    except KeyError as e:
        exception = e
        print(&#39;key error&#39;)
    except ValueError as e:
        exception = e
        print(&#39;value error&#39;)
    print(exception)

sys.argv.append(1)
good()
sys.argv.append(2)
good()
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python常见的错误<八>]]></title>
    <link href="https://sparkbye.github.io/myBlog/15655124251876.html"/>
    <updated>2019-08-11T16:33:45+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15655124251876.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">常见错误8: 未能解决Python 2和Python 3之间的差异</h4>

<p>请看下面这个 filefoo.py:</p>

<pre><code class="language-python">import sys

def bar(i):
    if i == 1:
        raise KeyError(1)
    if i == 2:
        raise ValueError(2)

def bad():
    e = None
    try:
        bar(int(sys.argv[1]))
    except KeyError as e:
        print(&#39;key error&#39;)
    except ValueError as e:
        print(&#39;value error&#39;)
    print(e)

bad()
</code></pre>

<p>在Python 2中运行正常：</p>

<pre><code class="language-python">$ python foo.py 1
key error
1
$ python foo.py 2
value error
2
</code></pre>

<p>但是，现在让我们把它在Python 3中运行一下：</p>

<pre><code class="language-python">&gt;&gt;&gt; python3 foo.py 1
key error
Traceback (most recent call last):
  File &quot;foo.py&quot;, line 19, in &lt;module&gt;
    bad()
  File &quot;foo.py&quot;, line 17, in bad
    print(e)
UnboundLocalError: local variable &#39;e&#39; referenced before assignment
</code></pre>

<p>出什么问题了？ “问题”就是，在 Python 3 中，异常的对象在 except 代码块之外是不可见的。（这样做的原因是，它将保存一个对内存中堆栈帧的引用周期，直到垃圾回收器运行并且从内存中清除掉引用。了解更多技术细节请参考）</p>

<p><a href="https://docs.python.org/3/reference/compound_stmts.html#except">https://docs.python.org/3/reference/compound_stmts.html#except</a></p>

<p>一种解决办法是在 except 代码块的外部作用域中定义一个对异常对象的引用，以便访问。下面的例子使用了该方法，因此最后的代码可以在Python 2 和 Python 3中运行良好。</p>

<pre><code class="language-python">import sys

def bar(i):
    if i == 1:
        raise KeyError(1)
    if i == 2:
        raise ValueError(2)
        
def good():
    exception = None
    try:
        bar(int(sys.argv[1]))
    except KeyError as e:
        exception = e
        print(&#39;key error&#39;)
    except ValueError as e:
        exception = e
        print(&#39;value error&#39;)
    print(exception)

sys.argv.append(1)
good()
sys.argv.append(2)
good()
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python常见的错误<七>]]></title>
    <link href="https://sparkbye.github.io/myBlog/15655123624150.html"/>
    <updated>2019-08-11T16:32:42+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15655123624150.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">常见错误7: 创建循环依赖模块</h4>

<p>让我们假设你有两个文件，a.py 和 b.py，他们之间相互引用，如下所示：</p>

<pre><code class="language-python">import b

def f():
    return b.x
print(f())
</code></pre>

<pre><code class="language-python">import a

x = 1
def g():
    print(a.f())
</code></pre>

<p>首先，让我们尝试引入 a.py：</p>

<pre><code class="language-python">import a
</code></pre>

<p>可以正常工作。这也许是你感到很奇怪。毕竟，我们确实在这里引入了一个循环依赖的模块，我们推测这样会出问题的，不是吗？<br/><br/>
答案就是在Python中，仅仅引入一个循环依赖的模块是没有问题的。如果一个模块已经被引入了，Python并不会去再次引入它。但是，根据每个模块要访问其他模块中的函数和变量位置的不同，就很可能会遇到问题。<br/><br/>
所以，回到我们这个例子，当我们引入 a.py 时，再引入 b.py 不会产生任何问题，因为当引入的时候，b.py 不需要 a.py 中定义任何东西。b.py 中唯一引用 a.py 中的东西是调用 a.f()。 但是那个调用是发生在g() 中的，并且 a.py 和 b.py 中都没有调用 g()。所以运行正常。<br/><br/>
但是，如果我们尝试去引入b.py 会发生什么呢？（在这之前不引入a.py），如下所示:</p>

<pre><code class="language-python">import b
</code></pre>

<p>啊哦。 出问题了！此处的问题是，在引入b.py的过程中，Python尝试去引入 a.py，但是a.py 要调用f()，而f() 有尝试去访问 b.x。但是此时 b.x 还没有被定义呢。所以发生了 AttributeError 异常。</p>

<p>至少，解决这个问题很简单，只需修改b.py，使其在g()中引入 a.py：</p>

<pre><code class="language-python">x = 1

def g():
    import a    # 只有当g()被调用的时候才会引入a
    print a.f()
</code></pre>

<p>现在，当我们再引入b，没有任何问题：</p>

<pre><code class="language-python">&gt;&gt;&gt; import b
&gt;&gt;&gt; b.g()
1    # Printed a first time since module &#39;a&#39; calls &#39;print f()&#39; at the end
1    # Printed a second time, this one is our call to &#39;g&#39;
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python常见的错误<六>]]></title>
    <link href="https://sparkbye.github.io/myBlog/15655122908336.html"/>
    <updated>2019-08-11T16:31:30+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15655122908336.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">常见错误6: 不明白Python在闭包中是如何绑定变量的</h4>

<p>我们来看下面这个例子：</p>

<pre><code class="language-python">def create_multipliers():
    return [lambda x : i * x for i in range(5)]

for multiplier in create_multipliers():
    print(multiplier(2))
</code></pre>

<pre><code>8
8
8
8
8
</code></pre>

<p>你也许希望获得下面的输出结果：  0  2  4  6  8<br/><br/>
惊讶吧!<br/><br/>
这之所以会发生是由于Python中的“后期绑定”行为，也叫做闭包的延迟绑定。<br/><br/>
<b>闭包中用到的变量只有在函数被调用的时候才会被赋值。</b><br/>
因此，当任何由create_multipliers()返回的函数被调用时，Python会在该函数被调用时的作用域中查找i对应的值。那时，不管返回的函数是否被调用，for循环已经完成，i被赋予了最终的值4。<br/><br/>
解决的办法有很多：</p>

<p>第一种办法是用yield惰性求值：</p>

<pre><code class="language-python">def create_multipliers():
    for i in range(5): yield lambda x : i * x

for multiplier in create_multipliers():
    print(multiplier(2))
</code></pre>

<pre><code>0
2
4
6
8
</code></pre>

<p>第二种办法就是创造一个闭包，利用默认函数立即绑定。<br/><br/>
在这里，我们利用了默认参数来生成一个匿名的函数以便实现我们想要的结果。有人说这个方法很巧妙，有人说它难以理解，还有人讨厌这种做法。但是，如果你是一个 Python 开发者，理解这种行为很重要。</p>

<pre><code class="language-python">def create_multipliers():
    return [lambda x, i=i: i * x for i in range(5)]

for multiplier in create_multipliers():
    print(multiplier(2))
</code></pre>

<pre><code>0
2
4
6
8
</code></pre>

<p>还有种替代的方案是，使用偏函数：</p>

<pre><code class="language-python">from functools import partial
from operator import mul
def create_multipliers():
    return [partial(mul, i) for i in range(5)]

for multiplier in create_multipliers():
    print(multiplier(2))
</code></pre>

<pre><code>0
2
4
6
8
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python常见的错误<五>]]></title>
    <link href="https://sparkbye.github.io/myBlog/15655122526636.html"/>
    <updated>2019-08-11T16:30:52+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15655122526636.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">常见错误5: 当迭代时修改一个列表（List）</h4>

<p>我们来看下面这个例子：</p>

<pre><code class="language-python">odd = lambda x : bool(x % 2)
numbers = [n for n in range(10)]
for i in range(len(numbers)):
     if odd(numbers[i]):
            del numbers[i]
</code></pre>

<pre><code>---------------------------------------------------------------------------

IndexError                                Traceback (most recent call last)

&lt;ipython-input-1-c259828f5d17&gt; in &lt;module&gt;
      2 numbers = [n for n in range(10)]
      3 for i in range(len(numbers)):
----&gt; 4      if odd(numbers[i]):
      5             del numbers[i]


IndexError: list index out of range
</code></pre>

<p>当迭代的时候，从一个 列表或者数组中删除元素，对于任何有经验的开发者来说，这是一个众所周知的错误。尽管上面的例子非常明显，但是许多高级开发者在更复杂的代码中也并非是故意而为之的。<br/>
幸运的是，Python包含大量简洁优雅的编程范例，若使用得当，能大大简化和精炼代码。<br/><br/>
这样的好处是能得到更简化和更精简的代码，能更好的避免程序中出现当迭代时修改一个列表这样的bug。一个这样的范例是递推式列表（list comprehensions）。<br/><br/>
<a href="https://docs.python.org/2/tutorial/datastructures.html#tut-listcomps">https://docs.python.org/2/tutorial/datastructures.html#tut-listcomps</a><br/><br/>
而且，递推式列表（list comprehensions）针对这个问题是特别有用的，通过更改上文中的实现，得到一段极佳的代码：</p>

<pre><code class="language-python">odd = lambda x : bool(x % 2)
numbers = [n for n in range(10)]
numbers[:] = [n for n in numbers if not odd(n)]  # ahh, the beauty of it all
numbers
</code></pre>

<pre><code>[0, 2, 4, 6, 8]
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python常见的错误<四>]]></title>
    <link href="https://sparkbye.github.io/myBlog/15655122052917.html"/>
    <updated>2019-08-11T16:30:05+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15655122052917.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">常见错误4: 不理解Python的作用域</h4>

<p>Python是基于 LEGB 来进行作用于解析的, LEGB<br/><br/>
是 Local, Enclosing, Global,Built-in 的缩写。看起来“见文知意”，对吗？实际上，在Python中还有一些需要注意的地方，先看下面一段代码：</p>

<pre><code class="language-python">x = 10
def foo():
    x += 1
    print(x)

foo()
</code></pre>

<pre><code>---------------------------------------------------------------------------

UnboundLocalError                         Traceback (most recent call last)

&lt;ipython-input-1-ec96c7a5b5d8&gt; in &lt;module&gt;
      4     print(x)
      5 
----&gt; 6 foo()


&lt;ipython-input-1-ec96c7a5b5d8&gt; in foo()
      1 x = 10
      2 def foo():
----&gt; 3     x += 1
      4     print(x)
      5 


UnboundLocalError: local variable &#39;x&#39; referenced before assignment
</code></pre>

<p>这里出什么问题了？<br/><br/>
上面的问题之所以会发生是因为当你给作用域中的一个变量赋值时，Python 会自动的把它当做是当前作用域的局部变量，从而会隐藏外部作用域中的同名变量。<br/><br/>
很多人会感到很吃惊，当他们给之前可以正常运行的代码的函数体的某个地方添加了一句赋值语句之后就得到了一个 UnboundLocalError 的错误。<br/><br/>
尤其是当开发者使用 lists 时，这个问题就更加常见。请看下面这个例子：</p>

<pre><code class="language-python">lst = [1, 2, 3]
def foo_1():
    lst.append(5)

foo_1()
lst
</code></pre>

<pre><code>[1, 2, 3, 5]
</code></pre>

<pre><code class="language-python">def foo_2():
    lst += [5]

foo_2()
</code></pre>

<pre><code>---------------------------------------------------------------------------

UnboundLocalError                         Traceback (most recent call last)

&lt;ipython-input-5-4f369a1ee364&gt; in &lt;module&gt;
      2     lst += [5]
      3 
----&gt; 4 foo_2()


&lt;ipython-input-5-4f369a1ee364&gt; in foo_2()
      1 def foo_2():
----&gt; 2     lst += [5]
      3 
      4 foo_2()


UnboundLocalError: local variable &#39;lst&#39; referenced before assignment
</code></pre>

<p>嗯？为什么 foo2 报错，而foo1没有问题呢？<br/><br/>
原因和之前那个例子的一样，不过更加令人难以捉摸。foo1 没有对 lst 进行赋值操作，而 foo2 做了。<br/><br/>
要知道， lst += [5] 是 lst = lst + [5] 的缩写，我们试图对 lst 进行赋值操作（Python把他当成了局部变量）。<br/><br/>
此外，我们对 lst 进行的赋值操作是基于 lst 自身（这再一次被Python当成了局部变量），但此时还未定义。因此出错！</p>

<p>下面我们再来看看这个作用域的问题。<br/><br/>
看看下面的代码为什么报错？</p>

<pre><code class="language-python">class A(object):
    x = 1
    gen = (x for _ in range(10))

print(list(A.gen))
</code></pre>

<pre><code>---------------------------------------------------------------------------

NameError                                 Traceback (most recent call last)

&lt;ipython-input-7-7c568240446a&gt; in &lt;module&gt;
      3     gen = (x for _ in range(10))
      4 
----&gt; 5 print(list(A.gen))


&lt;ipython-input-7-7c568240446a&gt; in &lt;genexpr&gt;(.0)
      1 class A(object):
      2     x = 1
----&gt; 3     gen = (x for _ in range(10))
      4 
      5 print(list(A.gen))


NameError: name &#39;x&#39; is not defined
</code></pre>

<p>这个问题是变量作用域问题，在 gen =( x for _ in xrange (10)) 中 gen 是一个 generator ,在 generator 中变量有自己的一套作用域，与其余作用域空间相互隔离。<br/><br/>
因此，将会出现这样的 NameError:name &#39; x &#39; is not defined 的问题，那么解决方案是什么呢？答案是：用 lambda 。</p>

<pre><code class="language-python">class A(object):
    x = 1
    gen = (lambda x: (x for _ in range(10)))(x)

print(list(A.gen))
</code></pre>

<pre><code>[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
</code></pre>

<p>或者这样</p>

<pre><code class="language-python">class A(object):
    x = 1
    gen = (A.x for _ in range(10))

print(list(A.gen))
</code></pre>

<pre><code>[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
</code></pre>

<blockquote>
<p>The scope of names defined in a class block is limited to the class block ;<br/><br/>
It does not extend to the code blocks of methods - this includes comprehensions and generator expressions since they are implemented using a function scope.<br/><br/>
This means that the following will fail :</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python常见的错误<三>]]></title>
    <link href="https://sparkbye.github.io/myBlog/15655121732301.html"/>
    <updated>2019-08-11T16:29:33+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15655121732301.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">常见错误3: 为 except 指定错误的参数</h4>

<p>我们来看下面这个例子：</p>

<pre><code class="language-python">try:
    l = [&quot;a&quot;, &quot;b&quot;]
    int(l[2])
except ValueError, IndexError:
    pass
</code></pre>

<pre><code>  File &quot;&lt;ipython-input-2-4f54e4adb7ee&gt;&quot;, line 4
    except ValueError, IndexError:
                     ^
SyntaxError: invalid syntax
</code></pre>

<p>这里的问题在于 except 语句并不接受以这种方式指定的异常列表。相反，在Python 2.x中，使用语法 except Exception, e 是将一个异常对象绑定到第二个可选参数（在这个例子中是 e）上，以便在后面使用。所以，在上面这个例子中，IndexError 这个异常并不是被except语句捕捉到的，而是被绑定到一个名叫 IndexError的参数上时引发的。<br/><br/>
在一个except语句中捕获多个异常的正确做法是将第一个参数指定为一个含有所有要捕获异常的元组。并且，为了代码的可移植性，要使用as关键词，因为Python 2 和Python 3都支持这种语法：</p>

<pre><code class="language-python">try:
    l = [&quot;a&quot;, &quot;b&quot;]
    int(l[2])
except (ValueError, IndexError) as e:
    pass
</code></pre>

]]></content>
  </entry>
  
</feed>
