<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Ascetic in the deadlock]]></title>
  <link href="https://sparkbye.github.io/myBlog/atom.xml" rel="self"/>
  <link href="https://sparkbye.github.io/myBlog/"/>
  <updated>2018-02-28T20:32:10+08:00</updated>
  <id>https://sparkbye.github.io/myBlog/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[Python 陷阱与缺陷列表]]></title>
    <link href="https://sparkbye.github.io/myBlog/15211187332796.html"/>
    <updated>2018-03-15T20:58:53+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15211187332796.html</id>
    <content type="html"><![CDATA[
<p>我个人对陷阱的定义是这样的：代码看起来可以工作，但不是以你“想当然“”的方式。如果一段代码直接出错，抛出了异常，我不认为这是陷阱。比如，Python程序员应该都遇到过的“UnboundLocalError”, 示例：</p>

<pre><code class="language-python">&gt;&gt;&gt; a=1
&gt;&gt;&gt; def func():
...     a+=1
...     print a
...
&gt;&gt;&gt; func()
Traceback (most recent call last):
File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
File &quot;&lt;stdin&gt;&quot;, line 2, in func
UnboundLocalError: local variable &#39;a&#39; referenced before assignment
</code></pre>

<p>&lt;-朕的朱批 -&gt; 这是因为在函数内部对变量赋值进行修改后，该变量就会被Python解释器认为是局部变量而非全局变量，当程序执行到a+=1的时候，因为这条语句是给a赋值，所以a成为了局部变量，那么在执行print a的时候，因为a这个局部变量还没有定义，自然就会抛出这样的错误。只要去掉a+=1，或者加关键字global就不会报错了</p>

<p>对于“UnboundLocalError”,还有更高级的版本：</p>

<pre><code class="language-python">import random
 
def func(ok):
    if ok:
        a = random.random()
    else:
        import random
        a = random.randint(1, 10)
    return a
 
func(True)# UnboundLocalError: local variable &#39;random&#39; referenced before assignment
</code></pre>

<p>可能对于很多python新手来说，这个Error让人摸不着头脑。但我认为这不算陷阱，因为这段代码一定会报错，而不是默默的以错误的方式运行。不怕真小人，就怕伪君子。我认为缺陷就好比伪君子。</p>

<p>那么Python中哪些真正算得上陷阱呢？</p>

<p><strong>第一：以mutable对象作为默认参数</strong></p>

<p>这个估计是最广为人知的了，Python和其他很多语言一样，提供了默认参数，默认参数确实是个好东西，可以让函数调用者忽略一些细节（比如GUI编程，Tkinter，QT），对于lambda表达式也非常有用。但是如果使用了可变对象作为默认参数，那么事情就不那么愉快了。</p>

<pre><code class="language-python">&gt;&gt;&gt; def f(lst = []):
...     lst.append(1)
...     return lst
...
&gt;&gt;&gt; f()
[1]
&gt;&gt;&gt; f()
[1, 1]
</code></pre>

<p>惊喜不惊喜？！究其原因，python中一切都是对象，函数也不列外，默认参数只是函数的一个属性。而默认参数在函数定义的时候已经求值了。<br/>
<code>Default parameter values are evaluated when the function definition is executed.</code><br/>
&lt;-朕的朱批 -&gt; lst是可变对象，默认参数在函数定义的时候已经求值了</p>

<p>stackoverflow上有一个更适当的例子来说明默认参数是在定义的时候求值，而不是调用的时候。</p>

<pre><code class="language-python">&gt;&gt;&gt; import time
&gt;&gt;&gt; def report(when=time.time()):
... return when
...
&gt;&gt;&gt; report()
1500113234.487932
&gt;&gt;&gt; report()
1500113234.487932
</code></pre>

<p>python docoment 给出了标准的解决办法：<br/>
<code>A way around this is to use None as the default, and explicitly test for it in the body of the function</code></p>

<pre><code class="language-python">&gt;&gt;&gt; def report(when=None):
...  if when is None:
...  when = time.time()
... return when
...
&gt;&gt;&gt; report()
1500113446.746997
&gt;&gt;&gt; report()
1500113448.552873
</code></pre>

<p><strong>第二: x += y vs x = x + y</strong><br/>
一般来说，二者是等价的，至少看起来是等价的（这也是陷阱的定义 — 看起来都OK，但不一定正确）。</p>

<pre><code class="language-python">&gt;&gt;&gt; x=1;x += 1;print x
2 
&gt;&gt;&gt; x=1;x = x+1;print x
2
&gt;&gt;&gt; x=[1];x+=[2];print x
[1, 2]
&gt;&gt;&gt; x=[1];x=x+[2];print x
[1, 2]
</code></pre>

<p>呃，被光速打脸了？</p>

<pre><code class="language-python">&gt;&gt;&gt; x=[1];print id(x);x=x+[2];print id(x) 
4357132800
4357132728
&gt;&gt;&gt; x=[1];print id(x);x+=[2];print id(x)
4357132800
4357132800
</code></pre>

<p>前者x指向一个新的对象，后者x在原来的对象是修改，当然，那种效果是正确的取决于应用场景。至少，得知道，二者有时候并不一样</p>

<p>&lt;-朕的朱批 -&gt; 我们可以通过dis来检查下这两者的区别;</p>

<pre><code class="language-python">import dis

def foo(x, y):
    x += y

def foo2(x, y):
    x = x + y

print dis.dis(foo)
print dis.dis(foo2)
</code></pre>

<p>输出结果如下：</p>

<pre><code class="language-python">74            0 LOAD_FAST                0 (x)
              3 LOAD_FAST                1 (y)
              6 INPLACE_ADD         
              7 STORE_FAST               0 (x)
             10 LOAD_CONST               0 (None)
             13 RETURN_VALUE             None

77            0 LOAD_FAST                0 (x)
              3 LOAD_FAST                1 (y)
              6 BINARY_ADD          
              7 STORE_FAST               0 (x)
             10 LOAD_CONST               0 (None)
             13 RETURN_VALUE             None
</code></pre>

<p>分别对应INPLACE_ADD和BINARY_ADD<br/>
更多内容可以参考：<br/>
<a href="https://stackoverflow.com/questions/15376509/when-is-i-x-different-from-i-i-x-in-python">https://stackoverflow.com/questions/15376509/when-is-i-x-different-from-i-i-x-in-python</a></p>

<p><strong>第三，神奇的小括号–()</strong><br/>
小括号（parenthese）在各种编程语言中都有广泛的应用，python中，小括号还能表示元组（tuple）这一数据类型, 元组是immutable的序列。</p>

<pre><code class="language-python">&gt;&gt;&gt; a = (1, 2)
&gt;&gt;&gt; type(a)
&lt;type &#39;tuple&#39;&gt;
&gt;&gt;&gt; type(())
&lt;type &#39;tuple&#39;&gt;
</code></pre>

<p>但如果只有一个元素呢</p>

<pre><code class="language-python">&gt;&gt;&gt; a=(1)
&gt;&gt;&gt; type(a)
&lt;type &#39;int&#39;&gt;
</code></pre>

<p>神奇不神奇，如果要表示只有一个元素的元组，正确的姿势是：</p>

<pre><code class="language-python">&gt;&gt;&gt; a=(1,)
&gt;&gt;&gt; type(a)
&lt;type &#39;int&#39;&gt;
</code></pre>

<p><strong>第四：生成一个元素是列表的列表</strong><br/>
这个有点像二维数组，当然生成一个元素是字典的列表也是可以的，更通俗的说，生成一个元素是可变对象的序列<br/>
很简单嘛：</p>

<pre><code class="language-python">&gt;&gt;&gt; a= [[]] * 10
&gt;&gt;&gt; a
[[], [], [], [], [], [], [], [], [], []]
&gt;&gt;&gt; a[0].append(10)
&gt;&gt;&gt; a[0] 
[10]
</code></pre>

<p>看起来很不错，简单明了，but</p>

<pre><code class="language-python">&gt;&gt;&gt; a[1]
[10]
&gt;&gt;&gt; a
[[10], [10], [10], [10], [10], [10], [10], [10], [10], [10]]
</code></pre>

<p>我猜，这应该不是你预期的结果吧，究其原因，还是因为python中list是可变对象，上述的写法大家都指向的同一个可变对象，正确的姿势</p>

<pre><code class="language-python">&gt;&gt;&gt; a = [[] for _ in xrange(10)]
&gt;&gt;&gt; a[0].append(10)
&gt;&gt;&gt; a
[[10], [], [], [], [], [], [], [], [], []]
</code></pre>

<p><strong>第五，在访问列表的时候，修改列表</strong><br/>
列表（list）在python中使用非常广泛，当然经常会在访问列表的时候增加或者删除一些元素。比如，下面这个函数，试图删掉列表中为3的倍数的元素：</p>

<pre><code class="language-python">&gt;&gt;&gt; def modify_lst(lst):
... for idx, elem in enumerate(lst):
... if elem % 3 == 0:
... del lst[idx]
</code></pre>

<p>测试一下，</p>

<pre><code class="language-python">&gt;&gt;&gt; lst = [1,2,3,4,5,6]
&gt;&gt;&gt; modify_lst(lst)
&gt;&gt;&gt; lst
[1, 2, 4, 5]
</code></pre>

<p>好像没什么错，不过这只是运气好</p>

<pre><code class="language-python">&gt;&gt;&gt; lst = [1,2,3,6,5,4]
&gt;&gt;&gt; modify_lst(lst)
&gt;&gt;&gt; lst
[1, 2, 6, 5, 4]
</code></pre>

<p>上面的例子中，6这个元素就没有被删除。如果在modify_lst函数中print idx， item就可以发现端倪：lst在变短，但idx是递增的，所以在上面出错的例子中，当3被删除之后，6变成了lst的第2个元素（从0开始）。在C++中，如果遍历容器的时候用迭代器删除元素，也会有同样的问题。<br/>
如果逻辑比较简单，使用list comprehension是不错的注意<br/>
&lt;-朕的朱批 -&gt; 不用不知道，一用吓一跳啊<br/>
修改方法很简单：</p>

<pre><code class="language-python">def mod_list(lst):
    new_lst = []
    for elem in lst:
        if elem % 3 != 0:
            new_lst.append(elem)
    return new_lst

lst = [1, 2, 3, 4, 5, 6]
s = mod_list(lst)
print s

lst = [1, 2, 3, 6, 5, 4]
s = mod_list(lst)
print s
</code></pre>

<p><strong>第六，闭包与lambda</strong><br/>
这个也是老生长谈的例子，在其他语言也有类似的情况。先看一个例子:</p>

<pre><code class="language-python">&gt;&gt;&gt; def create_multipliers():
...  return [lambda x:i*x for i in range(5)]
...
&gt;&gt;&gt; for multiplier in create_multipliers():
... print multiplier(2)
...
</code></pre>

<p>create_multipliers函数的返回值时一个列表，列表的每一个元素都是一个函数 －－ 将输入参数x乘以一个倍数i的函数。预期的结果时0，2，4，6，8. 但结果是5个8，意外不意外。</p>

<p>由于出现这个陷阱的时候经常使用了lambda，所以可能会认为是lambda的问题，但lambda表示不愿意背这个锅。问题的本质在与python中的属性查找规则，LEGB（local，enclousing，global，bulitin），在上面的例子中，i就是在闭包作用域（enclousing），而Python的闭包是迟绑定，这意味着闭包中用到的变量的值，是在内部函数被调用时查询得到的。<br/>
解决办法也很简单，那就是变闭包作用域为局部作用域。</p>

<pre><code class="language-python">&gt;&gt;&gt; def create_multipliers():
... return [lambda x, i = i:i*x for i in range(5)]
...
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[高效的 itertools 模块]]></title>
    <link href="https://sparkbye.github.io/myBlog/15211176555242.html"/>
    <updated>2018-03-15T20:40:55+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15211176555242.html</id>
    <content type="html"><![CDATA[
<p>我们知道，迭代器的特点是：惰性求值（Lazy evaluation），即只有当迭代至某个值时，它才会被计算，这个特点使得迭代器特别适合于遍历大文件或无限集合等，因为我们不用一次性将它们存储在内存中。</p>

<p>&lt;-朕的朱批 -&gt; 还记得enumerate犯下的错误吗？</p>

<p>Python 内置的 itertools 模块包含了一系列用来产生不同类型迭代器的函数或类，这些函数的返回都是一个迭代器，我们可以通过 for 循环来遍历取值，也可以使用 next() 来取值。<br/>
itertools 模块提供的迭代器函数有以下几种类型：</p>

<ul>
<li>无限迭代器：生成一个无限序列，比如自然数序列 1, 2, 3, 4, ...；</li>
<li>有限迭代器：接收一个或多个序列（sequence）作为参数，进行组合、分组和过滤等；</li>
<li>组合生成器：序列的排列、组合，求序列的笛卡儿积等；</li>
</ul>

<p>无限迭代器</p>

<p>itertools 模块提供了三个函数（事实上，它们是类）用于生成一个无限序列迭代器：</p>

<ul>
<li>count(firstval=0, step=1)创建一个从 firstval (默认值为 0) 开始，以 step (默认值为 1) 为步长的的无限整数迭代器</li>
<li>cycle(iterable)对 iterable 中的元素反复执行循环，返回迭代器</li>
<li>repeat(object [,times]反复生成 object，如果给定 times，则重复次数为 times，否则为无限
下面，让我们看看一些例子。</li>
</ul>

<p><strong>count</strong><br/>
count() 接收两个参数，第一个参数指定开始值，默认为 0，第二个参数指定步长，默认为 1：</p>

<pre><code class="language-python">&gt;&gt;&gt; import itertools
&gt;&gt;&gt;
&gt;&gt;&gt; nums = itertools.count()
&gt;&gt;&gt; for i in nums:
...     if i &gt; 6:
...         break
...     print i
...
0
1
2
3
4
5
6
&gt;&gt;&gt; nums = itertools.count(10, 2)    # 指定开始值和步长
&gt;&gt;&gt; for i in nums:
...     if i &gt; 20:
...         break
...     print i
...
10
12
14
16
18
20
</code></pre>

<p><strong>cycle</strong><br/>
cycle() 用于对 iterable 中的元素反复执行循环：</p>

<pre><code class="language-python">&gt;&gt;&gt; import itertools
&gt;&gt;&gt;
&gt;&gt;&gt; cycle_strings = itertools.cycle(&#39;ABC&#39;)
&gt;&gt;&gt; i = 1
&gt;&gt;&gt; for string in cycle_strings:
...     if i == 10:
...         break
...     print i, string
...     i += 1
...
1 A
2 B
3 C
4 A
5 B
6 C
7 A
8 B
9 C
</code></pre>

<p><strong>repeat</strong><br/>
repeat() 用于反复生成一个 object：</p>

<pre><code class="language-python">&gt;&gt;&gt; import itertools
&gt;&gt;&gt;
&gt;&gt;&gt; for item in itertools.repeat(&#39;hello world&#39;, 3):
...     print item
...
hello world
hello world
hello world
&gt;&gt;&gt;
&gt;&gt;&gt; for item in itertools.repeat([1, 2, 3, 4], 3):
...     print item
...
[1, 2, 3, 4]
[1, 2, 3, 4]
[1, 2, 3, 4]
</code></pre>

<p><strong>有限迭代器</strong><br/>
itertools 模块提供了多个函数（类），接收一个或多个迭代对象作为参数，对它们进行组合、分组和过滤等：</p>

<ul>
<li>chain()</li>
<li>compress()</li>
<li>dropwhile()</li>
<li>groupby()</li>
<li>ifilter()</li>
<li>ifilterfalse()</li>
<li>islice()</li>
<li>imap()</li>
<li>starmap()</li>
<li>tee()</li>
<li>takewhile()</li>
<li>izip()</li>
<li>izip_longest()</li>
</ul>

<p><strong>chain</strong><br/>
chain 的使用形式如下：<br/>
<code>chain(iterable1, iterable2, iterable3, ...)</code><br/>
chain 接收多个可迭代对象作为参数，将它们『连接』起来，作为一个新的迭代器返回。</p>

<pre><code class="language-python">&gt;&gt;&gt; from itertools import chain
&gt;&gt;&gt;
&gt;&gt;&gt; for item in chain([1, 2, 3], [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]):
...     print item
...
1
2
3
a
b
c
</code></pre>

<p>chain 还有一个常见的用法：<br/>
<code>chain.from_iterable(iterable)</code><br/>
接收一个可迭代对象作为参数，返回一个迭代器：</p>

<pre><code class="language-python">&gt;&gt;&gt; from itertools import chain
&gt;&gt;&gt;
&gt;&gt;&gt; string = chain.from_iterable(&#39;ABCD&#39;)
&gt;&gt;&gt; string.next()
&#39;A&#39;
</code></pre>

<p><strong>compress</strong><br/>
compress 的使用形式如下：<br/>
<code>compress(data, selectors)</code><br/>
compress 可用于对数据进行筛选，当 selectors 的某个元素为 true 时，则保留 data 对应位置的元素，否则去除：</p>

<pre><code class="language-python">&gt;&gt;&gt; from itertools import compress
&gt;&gt;&gt;
&gt;&gt;&gt; list(compress(&#39;ABCDEF&#39;, [1, 1, 0, 1, 0, 1]))
[&#39;A&#39;, &#39;B&#39;, &#39;D&#39;, &#39;F&#39;]
&gt;&gt;&gt; list(compress(&#39;ABCDEF&#39;, [1, 1, 0, 1]))
[&#39;A&#39;, &#39;B&#39;, &#39;D&#39;]
&gt;&gt;&gt; list(compress(&#39;ABCDEF&#39;, [True, False, True]))
[&#39;A&#39;, &#39;C&#39;]
</code></pre>

<p><strong>dropwhile</strong><br/>
dropwhile 的使用形式如下：<br/>
<code>dropwhile(predicate, iterable)</code><br/>
其中，predicate 是函数，iterable 是可迭代对象。对于 iterable 中的元素，如果 predicate(item) 为 true，则丢弃该元素，否则返回该项及所有后续项。<br/>
&lt;-朕的朱批 -&gt; predicate 断言，断定。 注意其返回项是丢弃元素判定失败后的后续项</p>

<pre><code class="language-python">&gt;&gt;&gt; from itertools import dropwhile
&gt;&gt;&gt;
&gt;&gt;&gt; list(dropwhile(lambda x: x &lt; 5, [1, 3, 6, 2, 1]))
[6, 2, 1]
&gt;&gt;&gt;
&gt;&gt;&gt; list(dropwhile(lambda x: x &gt; 3, [2, 1, 6, 5, 4]))
[2, 1, 6, 5, 4]
</code></pre>

<p><strong>groupby</strong><br/>
groupby 用于对序列进行分组，它的使用形式如下：<br/>
<code>groupby(iterable[, keyfunc])</code><br/>
其中，iterable 是一个可迭代对象，keyfunc 是分组函数，用于对 iterable 的连续项进行分组，如果不指定，则默认对 iterable 中的连续相同项进行分组，返回一个 (key, sub-iterator) 的迭代器。</p>

<pre><code class="language-python">&gt;&gt;&gt; from itertools import groupby
&gt;&gt;&gt;
&gt;&gt;&gt; for key, value_iter in groupby(&#39;aaabbbaaccd&#39;):
...     print key, &#39;:&#39;, list(value_iter)
...
a : [&#39;a&#39;, &#39;a&#39;, &#39;a&#39;]
b : [&#39;b&#39;, &#39;b&#39;, &#39;b&#39;]
a : [&#39;a&#39;, &#39;a&#39;]
c : [&#39;c&#39;, &#39;c&#39;]
d : [&#39;d&#39;]
&gt;&gt;&gt;
&gt;&gt;&gt; data = [&#39;a&#39;, &#39;bb&#39;, &#39;ccc&#39;, &#39;dd&#39;, &#39;eee&#39;, &#39;f&#39;]
&gt;&gt;&gt; for key, value_iter in groupby(data, len):    # 使用 len 函数作为分组函数
...     print key, &#39;:&#39;, list(value_iter)
...
1 : [&#39;a&#39;]
2 : [&#39;bb&#39;]
3 : [&#39;ccc&#39;]
2 : [&#39;dd&#39;]
3 : [&#39;eee&#39;]
1 : [&#39;f&#39;]
&gt;&gt;&gt;
&gt;&gt;&gt; data = [&#39;a&#39;, &#39;bb&#39;, &#39;cc&#39;, &#39;ddd&#39;, &#39;eee&#39;, &#39;f&#39;]
&gt;&gt;&gt; for key, value_iter in groupby(data, len):
...     print key, &#39;:&#39;, list(value_iter)
...
1 : [&#39;a&#39;]
2 : [&#39;bb&#39;, &#39;cc&#39;]
3 : [&#39;ddd&#39;, &#39;eee&#39;]
1 : [&#39;f&#39;]
</code></pre>

<p><strong>ifilter</strong><br/>
ifilter 的使用形式如下：<br/>
<code>ifilter(function or None, sequence)</code><br/>
将 iterable 中 function(item) 为 True 的元素组成一个迭代器返回，如果 function 是 None，则返回 iterable 中所有计算为 True 的项。</p>

<pre><code class="language-python">&gt;&gt;&gt; from itertools import ifilter
&gt;&gt;&gt;
&gt;&gt;&gt; list(ifilter(lambda x: x &lt; 6, range(10)))
[0, 1, 2, 3, 4, 5]
&gt;&gt;&gt;
&gt;&gt;&gt; list(ifilter(None, [0, 1, 2, 0, 3, 4]))
[1, 2, 3, 4]
</code></pre>

<p><strong>ifilterfalse</strong><br/>
ifilterfalse 的使用形式和 ifilter 类似，它将 iterable 中 function(item) 为 False 的元素组成一个迭代器返回，如果 function 是 None，则返回 iterable 中所有计算为 False 的项。</p>

<pre><code class="language-python">&gt;&gt;&gt; from itertools import ifilterfalse
&gt;&gt;&gt;
&gt;&gt;&gt; list(ifilterfalse(lambda x: x &lt; 6, range(10)))
[6, 7, 8, 9]
&gt;&gt;&gt;
&gt;&gt;&gt; list(ifilter(None, [0, 1, 2, 0, 3, 4]))
[0, 0]
</code></pre>

<p><strong>islice</strong><br/>
islice 是切片选择，它的使用形式如下：<br/>
<code>islice(iterable, [start,] stop [, step])</code><br/>
其中，iterable 是可迭代对象，start 是开始索引，stop 是结束索引，step 是步长，start 和 step 可选。</p>

<pre><code class="language-python">&gt;&gt;&gt; from itertools import count, islice
&gt;&gt;&gt;
&gt;&gt;&gt; list(islice([10, 6, 2, 8, 1, 3, 9], 5))
[10, 6, 2, 8, 1]
&gt;&gt;&gt;
&gt;&gt;&gt; list(islice(count(), 6))
[0, 1, 2, 3, 4, 5]
&gt;&gt;&gt;
&gt;&gt;&gt; list(islice(count(), 3, 10))
[3, 4, 5, 6, 7, 8, 9]
&gt;&gt;&gt; list(islice(count(), 3, 10 ,2))
[3, 5, 7, 9]
</code></pre>

<p>&lt;-朕的朱批 -&gt;似乎没啥用<br/>
<strong>imap</strong><br/>
imap 类似 map 操作，它的使用形式如下：<br/>
<code>imap(func, iter1, iter2, iter3, ...)</code><br/>
imap 返回一个迭代器，元素为 func(i1, i2, i3, ...)，i1，i2 等分别来源于 iter, iter2。</p>

<pre><code class="language-python">&gt;&gt;&gt; from itertools import imap
&gt;&gt;&gt;
&gt;&gt;&gt; imap(str, [1, 2, 3, 4])
&lt;itertools.imap object at 0x10556d050&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; list(imap(str, [1, 2, 3, 4]))
[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;]
&gt;&gt;&gt;
&gt;&gt;&gt; list(imap(pow, [2, 3, 10], [4, 2, 3]))
[16, 9, 1000]
</code></pre>

<p><strong>tee</strong><br/>
tee 的使用形式如下：<br/>
<code>tee(iterable [,n])</code><br/>
tee 用于从 iterable 创建 n 个独立的迭代器，以元组的形式返回，n 的默认值是 2。</p>

<pre><code class="language-python">&gt;&gt;&gt; from itertools import tee
&gt;&gt;&gt;
&gt;&gt;&gt; tee(&#39;abcd&#39;)   # n 默认为 2，创建两个独立的迭代器
(&lt;itertools.tee object at 0x1049957e8&gt;, &lt;itertools.tee object at 0x104995878&gt;)
&gt;&gt;&gt;
&gt;&gt;&gt; iter1, iter2 = tee(&#39;abcde&#39;)
&gt;&gt;&gt; list(iter1)
[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]
&gt;&gt;&gt; list(iter2)
[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]
&gt;&gt;&gt;
&gt;&gt;&gt; tee(&#39;abc&#39;, 3)  # 创建三个独立的迭代器
(&lt;itertools.tee object at 0x104995998&gt;, &lt;itertools.tee object at 0x1049959e0&gt;, &lt;itertools.tee object at 0x104995a28&gt;)
</code></pre>

<p><strong>takewhile</strong><br/>
takewhile 的使用形式如下：<br/>
<code>takewhile(predicate, iterable)</code><br/>
其中，predicate 是函数，iterable 是可迭代对象。对于 iterable 中的元素，如果 predicate(item) 为 true，则保留该元素，只要 predicate(item) 为 false，则立即停止迭代。</p>

<pre><code class="language-python">&gt;&gt;&gt; from itertools import takewhile
&gt;&gt;&gt;
&gt;&gt;&gt; list(takewhile(lambda x: x &lt; 5, [1, 3, 6, 2, 1]))
[1, 3]
&gt;&gt;&gt; list(takewhile(lambda x: x &gt; 3, [2, 1, 6, 5, 4]))
[]
</code></pre>

<p><strong>zip</strong><br/>
izip 用于将多个可迭代对象对应位置的元素作为一个元组，将所有元组『组成』一个迭代器，并返回。它的使用形式如下：<br/>
<code>izip(iter1, iter2, ..., iterN)</code><br/>
如果某个可迭代对象不再生成值，则迭代停止。</p>

<pre><code class="language-python">&gt;&gt;&gt; from itertools import izip
&gt;&gt;&gt;
&gt;&gt;&gt; for item in izip(&#39;ABCD&#39;, &#39;xy&#39;):
...     print item
...
(&#39;A&#39;, &#39;x&#39;)
(&#39;B&#39;, &#39;y&#39;)
&gt;&gt;&gt; for item in izip([1, 2, 3], [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]):
...     print item
...
(1, &#39;a&#39;)
(2, &#39;b&#39;)
(3, &#39;c&#39;)
</code></pre>

<p><strong>izip_longest</strong><br/>
izip_longest 跟 izip 类似，但迭代过程会持续到所有可迭代对象的元素都被迭代完。它的形式如下：<br/>
<code>izip_longest(iter1, iter2, ..., iterN, [fillvalue=None])</code><br/>
如果有指定 fillvalue，则会用其填充缺失的值，否则为 None。</p>

<pre><code class="language-python">&gt;&gt;&gt; from itertools import izip_longest
&gt;&gt;&gt;
&gt;&gt;&gt; for item in izip_longest(&#39;ABCD&#39;, &#39;xy&#39;):
...     print item
...
(&#39;A&#39;, &#39;x&#39;)
(&#39;B&#39;, &#39;y&#39;)
(&#39;C&#39;, None)
(&#39;D&#39;, None)
&gt;&gt;&gt;
&gt;&gt;&gt; for item in izip_longest(&#39;ABCD&#39;, &#39;xy&#39;, fillvalue=&#39;-&#39;):
...     print item
...
(&#39;A&#39;, &#39;x&#39;)
(&#39;B&#39;, &#39;y&#39;)
(&#39;C&#39;, &#39;-&#39;)
(&#39;D&#39;, &#39;-&#39;)
</code></pre>

<p>&lt;-朕的朱批 -&gt; filevalue挺方便<br/>
<strong>组合生成器</strong><br/>
itertools 模块还提供了多个组合生成器函数，用于求序列的排列、组合等：</p>

<ul>
<li>product</li>
<li>permutations</li>
<li>combinations</li>
<li>combinations_with_replacement</li>
</ul>

<p>&lt;-朕的朱批 -&gt; 排列组合必备良方<br/>
<strong>product</strong><br/>
product 用于求多个可迭代对象的笛卡尔积，它跟嵌套的 for 循环等价。它的一般使用形式如下：<br/>
<code>product(iter1, iter2, ... iterN, [repeat=1])</code><br/>
其中，repeat 是一个关键字参数，用于指定重复生成序列的次数，</p>

<pre><code class="language-python">&gt;&gt;&gt; from itertools import product
&gt;&gt;&gt;
&gt;&gt;&gt; for item in product(&#39;ABCD&#39;, &#39;xy&#39;):
...     print item
...
(&#39;A&#39;, &#39;x&#39;)
(&#39;A&#39;, &#39;y&#39;)
(&#39;B&#39;, &#39;x&#39;)
(&#39;B&#39;, &#39;y&#39;)
(&#39;C&#39;, &#39;x&#39;)
(&#39;C&#39;, &#39;y&#39;)
(&#39;D&#39;, &#39;x&#39;)
(&#39;D&#39;, &#39;y&#39;)
&gt;&gt;&gt;
&gt;&gt;&gt; list(product(&#39;ab&#39;, range(3)))
[(&#39;a&#39;, 0), (&#39;a&#39;, 1), (&#39;a&#39;, 2), (&#39;b&#39;, 0), (&#39;b&#39;, 1), (&#39;b&#39;, 2)]
&gt;&gt;&gt;
&gt;&gt;&gt; list(product((0,1), (0,1), (0,1)))
[(0, 0, 0), (0, 0, 1), (0, 1, 0), (0, 1, 1), (1, 0, 0), (1, 0, 1), (1, 1, 0), (1, 1, 1)]
&gt;&gt;&gt;
&gt;&gt;&gt; list(product(&#39;ABC&#39;, repeat=2))
[(&#39;A&#39;, &#39;A&#39;), (&#39;A&#39;, &#39;B&#39;), (&#39;A&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;A&#39;), (&#39;B&#39;, &#39;B&#39;), (&#39;B&#39;, &#39;C&#39;), (&#39;C&#39;, &#39;A&#39;), (&#39;C&#39;, &#39;B&#39;), (&#39;C&#39;, &#39;C&#39;)]
&gt;&gt;&gt;
</code></pre>

<p><strong>permutations</strong><br/>
permutations 用于生成一个排列，它的一般使用形式如下：<br/>
<code>permutations(iterable[, r])</code><br/>
其中，r 指定生成排列的元素的长度，如果不指定，则默认为可迭代对象的元素长度。</p>

<pre><code class="language-python">&gt;&gt;&gt; from itertools import permutations
&gt;&gt;&gt;
&gt;&gt;&gt; permutations(&#39;ABC&#39;, 2)
&lt;itertools.permutations object at 0x1074d9c50&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; list(permutations(&#39;ABC&#39;, 2))
[(&#39;A&#39;, &#39;B&#39;), (&#39;A&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;A&#39;), (&#39;B&#39;, &#39;C&#39;), (&#39;C&#39;, &#39;A&#39;), (&#39;C&#39;, &#39;B&#39;)]
&gt;&gt;&gt;
&gt;&gt;&gt; list(permutations(&#39;ABC&#39;))
[(&#39;A&#39;, &#39;B&#39;, &#39;C&#39;), (&#39;A&#39;, &#39;C&#39;, &#39;B&#39;), (&#39;B&#39;, &#39;A&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;C&#39;, &#39;A&#39;), (&#39;C&#39;, &#39;A&#39;, &#39;B&#39;), (&#39;C&#39;, &#39;B&#39;, &#39;A&#39;)]
&gt;&gt;&gt;
</code></pre>

<p><strong>combinations</strong><br/>
combinations 用于求序列的组合，它的使用形式如下：<br/>
<code>combinations(iterable, r)</code><br/>
其中，r 指定生成组合的元素的长度。</p>

<pre><code class="language-python">&gt;&gt;&gt; from itertools import combinations
&gt;&gt;&gt;
&gt;&gt;&gt; list(combinations(&#39;ABC&#39;, 2))
[(&#39;A&#39;, &#39;B&#39;), (&#39;A&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;C&#39;)]
</code></pre>

<p><strong>combinations_with_replacement</strong><br/>
combinations_with_replacement 和 combinations 类似，但它生成的组合包含自身元素。</p>

<pre><code class="language-python">&gt;&gt;&gt; from itertools import combinations_with_replacement
&gt;&gt;&gt;
&gt;&gt;&gt; list(combinations_with_replacement(&#39;ABC&#39;, 2))
[(&#39;A&#39;, &#39;A&#39;), (&#39;A&#39;, &#39;B&#39;), (&#39;A&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;B&#39;), (&#39;B&#39;, &#39;C&#39;), (&#39;C&#39;, &#39;C&#39;)]
</code></pre>

<p><strong>小结</strong></p>

<p>itertools 模块提供了很多用于产生多种类型迭代器的函数，它们的返回值不是 list，而是迭代器。</p>

<p><strong>参考链接</strong></p>

<ul>
<li>itertools — Functions creating iterators for efficient looping</li>
<li>itertools – Iterator functions for efficient looping – Python Module of the Week</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[浅谈Python中字符串处理]]></title>
    <link href="https://sparkbye.github.io/myBlog/15211170247112.html"/>
    <updated>2018-03-15T20:30:24+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15211170247112.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">一、拆分含有多种分隔符的字符串</h2>

<h3 id="toc_1">1.如何拆分含有多种分隔符的字符串</h3>

<p>问题： 我们要把某个字符串依据分隔符号拆分不同的字段，该字符串包含多种不同的分隔符，例如：</p>

<pre><code class="language-python">s = &quot;ab;cd|efg|hi,jkl|mn\topq;rst,uvw\txyz&quot;
</code></pre>

<p>其中;,|,\t 都是分隔符号，如何处理？<br/>
方法一： 连续使用str.split()方法，每次处理一种分隔符号</p>

<pre><code class="language-python">s = &quot;ab;cd|efg|hi,jkl|mn\topq;rst,uvw\txyz&quot;
def mySplit(s,ds):
    res = [s]    
    for d in ds:
        t = []
        map(lambda x: t.extend(x.split(d)), res)
        res = t    
    return res

print mySplit(s,&#39;;|,\t&#39;)

输出：
[&#39;ab&#39;, &#39;cd&#39;, &#39;efg&#39;, &#39;hi&#39;, &#39;jkl&#39;, &#39;mn&#39;, &#39;opq&#39;, &#39;rst&#39;, &#39;uvw&#39;, &#39;xyz&#39;]
</code></pre>

<p>方法二： 使用正则表达式的re.split()方法，一次性拆分字符串</p>

<pre><code class="language-python">import re

s = &quot;ab;cd|efg|hi,jkl|mn\topq;rst,uvw\txyz&quot;

print re.split(r&#39;[;|,\t]+&#39;,s)

输出：
[&#39;ab&#39;, &#39;cd&#39;, &#39;efg&#39;, &#39;hi&#39;, &#39;jkl&#39;, &#39;mn&#39;, &#39;opq&#39;, &#39;rst&#39;, &#39;uvw&#39;, &#39;xyz&#39;]
</code></pre>

<h2 id="toc_2">二、调整字符串中文本格式</h2>

<h3 id="toc_3">1. 如何判断字符串a是否以字符串b开头或结尾</h3>

<p>问题：某文件系统目录下有一系列文件：a.py,quicksort.c,stack.cpp,b.sh , 编写程序给其中所有.sh文件和.py文件加上用户可执行权限？<br/>
解决方案：<br/>
使用字符串中的str.startswith()和end.startswith()方法 (注意：多个匹配时参数使用元组)</p>

<pre><code class="language-python">In [1]: import os    #列出当前目录以.sh和以.py结尾的文件
In [2]: [name for name in os.listdir(&#39;.&#39;) if name.endswith((&#39;.py&#39;,&#39;.sh&#39;))]
Out[2]: [&#39;b.sh&#39;, &#39;a.py&#39;]

In [3]: import stat

# 查看 a.py 文件权限
In [4]: os.stat(&#39;a.py&#39;).st_mode
Out[4]: 33204# 把文件权限转换成8进制，即为平常看到的权限
In [5]: oct(os.stat(&#39;a.py&#39;).st_mode)
Out[5]: &#39;0100664&#39;# 更改文件权限，添加一个可执行权限
In [6]: os.chmod(&#39;a.py&#39;,os.stat(&#39;a.py&#39;).st_mode | stat.S_IXUSR)

In [7]: ll
total 0
-rwxrw-r-- 1 yangevan 0 5月   9 14:48 a.py*
-rw-rw-r-- 1 yangevan 0 5月   9 14:48 b.sh
-rw-rw-r-- 1 yangevan 0 5月   9 14:48 quicksort.c
-rw-rw-r-- 1 yangevan 0 5月   9 14:48 stack.cpp
</code></pre>

<h3 id="toc_4">2.如何对字符串中文本的格式进行调整</h3>

<p>问题：某软件的log文件，其中日期格式为“yyyy-mm-dd”:</p>

<pre><code class="language-python">2017-05-08 09:12:48 status half-configured passwd:amd64 1:4.2-3.1ubuntu5.2
2017-05-08 09:12:48 status installed passwd:amd64 1:4.2-3.1ubuntu5.2
2017-05-08 09:12:48 status unpacked passwd:amd64 1:4.2-3.1ubuntu5.2
2017-05-08 09:12:48 status unpacked passwd:amd64 1:4.2-3.1ubuntu5.2
2017-05-08 09:12:48 status half-configured passwd:amd64 1:4.2-3.1ubuntu5.2
2017-05-08 09:12:48 status installed passwd:amd64 1:4.2-3.1ubuntu5.2
2017-05-08 09:12:48 startup packages configure
09:12:48 startup packages configure
</code></pre>

<p>我们想把其中日期改为美国日期的格式&quot;mm/dd/yyyy&quot;,2017-05-08 ==&gt; 05/08/2017 ,应如何处理？<br/>
解决方案：<br/>
使用正则表达式re.sub()方法做字符串替换，利用正则表达式的捕获组捕获每个部分内容，在字符串中调整各个组的捕获顺序。</p>

<pre><code class="language-python">In [1]: import re

In [2]: log = open(&#39;/var/log/dpkg.log&#39;).read()
# (\d{4}) 匹配到4个数字为一个捕获组，其顺序为1。故后面替换用\1放到最后，r是为了防止字符串被转义
In [3]: print re.sub(&#39;(\d{4})-(\d{2})-(\d{2})&#39;,r&#39;\2/\3/\1&#39;, log)
05/08/2017 09:12:48 status unpacked passwd:amd64 1:4.2-3.1ubuntu5.2
05/08/2017 09:12:48 status unpacked passwd:amd64 1:4.2-3.1ubuntu5.2
05/08/2017 09:12:48 status unpacked passwd:amd64 1:4.2-3.1ubuntu5.2
05/08/2017 09:12:48 status half-configured passwd:amd64 1:4.2-3.1ubuntu5.2
05/08/2017 09:12:48 status installed passwd:amd64 1:4.2-3.1ubuntu5.2
05/08/2017 09:12:48 startup packages configure

# 也可以为每个捕获组起个名称，而不使用默认顺序来处理
In [5]: print re.sub(&#39;(?P&lt;year&gt;\d{4})-(?P&lt;month&gt;\d{2})-(?P&lt;day&gt;\d{2})&#39;,r&#39;\g&lt;month&gt;/\g&lt;day&gt;/\g&lt;year&gt;&#39;, log)
05/08/2017 09:12:48 status unpacked passwd:amd64 1:4.2-3.1ubuntu5.2
05/08/2017 09:12:48 status unpacked passwd:amd64 1:4.2-3.1ubuntu5.2
05/08/2017 09:12:48 status unpacked passwd:amd64 1:4.2-3.1ubuntu5.2
05/08/2017 09:12:48 status half-configured passwd:amd64 1:4.2-3.1ubuntu5.2
05/08/2017 09:12:48 status installed passwd:amd64 1:4.2-3.1ubuntu5.2
05/08/2017 09:12:48 startup packages configure
</code></pre>

<h2 id="toc_5">三、字符串拼接</h2>

<h3 id="toc_6">1.如何将多个小字符串拼接成一个大的字符串</h3>

<p>问题：在程序中我们将各个参数按次序收集到列表中： [&quot;<0112>&quot;, &quot;<32>&quot;,&quot;<1024x768>&quot;,&quot;<60>&quot; ],要把各个参数拼接成数据报进行发送&quot;<0112><32><1024x768><60>&quot;<br/>
解决方案：<br/>
方法一：迭代列表，连续使用“+”操作依次拼接每一个字符串</p>

<pre><code class="language-python">In [1]: pl = [&quot;&lt;0112&gt;&quot;, &quot;&lt;32&gt;&quot;,&quot;&lt;1024x768&gt;&quot;,&quot;&lt;60&gt;&quot; ]

In [2]: s = &#39;&#39;

# 这种方法会产生许多临时结果，会造成资源的浪费
In [3]: for p in pl:
  ...:     s = s + p
  ...:     print s
  ...:    
&lt;0112&gt;&lt;0112&gt;&lt;32&gt;&lt;0112&gt;&lt;32&gt;&lt;1024x768&gt;&lt;0112&gt;&lt;32&gt;&lt;1024x768&gt;&lt;60&gt;
In [4]: s
Out[4]: &#39;&lt;0112&gt;&lt;32&gt;&lt;1024x768&gt;&lt;60&gt;&#39;
</code></pre>

<p>方法二：使用str.join()方法，更加快速的拼接列表中所有字符串</p>

<pre><code class="language-python">In [5]: &#39;&#39;.join(pl)
Out[5]: &#39;&lt;0112&gt;&lt;32&gt;&lt;1024x768&gt;&lt;60&gt;&#39;
</code></pre>

<p>有个列表l = [&#39;abc&#39;,123,45,&#39;xyz&#39;],如何让123和45以字符串的方式拼接</p>

<pre><code class="language-python">In [6]: l = [&#39;abc&#39;,123,45,&#39;xyz&#39;]

# 使用生成器表达式，开销比列表表达式小
In [7]: (str(x) for x in l)
  ...:
Out[7]: &lt;generator object &lt;genexpr&gt; at 0x7fe3cadef550&gt;

In [8]: &#39;&#39;.join(str(x) for x in l)
Out[8]: &#39;abc12345xyz&#39;
</code></pre>

<h2 id="toc_7">四、字符串居中对齐</h2>

<h3 id="toc_8">1.如何对字符串进行左、右、居中对齐</h3>

<p>问题： 某个字典存储了一系列属性值</p>

<pre><code class="language-python">{    &quot;loDist&quot;:100.0,    &quot;smartCull&quot;:0.04,    &quot;farclip&quot;:477}
</code></pre>

<p>在程序中想以工整的格式进行输出，如何处理？<br/>
解决方案：<br/>
方法一： 使用字符串的str.ljust(),str.rjust(),str.center()进行,右,居中对齐<br/>
方法二： 使用format方法，传递类似&#39;<20','>20&#39;,&#39;<sup>20&#39;参数完成同样任务</sup></p>

<pre><code class="language-python">In [1]: s = &#39;abc&#39;In 

Out[2]: &#39;abc                 &#39;
In [3]: s.ljust(20,&#39;=&#39;)
Out[3]: &#39;abc=================&#39;
In [4]: s.center(20)
Out[4]: &#39;        abc         &#39;
In [5]: format(s,&#39;&lt;20&#39;)
Out[5]: &#39;abc                 &#39;
In [6]: d = {
  ...:     &quot;loDist&quot;:100.0,
  ...:     &quot;smartCull&quot;:0.04,
  ...:     &quot;farclip&quot;:477
  ...: }
In [7]: d.keys()
Out[7]: [&#39;loDist&#39;, &#39;smartCull&#39;, &#39;farclip&#39;]
In [8]: w =max(map(len,d.keys()))
In [9]: for k in d:
  ...:     print k.ljust(w),&#39;:&#39;,d[k]
  ...:    
loDist    : 100.0
smartCull : 0.04
farclip   : 477
</code></pre>

<h3 id="toc_9">2.去掉不需要的字符串</h3>

<p>问题：<br/>
1.过滤掉用户输入中前后多余的空白字符： &#39; <a href="mailto:nick@gmail.com">nick@gmail.com</a> &#39;<br/>
2.过滤某windows下编辑文本中的&#39;\r&#39;: &#39;hello world\r\n&#39;<br/>
3.去掉文本中的unicode组合符号(音调):u&#39;zǒu&#39;<br/>
解决方案：<br/>
方法一： 字符串strip(),lstrip(),rstrip()方法去掉字符串两端字符<br/>
方法二：删除单个固定位置的字符，可以使用切片+拼接的方式<br/>
方法三：字符串的replace方法或正则表达式re.sub()方法删除任意位置字符<br/>
方法四：字符串translate()方法,可以同时删除多种不同字符</p>

<pre><code class="language-python">In [1]: s = &#39;  abc 123  &#39;
In [2]: s.strip()
Out[2]: &#39;abc 123&#39;
In [3]: s.lstrip()
Out[3]: &#39;abc 123  &#39;
In [4]: s = &#39;-----ab+++++&#39;
In [5]: s.strip(&#39;-+&#39;)
Out[5]: &#39;ab&#39;
In [6]: s = &#39;abc:123&#39;
In [7]: s[:3]+s[4:]
Out[7]: &#39;abc123&#39;
In [8]: s = &#39;\tabc\t123\txyz&#39;# 去除\t
In [9]: s.replace(&#39;\t&#39;,&#39;&#39;)
Out[9]: &#39;abc123xyz&#39;
In [10]: s = &#39;\tabc\t123\txyz\ropq\r&#39;
In [11]: import re# 去除\t\r
In [12]: re.sub(&#39;[\t\r]&#39;,&#39;&#39;,s)
Out[12]: &#39;abc123xyzopq&#39;
In [13]: s = &#39;abc\refg\n\2342\t&#39;# 去除\t\r\n
In [14]: s.translate(None,&#39;\t\r\n&#39;)
Out[14]: &#39;abcefg\x9c2&#39;
In [15]: u = u&#39;zǒu&#39;
In [16]: u
Out[16]: u&#39;z\u01d2u&#39;
In [17]: print u.translate({0x01d2:None})
zu
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python 字典的内部实现]]></title>
    <link href="https://sparkbye.github.io/myBlog/15198200217202.html"/>
    <updated>2018-02-28T20:13:41+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15198200217202.html</id>
    <content type="html"><![CDATA[
<p>python中字典是通过键索引的，因此，字典也可视作彼此关联的两个数组。下面我们尝试向字典中添加3个键/值（key/value）对：</p>

<pre><code class="language-python">d = {&#39;a&#39;:1, &#39;b&#39;:2}
d[&#39;c&#39;] = 3
print d
</code></pre>

<p>输出：<code>{&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3}</code><br/>
这些值可通过如下方法访问：</p>

<pre><code class="language-python">print d[&#39;a&#39;]
print d[&#39;b&#39;]
print d[&#39;c&#39;]
print d[&#39;d&#39;]
</code></pre>

<p><code>Traceback (most recent call last):<br/>
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; KeyError: &#39;d&#39;</code><br/>
由于不存在 &#39;d&#39; 这个键，所以引发了KeyError异常。</p>

<p><strong>哈希表（Hash tables）</strong><br/>
在Python中，字典是通过哈希表实现的。也就是说，字典是一个数组，而数组的索引是键经过哈希函数处理后得到的。哈希函数的目的是使键均匀地分布在数组中。由于不同的键可能具有相同的哈希值，即可能出现冲突，高级的哈希函数能够使冲突数目最小化。Python中并不包含这样高级的哈希函数，几个重要（用于处理字符串和整数）的哈希函数通常情况下均是常规的类型：</p>

<pre><code>&gt;&gt;&gt; map(hash, (0, 1, 2, 3))
[0, 1, 2, 3]
&gt;&gt;&gt; map(hash, (&quot;namea&quot;, &quot;nameb&quot;, &quot;namec&quot;, &quot;named&quot;))
[-1658398457, -1658398460, -1658398459, -1658398462]
</code></pre>

<p>在以下的篇幅中，我们仅考虑用字符串作为键的情况。在Python中，用于处理字符串的哈希函数是这样定义的：</p>

<pre><code class="language-python">arguments: string object
returns: hash
function string_hash:
    if hash cached:
        return it
    set len to string&#39;s length
    initialize var p pointing to 1st char of string object
    set x to value pointed by p left shifted by 7 bits
    while len &gt;= 0:
        set var x to (1000003 * x) xor value pointed by p
        increment pointer p
    set x to x xor length of string object
    cache x as the hash so we don&#39;t need to calculate it again
    return x as the hash
</code></pre>

<p>如果在Python中运行 hash(&#39;a&#39;) ，后台将执行 string_hash()函数，然后返回 12416037344 （这里我们假设采用的是64位的平台）。</p>

<p>如果用长度为 x 的数组存储键/值对，则我们需要用值为 x-1 的掩码计算槽（slot，存储键/值对的单元）在数组中的索引。这可使计算索引的过程变得非常迅速。字典结构调整长度的机制（以下会详细介绍）会使找到空槽的概率很高，也就意味着在多数情况下只需要进行简单的计算。假如字典中所用数组的长度是 8 ，那么键&#39;a&#39;的索引为：hash(&#39;a&#39;) &amp; 7 = 0，同理&#39;b&#39;的索引为 3 ,&#39;c&#39;的索引为 2 , 而&#39;z&#39;的索引与&#39;b&#39;相同，也为 3 ，这就出现了冲突。<br/>
<img src="media/15198200217202/15198207691451.png" alt=""/><br/>
可以看出，Python的哈希函数在键彼此连续的时候表现得很理想，这主要是考虑到通常情况下处理的都是这类形式的数据。然而，一旦我们添加了键&#39;z&#39;就会出现冲突，因为这个键值并不毗邻其他键，且相距较远。</p>

<p>当然，我们也可以用索引为键的哈希值的链表来存储键/值对，但会增加查找元素的时间，时间复杂度也不再是 O(1) 了。下一节将介绍Python的字典解决冲突所采用的方法。</p>

<p><strong>开放寻址法（ Open addressing ）</strong></p>

<p>开放寻址法是一种用探测手段处理冲突的方法。在上述键&#39;z&#39;冲突的例子中，索引 3 在数组中已经被占用了，因而需要探寻一个当前未被使用的索引。增加和搜寻键/值对需要的时间均为 O(1)。</p>

<p>搜寻空闲槽用到了一个二次探测序列（quadratic probing sequence），其代码如下：</p>

<pre><code class="language-python">j = (5*j) + 1 + perturb; 
perturb &gt;&gt;= PERTURB_SHIFT;
use j % 2**i as the next table index;
</code></pre>

<p>循环地5*j+1可以快速放大不影响初始索引的哈希值二进位的微小差异。变量perturb可使其他二进位也不断变化。</p>

<p>出于好奇，我们来看一看当数组长度为 32 时的探测序列，j = 3 -&gt; 11 -&gt; 19 -&gt; 29 -&gt; 5 -&gt; 6 -&gt; 16 -&gt; 31 -&gt; 28 -&gt; 13 -&gt; 2…</p>

<p>关于探测序列的更多介绍可以参阅dictobject.c的源码。文件的开头包含了对探测机理的详细介绍。<br/>
<img src="media/15198200217202/15198208428424.jpg" alt=""/><br/>
下面我们结合例子来看一看 Python 内部代码。<br/>
<strong>基于C语言的字典结构</strong><br/>
以下基于C语言的数据结构用于存储字典的键/值对（也称作 entry），存储内容有哈希值，键和值。PyObject 是 Python 对象的一个基类。</p>

<pre><code class="language-C">typedef struct {
    Py_ssize_t me_hash;
    PyObject *me_key;
    PyObject *me_value
} PyDictEntry;
</code></pre>

<p>下面为字典对应的数据结构。其中，ma_fill为活动槽以及哑槽（dummy slot）的总数。当一个活动槽中的键/值对被删除后，该槽则被标记为哑槽。ma_used为活动槽的总数。ma_mask值为数组的长度减 1 ，用于计算槽的索引。ma_table为数组本身，ma_smalltable为长度为 8 的初始数组。</p>

<pre><code class="language-C">typedef struct _dictobject PyDictObject;
struct _dictobject {
    PyObject_HEAD
    Py_ssize_t ma_fill;
    Py_ssize_t ma_used;
    Py_ssize_t ma_mask;
    PyDictEntry *ma_table;
    PyDictEntry *(*ma_lookup)(PyDictObject *mp, PyObject *key, long hash);
    PyDictEntry ma_smalltable[PyDict_MINSIZE];
};
</code></pre>

<p><strong>字典初始化</strong><br/>
字典在初次创建时将调用PyDict_New()函数。这里删掉了源代码中的部分行，并且将C语言代码转换成了伪代码以突出其中的几个关键概念。</p>

<pre><code class="language-C">returns new dictionary object
function PyDict_New:
    allocate new dictionary object
    clear dictionary&#39;s table
    set dictionary&#39;s number of used slots + dummy slots (ma_fill) to 0
    set dictionary&#39;s number of active slots (ma_used) to 0
    set dictionary&#39;s mask (ma_value) to dictionary size - 1 = 7
    set dictionary&#39;s lookup function to lookdict_string
    return allocated dictionary object
</code></pre>

<p><strong>添加项</strong><br/>
添加新的键/值对调用的是PyDict_SetItem()函数。函数将使用一个指针指向字典对象和键/值对。这一过程中，首先会检查键是否是字符串，然后计算哈希值，如果先前已经计算并缓存了键的哈希值，则直接使用缓存的值。接着调用insertdict()函数添加新键/值对。如果活动槽和空槽的总数超过数组长度的2/3，则需调整数组的长度。为什么是 2/3 ？这主要是为了保证探测序列能够以足够快的速度找到空闲槽。后面我们会介绍调整长度的函数。</p>

<pre><code class="language-C">arguments: dictionary, key, value
returns: 0 if OK or -1
function PyDict_SetItem:
    if key&#39;s hash cached:
        use hash
    else:
        calculate hash
    call insertdict with dictionary object, key, hash and value
    if key/value pair added successfully and capacity over 2/3:
        call dictresize to resize dictionary&#39;s table
</code></pre>

<p>inserdict() 使用搜寻函数 lookdict_string() 来查找空闲槽。这跟查找键所用的是同一函数。lookdict_string() 使用哈希值和掩码计算槽的索引。如果用“索引 = 哈希值&amp;掩码”的方法未找到键，则会用调用先前介绍的循环方法探测，直至找到一个空闲槽。第一轮探测，如果未找到匹配的键的且探测过程中遇到过哑槽，则返回一个哑槽。这可使优先选择先前删除的槽。<br/>
现在我们想添加如下的键/值对：{‘a’: 1, ‘b’: 2′, ‘z’: 26, ‘y’: 25, ‘c’: 5, ‘x’: 24}，那么将会发生如下过程：</p>

<p>分配一个字典结构，内部表的尺寸为8。<br/>
<img src="media/15198200217202/15198209955932.jpg" alt=""/><br/>
以下就是我们目前所得到的：<br/>
<img src="media/15198200217202/15198210086336.jpg" alt=""/><br/>
8个槽中的6个已被使用，使用量已经超过了总容量的2/3，因而，dictresize()函数将会被调用，用以分配一个长度更大的数组，同时将旧表中的条目复制到新的表中。</p>

<p>在我们这个例子中，dictresize()函数被调用后，数组长度调整后的长度不小于活动槽数量的 4 倍，即minused = 24 = 4 * ma_used。而当活动槽的数量非常大（大于50000）时，调整后长度应不小于活动槽数量的2倍，即2*ma_used。为什么是 4 倍？这主要是为了减少调用调整长度函数的次数，同时能显著提高稀疏度。</p>

<p>新表的长度应大于 24，计算长度值时会不断对当前长度值进行升位运算，直到大于 24，最终得到的长度是 32，例如当前长度为 8 ，则计算过程如8 -&gt; 16 -&gt; 32。</p>

<p>这就是长度调整的过程：分配一个长度为 32 的新表，然后用新的掩码，也就是 31 ，将旧表中的条目插入到新表。最终得到的结果如下：<br/>
<img src="media/15198200217202/15198210614829.jpg" alt=""/><br/>
<strong>删除项</strong><br/>
删除条目时将调用PyDict_DelItem()函数。删除时，首先计算键的哈希值，然后调用搜询函数返回到该条目，最后该槽被标记为哑槽。</p>

<p>假设我们想要从字典中删除键&#39;c&#39;，我们最终将得到如下结果：<br/>
<img src="media/15198200217202/15198210844803.png" alt=""/><br/>
注意，删除项目后，即使最终活动槽的数量远小于总的数量也不会触发调整数组长度的动作。但是，若删减后又增加键/值对时，由于调整长度的条件判断基于的是活动槽与哑槽的总数量，因而可能会缩减数组长度。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Auto Install Stack(v2.0)]]></title>
    <link href="https://sparkbye.github.io/myBlog/15161073656469.html"/>
    <updated>2018-01-16T20:56:05+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15161073656469.html</id>
    <content type="html"><![CDATA[
<p>更新了脚本：</p>

<pre><code class="language-sh">#!/bin/bash

##############################################################################
# Use script like this:
# ./auto_install_stack.sh ${num}
#            run 1  --- will re-install stack with default image.
#            run 2  --- will re-install stack with specified image(install new stack with same yaml file).
#            run 3  --- will re-install stack with specified image and yaml parameter(first use this scripts).
##############################################################################

set -x

function echo__blue()            { echo -e &quot;\e[0;34;1m$1\e[0m&quot;;}
function echo__red()             { echo -e &quot;\e[0;31;1m$1\e[0m&quot;;}
function echo__green()           { echo -e &quot;\e[0;32;1m$1\e[0m&quot;;}
function echo__yellow()          { echo -e &quot;\e[0;33;1m$1\e[0m&quot;;}
function echo__red_shining()     { echo -e &quot;\033[31m \033[05m $2 \033[0m&quot;;}
function echo__blue_shining()    { echo -e &quot;\033[34m \033[05m $2 \033[0m&quot;;}

CURRENT_DIR=`pwd`
LOCAL_DIR=&quot;rcp-heat&quot;
STACK_TYPE=&quot;net&quot;
NUM=`echo ${CURRENT_DIR##*/} | tr -cd &quot;[0-9]&quot;`

if [ ${CURRENT_DIR##*/} != &quot;hranuser$NUM&quot; ];then
    echo__red &quot;======= Error: Current directory must be end with &#39;/hranuser&#39; ======&quot;
    exit -1
fi

if [ ! -d &quot;$LOCAL_DIR&quot; ];then
    mkdir -p $LOCAL_DIR
fi

function _create_image()
{
    IMAGE_FILE=`echo ${RCP_IMAGE_URL##*/} | cut -d &quot;.&quot; -f 1,2`
    IMAGE_EXIST=`glance image-list | grep $IMAGE_FILE | wc -l`
    if [ $IMAGE_EXIST -ne 0 ];then
        IMAGE_UUID=`glance image-list | grep $IMAGE_FILE | awk &#39;{print $2}&#39;`
        glance image-delete $IMAGE_UUID
        sleep 3
    fi
    echo__blue &quot;====== Begin to download RCP image to $LOCAL_DIR ======&quot;
    wget -O $LOCAL_DIR/${RCP_IMAGE_URL##*/} $RCP_IMAGE_URL
    if [ $? -ne 0 ];then
        echo__red &quot;====== Download image unsuceessfully, please check your image name is right ======&quot;
        exit -1
    fi
    echo__blue &quot;====== Download image suceessfully ======&quot;    
    echo__blue &quot;====== Begin to create image ======&quot;
    glance image-create --name=$IMAGE_FILE --container-format=bare --visibility=private --disk-format=qcow2 --file=$LOCAL_DIR/${RCP_IMAGE_URL##*/}
    IMAGE_UUID=`glance image-list | grep $IMAGE_FILE | awk &#39;{print $2}&#39;`
    while ((1))
    do
        GLANCE_STATUS=`glance image-show $IMAGE_UUID | grep status | awk &#39;{print $4}&#39;`
        if [ &quot;active&quot; != &quot;$GLANCE_STATUS&quot; ];then
            echo__blue &quot;====== Waiting for image active... ======&quot;
            sleep 5
        else
            break
        fi
    done
    echo__blue &quot;====== Create image suceessfully ======&quot;
    sleep 3
}

function _download_yaml()
{
    TEMPLATE_FILE=${RCP_TEMPLATE_URL##*/}
    echo__blue &quot;====== Downloading RCP template to $LOCAL_DIR/$TEMPLATE_FILE ======&quot;
    wget -O $LOCAL_DIR/$TEMPLATE_FILE $RCP_TEMPLATE_URL
    if [ $? -ne 0 ]
    then
        echo__red &quot;====== Download template unsuceessfully, please check your template file is right ======&quot;
        exit -1
    fi
    echo__blue &quot;====== Download template suceessfully ======&quot;
    ls -l $LOCAL_DIR
    tar -xzvf $LOCAL_DIR/$TEMPLATE_FILE -C $LOCAL_DIR
    rm -f $LOCAL_DIR/$TEMPLATE_FILE
}

function _uninstall_old_stack()
{
    echo__blue &quot;====== Begin to uninstall existed stack ======&quot;
    STACK_UUID=`openstack stack list | awk &#39;{print $2}&#39; | awk &#39;NR&gt;2&#39; | awk &#39;{if(length!=0) print $0}&#39;`
    ### === used for Multi-stack === ###
    # STACK_UUID=`openstack stack list | grep touchdown | awk &#39;{print $2}&#39; | awk &#39;{if(length!=0) print $0}&#39;`
    if [ -n &quot;$STACK_UUID&quot; ];then
        /usr/bin/expect &lt;&lt; EOF
        set time 10
        spawn openstack stack delete ${STACK_UUID}
        expect &quot;*y/N*&quot;
        send &quot;y\r&quot;
        expect eof
EOF
    fi
    while ((1))
    do
        STACK_STATUS=`openstack stack list | awk &#39;{print $6}&#39; | awk &#39;NR&gt;2&#39; | awk &#39;{if(length!=0) print $0}&#39;`
        if [ -n &quot;${STACK_STATUS}&quot; ];then
            sleep 10
            echo__blue &quot;====== Deleting old stack, please wait... ======&quot;
        else
            break
        fi
    done
    echo__blue &quot; === Uninstall existed stack successfully === &quot;
}

function _mod_env_file_part()
{
    echo__blue &quot;====== Begin to modify env file... ======&quot;
    image=`echo ${REPLY##*/} | cut -d &quot;.&quot; -f 1,2`
    RCP_HEAT_FILE=&quot;rcp-heat/$STACK_TYPE/rcp-heat.env&quot;
    sed -i &quot;s/image: .*/image: $image/g&quot; $RCP_HEAT_FILE
    echo__blue &quot;====== Modify successfully ======&quot;
}

function _mod_env_file_full()
{
    echo__blue &quot;====== Begin to modify env file... ======&quot;  
    availability_zone=&quot;nova&quot;
    cluster_id=&quot;RCP-1234&quot;
    dns_forwarders=&quot;10.56.126.31&quot;
    config_drive=&quot;false&quot;
    ext0=&quot;`neutron net-list | grep hran${num} | awk &#39;{print $4}&#39; | awk &#39;NR==1&#39;`&quot;
    ext1=&quot;`neutron net-list | grep hran${num} | awk &#39;{print $4}&#39; | awk &#39;NR==2&#39;`&quot;
    ext2=&quot;`neutron net-list | grep hran${num} | awk &#39;{print $4}&#39; | awk &#39;NR==3&#39;`&quot;
    cp=&quot;rcp_medium_v2&quot;
    ei=&quot;rcp_xlarge_v2&quot;
    mn=&quot;rcp_large_v2&quot;
    up=&quot;rcp_xlarge_v2&quot;
    uvm=&quot;rcp_medium_v2&quot;
    hostname_prefix=&quot;abc&quot;
    image=`echo ${RCP_IMAGE_URL##*/} | cut -d &quot;.&quot; -f 1,2`
    key_name=`nova keypair-list | awk &#39;NR&gt;2&#39; | awk &#39;{print $2}&#39; | awk &#39;{if(length!=0) print $0}&#39;`
    if [ -z &quot;$key_name&quot; ];then
        nova keypair-add default_key
        key_name=`nova keypair-list | awk &#39;NR&gt;2&#39; | awk &#39;{print $2}&#39; | awk &#39;{if(length!=0) print $0}&#39;`
    fi
    ntp_servers=&quot;10.39.12.252&quot;
    number_of_uvm_nodes=&quot;0&quot;
    ### use oam uuid
    #oam_network=&quot;`nova network-list | grep -w &quot;vnfoam &quot; | awk &#39;{print $2}&#39;`&quot;
    ### use oam name
    oam_network=&quot;vnfoam&quot;
    _nokadmin=&quot;Nokia123&quot;
    _nokfsoperator=&quot;RCP_owner&quot;
    root=&quot;root&quot;
    time_zone=&quot;Asia/Shanghai&quot;    
    vif_models=&quot;avp&quot;
    vif_models_2=&quot;virtio&quot;  
    rcp_heat_file=&quot;rcp-heat/$STACK_TYPE/rcp-heat.env&quot;
    sed -i &quot;s/availability_zone: .*/availability_zone: $availability_zone/g&quot; ${rcp_heat_file}
    sed -i &quot;s/cluster_id: .*/cluster_id: $cluster_id/g&quot; ${rcp_heat_file}
    sed -i &quot;s/dns_forwarders: .*/dns_forwarders: $dns_forwarders/g&quot; ${rcp_heat_file}
    sed -i &quot;s/config_drive: .*/config_drive: $config_drive/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ext0: .*/ext0: $ext0/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ext1: .*/ext1: $ext1/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ext2: .*/ext2: $ext2/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ cp: .*/ cp: $cp/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ ei: .*/ ei: $ei/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ mn: .*/ mn: $mn/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ up: .*/ up: $up/g&quot; ${rcp_heat_file}
    sed -i &quot;s/uvm: .*/uvm: $uvm/g&quot; ${rcp_heat_file}
    sed -i &quot;s/hostname_prefix: .*/hostname_prefix: $hostname_prefix/g&quot; ${rcp_heat_file}
    sed -i &quot;s/image: .*/image: $image/g&quot; ${rcp_heat_file}
    sed -i &quot;s/key_name: .*/key_name: $key_name/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ntp_servers: .*/ntp_servers: $ntp_servers/g&quot; ${rcp_heat_file}
    sed -i &quot;s/number_of_uvm_nodes: .*/number_of_uvm_nodes: $number_of_uvm_nodes/g&quot; ${rcp_heat_file}
    sed -i &quot;s/oam_network: .*/oam_network: $oam_network/g&quot; ${rcp_heat_file}
    sed -i &quot;s/_nokadmin: .*/_nokadmin: $_nokadmin/g&quot; ${rcp_heat_file}
    sed -i &quot;s/_nokfsoperator: .*/_nokfsoperator: $_nokfsoperator/g&quot; ${rcp_heat_file}
    sed -i &quot;s/root: .*/root: $root/g&quot; ${rcp_heat_file}
    sed -i &quot;s#time-zone: .*#time-zone: $time_zone#g&quot; ${rcp_heat_file}
    sed -i &quot;s/uvm_image: .*/uvm_image: $image/g&quot; ${rcp_heat_file}  
    sed -i &quot;s/ external: .*/ external: $vif_models/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ internal: .*/ internal: $vif_models_2/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ oam: .*/ oam: $vif_models/g&quot; ${rcp_heat_file}   
    echo__blue &quot;====== Modify successfully ======&quot;
}

function _launch_stack()
{
    echo__blue &quot;====== Begin to launch stack ======&quot;
    openstack stack create -f yaml -e $LOCAL_DIR/$STACK_TYPE/rcp-heat.env -t $LOCAL_DIR/$STACK_TYPE/rcp-heat.yaml ${CURRENT_DIR##*/}_auto
    while ((1))
    do
        STACK_STATUS=`openstack stack list | awk &#39;{print $6}&#39; | awk &#39;NR&gt;2&#39; | awk &#39;{if(length!=0) print $0}&#39;`
        if [ &quot;CREATE_COMPLETE&quot; != &quot;${STACK_STATUS}&quot; ];then
            sleep 30
            echo__blue &quot;====== Installing, please wait... ======&quot;
        else
            break
        fi
    done
    oam=`nova list | grep vnfoam | awk &#39;{print $13}&#39;`
    echo__blue_shining &quot;====== Launch stack successfully, ${oam} DONE ====== \033[05m ${oam}&quot;
}

function reinstall_stack_1()
{
    _uninstall_old_stack
    _launch_stack
}

function reinstall_stack_2()
{
    _create_image $REPLY
    _uninstall_old_stack
    _mod_env_file_part
    _launch_stack
    rm -f $LOCAL_DIR/${REPLY##*/}
}

function reinstall_stack_3()
{
    _download_yaml
    _mod_env_file_full
    _create_image ${RCP_IMAGE_URL}
    _uninstall_old_stack
    _launch_stack
    rm -f $LOCAL_DIR/${RCP_IMAGE_URL##*/}
}


case &quot;$1&quot; in
    1)
      echo &quot;Begin to re-install stack.....&quot;
      reinstall_stack_1
      echo &quot;Script completes!!!!!&quot;
      exit 1
      ;;
    2)
      read -p &quot;Please input specified image url: &quot;
      echo &quot;Begin to re-install stack with image ${REPLY##*/}.....&quot;
      reinstall_stack_2
      echo &quot;Script completes!!!!!&quot;
      exit 1
      ;;
    3)
      read -p &quot;Please input specified image url: &quot; RCP_IMAGE_URL
      read -p &quot;Please input specified yaml url: &quot; RCP_TEMPLATE_URL
      echo &quot;Begin to re-install stack with image ${RCP_IMAGE_URL##*/} and yaml ${RCP_TEMPLATE_URL##*/}.....&quot;
      reinstall_stack_3
      echo &quot;Script completes!!!!!&quot;
      exit 1
      ;;
    *)
      echo &quot;Usage:
            run 1  --- will re-install stack with default image.
            run 2  --- will re-install stack with specified image.
            run 3  --- will re-install stack with specified image and yaml parameter.&quot;
      exit 1
      ;;
esac
exit 0
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Auto Install Stack]]></title>
    <link href="https://sparkbye.github.io/myBlog/15161072350728.html"/>
    <updated>2018-01-16T20:53:55+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15161072350728.html</id>
    <content type="html"><![CDATA[
<p>自动安装脚本：</p>

<pre><code class="language-sh">#!/bin/bash

##############################################################################
# Use script like this:
# ./auto_install_stack.sh ${num}
#            run 1  --- will re-install stack with default image.
#            run 2  --- will re-install stack with specified image(install new stack with same yaml file).
#            run 3  --- will re-install stack with specified image and yaml parameter(first use this scripts).
##############################################################################

set +x

function echo_color(){
    case $1 in
        &quot;red&quot;)
            echo -e &quot;\033[31m $2 \033[0m&quot; ;;
        &quot;red-shining&quot;)
            echo -e &quot;\033[31m \033[05m $2 \033[0m&quot; ;;
        &quot;yellow&quot;)
            echo -e &quot;\033[33m $2 \033[0m&quot; ;;
        &quot;blue&quot;)
            echo -e &quot;\033[34m $2 \033[0m&quot; ;;
        &quot;blue-shining&quot;)
            echo -e &quot;\033[34m \033[05m $2 \033[0m&quot; ;;
        &quot;purple&quot;)
            echo -e &quot;\033[35m $2 \033[0m&quot; ;;
        &quot;green&quot;)
            echo -e &quot;\033[32m $2 \033[0m&quot; ;;
        &quot;*&quot;)
            echo -e &quot;\033[37m $2 \033[0m&quot; ;;
    esac
}

current_dir=`pwd`
num=`echo ${current_dir##*/} | tr -cd &quot;[0-9]&quot;`
if [ ${current_dir##*/} != &quot;hranuser${num}&quot; ]
then
    echo_color red &quot; === Error: Current directory must be end with &#39;/hranuser&#39; ===&quot;
    exit -1
fi
local_dir=&quot;rcp-heat&quot;
stack_type=&quot;net&quot;
if [ ! -d &quot;${local_dir}&quot; ]
then
    mkdir -p ${local_dir}
fi

function _create_image()
{
    RCP_IMAGE_URL=$1
    IMAGE_FILE=${RCP_IMAGE_URL##*/}
    echo_color blue &quot; === Begin to download RCP image to ${local_dir}/${IMAGE_FILE} === &quot;
    wget -O ${local_dir}/${IMAGE_FILE} ${RCP_IMAGE_URL}
    if [ $? -ne 0 ]
    then
        set +x
        echo_color red &quot; === Download image unsuceessfully, please check your image name is right === &quot;
        exit -1
    fi
    echo_color blue &quot; === Download image suceessfully ==== &quot;
    echo_color blue &quot; === Begin to create image === &quot;
    nova image-delete ${IMAGE_FILE}
    glance image-create --name=${IMAGE_FILE} --container-format=bare --visibility=private --disk-format=qcow2 --file=${local_dir}/${IMAGE_FILE}
    glance_status=`nova image-show ${IMAGE_FILE} | grep status | awk &#39;{print $4}&#39;`
    if [ &quot;ACTIVE&quot; != &quot;${glance_status}&quot; ]
    then
        echo_color blue-shining &quot; === Waiting for image active... ==== &quot;
        sleep 5
    fi
    echo_color blue &quot; === Create image suceessfully ==== &quot;
    sleep 3
}

function _download_yaml()
{
    TEMPLATE_FILE=${RCP_TEMPLATE_URL##*/}
    echo_color blue &quot; === Downloading RCP template to ${local_dir}/${TEMPLATE_FILE} === &quot;
    wget -O ${local_dir}/${TEMPLATE_FILE} ${RCP_TEMPLATE_URL}
    if [ $? -ne 0 ]
    then
        set +x
        echo_color red &quot; === Download template unsuceessfully, please check your template file is right === &quot;
        exit -1
    fi
    echo_color blue &quot; === Download template suceessfully ==== &quot;
    ls -l ${local_dir}
    tar -xzvf ${local_dir}/${TEMPLATE_FILE} -C ${local_dir}
    rm -f ${local_dir}/${TEMPLATE_FILE}
}

function _uninstall_old_stack()
{
    echo_color blue &quot; === Begin to uninstall existed stack === &quot;
    ### === used for N34 === ###
    STACK_UUID=`heat stack-list | awk &#39;{print $2}&#39; | awk &#39;NR&gt;2&#39; | awk &#39;{if(length!=0) print $0}&#39;`
    ### === used for touchdown === ###
    # STACK_UUID=`heat stack-list | grep touchdown | awk &#39;{print $2}&#39; | awk &#39;{if(length!=0) print $0}&#39;`
    if [ -n &quot;${STACK_UUID}&quot; ]
    then    
        heat stack-delete ${STACK_UUID}
        while ((1))
        do
            set +x
            STACK_STATUS=`heat stack-list | awk &#39;{print $6}&#39; | awk &#39;NR&gt;2&#39; | awk &#39;{if(length!=0) print $0}&#39;`
            if [ -n &quot;${STACK_STATUS}&quot; ]
            then
                sleep 10
                echo_color blue &quot; === Deleting old stack, please wait... === &quot;
            else
                break
            fi
        done
    fi
    echo_color blue &quot; === Uninstall existed stack successfully === &quot;
}

function _mod_env_file_part()
{
    echo_color blue &quot; === Begin to modify env file... === &quot;
    RCP_IMAGE_URL=$REPLY
    IMAGE_FILE=${RCP_IMAGE_URL##*/}
    rcp_heat_file=&quot;rcp-heat/net/rcp-heat.env&quot;
    sed -i &quot;s/image: .*/image: ${IMAGE_FILE}/g&quot; ${rcp_heat_file}
    echo_color blue &quot; === Modify successfully. === &quot;
}

function _mod_env_file_full()
{
    echo_color blue &quot; === Begin to modify env file... === &quot;
    IMAGE_FILE=${RCP_IMAGE_URL##*/}
    key_name=&quot;default_key&quot;
    cluster_id=&quot;RCP-1234&quot;
    hostname_prefix=&quot;abc&quot;
    cp=&quot;rcp_medium_v2&quot;
    ei=&quot;rcp_xlarge_v2&quot;
    mn=&quot;rcp_large_v2&quot;
    up=&quot;rcp_xlarge_v2&quot;
    uvm=&quot;rcp_medium_v2&quot;
    time_zone=&quot;Asia/Shanghai&quot;
    ### use oam uuid
    #oam_network=&quot;`nova network-list | grep -w &quot;vnfoam &quot; | awk &#39;{print $2}&#39;`&quot;
    ### use oam name
    oam_network=&quot;vnfoam&quot;
    ntp_servers=&quot;10.39.12.252&quot;
    dns_forwarders=&quot;10.56.126.31&quot;
    vif_models=&quot;avp&quot;
    vif_models_2=&quot;virtio&quot;
    _nokadmin=&quot;Nokia123&quot;
    _nokfsoperator=&quot;RCP_owner&quot;
    root=&quot;root&quot;
    ext0=&quot;`nova network-list | grep hran${num} | awk &#39;{print $4}&#39; | awk &#39;NR==1&#39;`&quot;
    ext1=&quot;`nova network-list | grep hran${num} | awk &#39;{print $4}&#39; | awk &#39;NR==2&#39;`&quot;
    ext2=&quot;`nova network-list | grep hran${num} | awk &#39;{print $4}&#39; | awk &#39;NR==3&#39;`&quot;
    number_of_uvm_nodes=&quot;0&quot;
    rcp_heat_file=&quot;rcp-heat/net/rcp-heat.env&quot;
    sed -i &quot;s/image: .*/image: ${IMAGE_FILE}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/key_name: .*/key_name: ${key_name}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/cluster_id: .*/cluster_id: ${cluster_id}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/hostname_prefix: .*/hostname_prefix: ${hostname_prefix}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ cp: .*/ cp: ${cp}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ ei: .*/ ei: ${ei}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ mn: .*/ mn: ${mn}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ up: .*/ up: ${up}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/uvm: .*/uvm: ${uvm}/g&quot; ${rcp_heat_file}
    sed -i &quot;s#time-zone: .*#time-zone: ${time_zone}#g&quot; ${rcp_heat_file}
    sed -i &quot;s/oam_network: .*/oam_network: ${oam_network}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ntp_servers: .*/ntp_servers: ${ntp_servers}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/dns_forwarders: .*/dns_forwarders: ${dns_forwarders}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/_nokadmin: .*/_nokadmin: ${_nokadmin}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/_nokfsoperator: .*/_nokfsoperator: ${_nokfsoperator}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/root: .*/root: ${root}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ext0: .*/ext0: ${ext0}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ext1: .*/ext1: ${ext1}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ext2: .*/ext2: ${ext2}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ external: .*/ external: ${vif_models}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ internal: .*/ internal: ${vif_models_2}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ oam: .*/ oam: ${vif_models}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/number_of_uvm_nodes: .*/number_of_uvm_nodes: ${number_of_uvm_nodes}/g&quot; ${rcp_heat_file}
    nova keypair-add ${key_name}
    echo_color blue &quot; === Modify successfully. === &quot;
}

function _launch_stack()
{
    echo_color blue &quot; === Begin to launch stack === &quot;
    heat stack-create -e ${local_dir}/${stack_type}/rcp-heat.env -f ${local_dir}/${stack_type}/rcp-heat.yaml touchdown_auto
    while ((1))
    do
        set +x
        STACK_STATUS=`heat stack-list | awk &#39;{print $6}&#39; | awk &#39;NR&gt;2&#39; | awk &#39;{if(length!=0) print $0}&#39;`
        if [ &quot;CREATE_COMPLETE&quot; != &quot;${STACK_STATUS}&quot; ]
        then
            sleep 30
            echo_color blue &quot; === Installing, please wait... === &quot;
        else
            break
        fi
    done
    oam=`nova list | grep vnfoam | awk &#39;{print $14}&#39;`
    echo_color blue &quot; === Launch stack successfully, ${oam} === \033[05m ${oam} &quot;
}

function reinstall_stack_1()
{
    _uninstall_old_stack
    _launch_stack
}

function reinstall_stack_2()
{
    _create_image $REPLY
    _uninstall_old_stack
    _mod_env_file_part
    _launch_stack
    rm -f ${local_dir}/${IMAGE_FILE}
}

function reinstall_stack_3()
{
    _download_yaml
    _mod_env_file_full
    _create_image ${RCP_IMAGE_URL}
    _uninstall_old_stack
    _launch_stack
    rm -f ${local_dir}/${IMAGE_FILE}
}


case &quot;$1&quot; in
    1)
      echo &quot;Begin to re-install stack.....&quot;
      reinstall_stack_1
      echo &quot;Script completes!!!!!&quot;
      exit 1
      ;;
    2)
      read -p &quot;Please input specified image url: &quot;
      echo &quot;Begin to re-install stack with image ${REPLY##*/}.....&quot;
      reinstall_stack_2
      echo &quot;Script completes!!!!!&quot;
      exit 1
      ;;
    3)
      read -p &quot;Please input specified image url: &quot; RCP_IMAGE_URL
      read -p &quot;Please input specified yaml url: &quot; RCP_TEMPLATE_URL
      echo &quot;Begin to re-install stack with image ${RCP_IMAGE_URL##*/} and yaml ${RCP_TEMPLATE_URL##*/}.....&quot;
      reinstall_stack_3
      echo &quot;Script completes!!!!!&quot;
      exit 1
      ;;
    *)
      echo &quot;Usage:
            run 1  --- will re-install stack with default image.
            run 2  --- will re-install stack with specified image.
            run 3  --- will re-install stack with specified image and yaml parameter.&quot;
      exit 1
      ;;
esac
exit 0
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Auto Migrate Tools(v2.0)]]></title>
    <link href="https://sparkbye.github.io/myBlog/15161070375181.html"/>
    <updated>2018-01-16T20:50:37+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15161070375181.html</id>
    <content type="html"><![CDATA[
<p>更新了下脚本：<br/>
还是有些问题：<br/>
1. 如果有其他Project的node怎么处理？<br/>
2. 如果有自己的其他node怎么处理？</p>

<pre><code class="language-sh">#!/bin/bash

function echo__blue()      { echo -e &quot;\e[0;34;1m$1\e[0m&quot;;}
function echo__red()       { echo -e &quot;\e[0;31;1m$1\e[0m&quot;;}
function echo__green()     { echo -e &quot;\e[0;32;1m$1\e[0m&quot;;}
function echo__yellow()    { echo -e &quot;\e[0;33;1m$1\e[0m&quot;;}

COMPUTER_LIST=`nova hypervisor-list | awk &#39;{print $4}&#39; | awk &#39;NR&gt;2&#39; | awk &#39;{if(length!=0) print $0}&#39;`
UE_NODE_LIST=`nova list | grep ei | awk &#39;{print $4}&#39;`
UE_NODE_NAME=`nova list | grep ei-0 | awk &#39;{print $4}&#39;`
OTHER_NODE_LIST=`nova list --fields name | grep -v ei | awk &#39;NR&gt;2&#39; | awk &#39;{print $4}&#39; | awk &#39;{if(length!=0) print $0}&#39;`
OPTIMAL_COMPUTE=&#39;&#39;
INFERIOR_COMPUTE=&#39;&#39;
INIT_USED=8.0

for COMPUTER in $COMPUTER_LIST
    do
        CPUS_USED=`nova hypervisor-show $COMPUTER | grep -i &quot;vcpus_used&quot; | awk &#39;{print $4}&#39; | head -1`
        echo__blue &quot;$COMPUTER node&#39;s vcpus_used is :  $CPUS_USED&quot;
        if [[ $(echo &quot;$CPUS_USED == 0.0&quot;|bc) = 1 ]];then
            echo__blue &quot;Greate! $COMPUTER is a optimal computer.&quot;
            OPTIMAL_COMPUTER=$COMPUTER
            break
        elif [[ $(echo &quot;$CPUS_USED &gt; 0.0&quot;|bc) = 1 ]] &amp;&amp; [[ $(echo &quot;$CPUS_USED &lt; 8.0 &quot;|bc) = 1 ]];then
            echo__green &quot;Maybe $COMPUTER is a selectable computer.&quot;
            if [[ $(echo &quot;$CPUS_USED &lt; $INIT_USED&quot;|bc) = 1 ]];then
                INIT_USED=$CPUS_USED
                INFERIOR_COMPUTE=$COMPUTER
                echo__blue &quot;Now OPTIMAL_COMPUTER is: $COMPUTER.&quot;
            fi
        elif [[ $(echo &quot;$CPUS_USED &gt;= 8.0&quot;|bc) = 1 ]] &amp;&amp; [[ $(echo &quot;$CPUS_USED &lt;= 13.0 &quot;|bc) = 1 ]];then
            echo__red &quot;Maybe $COMPUTER is not a good choice.&quot;
            INSTANCE_NUMBER=`nova hypervisor-servers compute-159 | awk &#39;{print $4}&#39; | awk &#39;NR&gt;2&#39; | awk &#39;{if(length!=0) print $0}&#39; | wc -l`
            USED_RATE=$(echo &quot;$CPUS_USED / $INSTANCE_NUMBER&quot; | bc)
            echo &quot;===========USED_RATE: $USED_RATE=============&quot;
            if [[ $(echo &quot;$USED_RATE &lt; $INIT_USED&quot;|bc) = 1 ]];then
                INIT_USED=$USED_RATE
                echo &quot;===========INIT_USED: $INIT_USED=============&quot;
                INFERIOR_COMPUTE=$COMPUTER
                echo__blue &quot;Now OPTIMAL_COMPUTER is: $COMPUTER.&quot;
            else
                continue
            fi
        else
            echo__red &quot;This computer node is full.&quot;
        fi
    done
    echo &quot;===========Finally the chosen computer is : 1. $OPTIMAL_COMPUTER  2. $INFERIOR_COMPUTE.==============&quot;

for INSTANCE_NAME in $OTHER_NODE_LIST
        do
            UE_COMPUTE=`nova list --fields name,host,wrs-res:topology | grep $INSTANCE_NAME | awk &#39;{print $6}&#39;`
            CPUS_USED=`nova hypervisor-show $UE_COMPUTE | grep -i &quot;vcpus_used&quot; | awk &#39;{print $4}&#39; | head -1`
            echo__blue &quot;$UE_COMPUTE node&#39;s vcpus_used is :  $CPUS_USED&quot;
            if [[ $(echo &quot;$CPUS_USED == 8.0&quot;|bc) = 1 ]];then
                echo__blue &quot;Greate! $UE_COMPUTE is a optimal computer.&quot;
                OPTIMAL_COMPUTER=$UE_COMPUTE
                break
            else
                continue
            fi
        done
    echo__red &quot;All UE instance are not stand alone.&quot;

for INSTANCE_NAME in $UE_NODE_LIST
        do
            UE_COMPUTE=`nova list --fields name,host,wrs-res:topology | grep $INSTANCE_NAME | awk &#39;{print $6}&#39;`
            CPUS_USED=`nova hypervisor-show $UE_COMPUTE | grep -i &quot;vcpus_used&quot; | awk &#39;{print $4}&#39; | head -1`
            echo__blue &quot;$UE_COMPUTE node&#39;s vcpus_used is :  $CPUS_USED&quot;
            if [[ $(echo &quot;$CPUS_USED == 8.0&quot;|bc) = 1 ]];then
                echo__blue &quot;Greate! $UE_COMPUTE is a optimal computer.&quot;
                OPTIMAL_COMPUTER=$UE_COMPUTE
                break
            else
                continue
            fi
        done
    echo__red &quot;All other instance are not stand alone.&quot;

echo__green &quot;==============Begin to migrate UE node to $OPTIMAL_COMPUTER.=====================&quot;
if [[ -z &quot;$OPTIMAL_COMPUTER&quot; ]];then
    for UE_NODE in $UE_NODE_LIST
        do
            nova live-migration $UE_NODE $OPTIMAL_COMPUTER
            sleep 5
            if [ &quot;Running&quot; != &quot;$UE_NODE_STATE&quot; ];then
                echo &quot;Still migrating, please wait...&quot;
                sleep 5     
            fi
        done
else
    for UE_NODE in $UE_NODE_LIST
        do
            nova live-migration $UE_NODE $INFERIOR_COMPUTE
            sleep 5
            if [ &quot;Running&quot; != &quot;$UE_NODE_STATE&quot; ];then
                echo &quot;Still migrating, please wait...&quot;
                sleep 5     
            fi
        done   
fi

echo__green &quot;Live migration is successfully.&quot;
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python对象的浅拷贝与深拷贝]]></title>
    <link href="https://sparkbye.github.io/myBlog/15156751072902.html"/>
    <updated>2018-01-11T20:51:47+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15156751072902.html</id>
    <content type="html"><![CDATA[
<p>我们知道，对象赋值实际上是简单的对象引用。也就是说，当你创建了一个对象，然后把它赋值给另外一个变量的时候，Python并没有拷贝这个对象，而是拷贝了这个对象的引用。<br/>
举例说明：</p>

<pre><code class="language-python">x = 3.14
y = x
</code></pre>

<p>语句<code>x = 3.14</code>创建了一个浮点型对象并将其引用赋值给x。<br/>
x是第一个引用。<br/>
语句<code>y = x</code>创建了一个指向同一对象的别名y，而事实上并没有为y创建一个新对象(该对象引用计数变成了2)。<br/>
<img src="media/15156751072902/15156757071783.jpg" alt=""/></p>

<h3 id="toc_0">对象赋值</h3>

<p>直接看一段代码：</p>

<pre><code class="language-python">will = [&quot;Will&quot;, 28, [&quot;Python&quot;, &quot;C#&quot;, &quot;JavaScript&quot;]]
wilber = will
print id(will)
print will
print [id(ele) for ele in will]
print id(wilber)
print wilber
print [id(ele) for ele in wilber]

will[0] = &quot;Wilber&quot;
will[2].append(&quot;CSS&quot;)
print id(will)
print will
print [id(ele) for ele in will]
print id(wilber)
print wilber
print [id(ele) for ele in wilber]
</code></pre>

<p>代码的输出为：<br/>
<img src="media/15156751072902/15156770585054.png" alt=""/></p>

<p>下面来分析一下这段代码：</p>

<ul>
<li>首先，创建了一个名为will的变量，这个变量指向一个list对象，从第一张图中可以看到所有对象的地址（每次运行，结果可能不同）</li>
<li>然后，通过will变量对wilber变量进行赋值，那么wilber变量将指向will变量对应的对象（内存地址），也就是说&quot;wilber is will&quot;，&quot;wilber[i] is will[i]&quot;

<ul>
<li>可以理解为，Python中，对象的赋值都是进行对象引用（内存地址）传递</li>
</ul></li>
<li>第三张图中，由于will和wilber指向同一个对象，所以对will的任何修改都会体现在wilber上

<ul>
<li>这里需要注意的一点是，str是不可变类型，所以当修改的时候会替换旧的对象，产生一个新的地址39758496
<img src="media/15156751072902/15156771227464.png" alt=""/></li>
</ul></li>
</ul>

<h3 id="toc_1">浅拷贝</h3>

<p>下面就来看看浅拷贝的结果：</p>

<pre><code class="language-python">import copy

will = [&quot;Will&quot;, 28, [&quot;Python&quot;, &quot;C#&quot;, &quot;JavaScript&quot;]]
wilber = copy.copy(will)

print id(will)
print will
print [id(ele) for ele in will]
print id(wilber)
print wilber
print [id(ele) for ele in wilber]

will[0] = &quot;Wilber&quot;
will[2].append(&quot;CSS&quot;)
print id(will)
print will
print [id(ele) for ele in will]
print id(wilber)
print wilber
print [id(ele) for ele in wilber]
</code></pre>

<p>代码的输出结果如下：<br/>
<img src="media/15156751072902/15156771638072.png" alt=""/><br/>
分析一下这段代码：</p>

<ul>
<li>首先，依然使用一个will变量，指向一个list类型的对象</li>
<li>然后，通过copy模块里面的浅拷贝函数copy()，对will指向的对象进行浅拷贝，然后浅拷贝生成的新对象赋值给wilber变量

<ul>
<li>浅拷贝会创建一个新的对象，这个例子中&quot;wilber is not will&quot;</li>
<li>但是，对于对象中的元素，浅拷贝就只会使用原始元素的引用（内存地址），也就是说&quot;wilber[i] is will[i]&quot;</li>
</ul></li>
<li>当对will进行修改的时候

<ul>
<li>由于list的第一个元素是不可变类型，所以will对应的list的第一个元素会使用一个新的对象39758496</li>
<li>但是list的第三个元素是一个可不类型，修改操作不会产生新的对象，所以will的修改结果会相应的反应到wilber上
<img src="media/15156751072902/15156771821899.png" alt=""/>
总结一下，当我们使用下面的操作的时候，会产生浅拷贝的效果：</li>
</ul></li>
<li>使用切片[:]操作</li>
<li>使用工厂函数（如list/dir/set）</li>
<li>使用copy模块中的copy()函数
例如：</li>
</ul>

<pre><code class="language-python">will = [&quot;Will&quot;, 28, [&quot;Python&quot;, &quot;C#&quot;, &quot;JavaScript&quot;]]
willber = will[:]
wiww = list(will)
</code></pre>

<h3 id="toc_2">深拷贝</h3>

<p>最后来看看深拷贝：</p>

<pre><code class="language-python">import copy

will = [&quot;Will&quot;, 28, [&quot;Python&quot;, &quot;C#&quot;, &quot;JavaScript&quot;]]
wilber = copy.deepcopy(will)

print id(will)
print will
print [id(ele) for ele in will]
print id(wilber)
print wilber
print [id(ele) for ele in wilber]

will[0] = &quot;Wilber&quot;
will[2].append(&quot;CSS&quot;)
print id(will)
print will
print [id(ele) for ele in will]
print id(wilber)
print wilber
print [id(ele) for ele in wilber]
</code></pre>

<p>代码的输出结果如下：<br/>
<img src="media/15156751072902/15156773634373.png" alt=""/></p>

<p>分析一下这段代码：</p>

<ul>
<li>首先，同样使用一个will变量，指向一个list类型的对象</li>
<li>然后，通过copy模块里面的深拷贝函数deepcopy()，对will指向的对象进行深拷贝，然后深拷贝生成的新对象赋值给wilber变量

<ul>
<li>跟浅拷贝类似，深拷贝也会创建一个新的对象，这个例子中&quot;wilber is not will&quot; </li>
<li>但是，对于对象中的元素，深拷贝都会重新生成一份（有特殊情况，下面会说明），而不是简单的使用原始元素的引用（内存地址）

<ul>
<li>例子中will的第三个元素指向39737304，而wilber的第三个元素是一个全新的对象39773088，也就是说，&quot;wilber[2] is not will[2]&quot;</li>
</ul></li>
</ul></li>
<li>当对will进行修改的时候

<ul>
<li>由于list的第一个元素是不可变类型，所以will对应的list的第一个元素会使用一个新的对象39758496</li>
<li>但是list的第三个元素是一个可不类型，修改操作不会产生新的对象，但是由于&quot;wilber[2] is not will[2]&quot;，所以will的修改不会影响wilber
<img src="media/15156751072902/15156773891985.png" alt=""/></li>
</ul></li>
</ul>

<h3 id="toc_3">拷贝的特殊情况</h3>

<p>其实，对于拷贝有一些特殊情况：</p>

<ul>
<li>对于非容器类型（如数字、字符串、和其他&#39;原子&#39;类型的对象）没有拷贝这一说

<ul>
<li>也就是说，对于这些类型，&quot;obj is copy.copy(obj)&quot; 、&quot;obj is copy.deepcopy(obj)&quot;</li>
</ul></li>
<li>如果元祖变量只包含原子类型对象，则不能深拷贝，看下面的例子
<img src="media/15156751072902/15156774222287.png" alt=""/></li>
</ul>

<h3 id="toc_4">总结</h3>

<p>本文介绍了对象的赋值和拷贝，以及它们之间的差异：<br/>
* Python中对象的赋值都是进行对象引用（内存地址）传递<br/>
* 使用copy.copy()，可以进行对象的浅拷贝，它复制了对象，但对于对象中的元素，依然使用原始的引用.<br/>
* 如果需要复制一个容器对象，以及它里面的所有元素（包含元素的子元素），可以使用copy.deepcopy()进行深拷贝<br/>
* 对于非容器类型（如数字、字符串、和其他&#39;原子&#39;类型的对象）没有被拷贝一说<br/>
* 如果元祖变量只包含原子类型对象，则不能深拷贝.</p>

<p>文章引用：<br/>
<a href=""></a><a href="https://www.cnblogs.com/wilber2013/p/4645353.html">https://www.cnblogs.com/wilber2013/p/4645353.html</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pyhton变量变换原理]]></title>
    <link href="https://sparkbye.github.io/myBlog/15142967450536.html"/>
    <updated>2017-12-26T21:59:05+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15142967450536.html</id>
    <content type="html"><![CDATA[
<p>我们在C语言中实现变量交换，往往会使用到通过中间变量来交换两个变量的值：</p>

<pre><code class="language-C">tmp = x;
x = y;
y = tmp;
</code></pre>

<p>而在python中，则无需中间变量即可实现：</p>

<pre><code class="language-python">x , y = y, x
</code></pre>

<p>看起来很神奇，那么具体实现机制是什么呢？<br/>
将这个之前，我们先来了解python的多元赋值机制(《python核心编程3.2》)。通常形式是这样的：</p>

<pre><code class="language-python">x, y , z = 1, 2, &#39;a string&#39;
</code></pre>

<p>采取这种方式的赋值是，等号两边的对象其实都是元祖，即：</p>

<pre><code class="language-python">(x, y, z) = (1, 2, &#39;a string&#39;)
</code></pre>

<p>变量名x, y, z都是引用，内存开辟除了三个空间分别存储1, 2, &#39;a string&#39;，三个变量分别指向这三块地址。由这三个变量构造的元组tuple，<strong>它有三个元素，这三个元素并不是x,y,z这三个变量，而是这三个变量所指向的地址空间里的内容</strong>。如果此时再另x=4,此时在地址空间会另开辟出一块空间存储4，x进而指向这块空间，而元组内的三个值仍保持不变。<br/>
接着我们来解读x, y = y, x， 同样， 它等价于(x, y) = (y, x)。<br/>
运行时，首先构造一个元组(y, x)，然后构造另一个元组(x, y)，接着用元组(y, x)赋值给(x, y)，元组赋值过程从左到右，依次进行。假如x=1,y=2，先令x=y,此时x=2,然后令y=x,y等于1。<br/>
<img src="media/15142967450536/15142979681246.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Unittest与Mock]]></title>
    <link href="https://sparkbye.github.io/myBlog/15142936231027.html"/>
    <updated>2017-12-26T21:07:03+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15142936231027.html</id>
    <content type="html"><![CDATA[
<p><strong>unittest</strong><br/>
python内部自带了一个单元测试的模块，pyUnit也就是我们说的：unittest<br/>
python unittest的框架如下： <br/>
<img src="media/15142936231027/15142937307631.png" alt=""/><br/>
基本使用方法如下：</p>

<ol>
<li>import unittest module</li>
<li>定义一个继承自unittest.TestCase的测试用例类。</li>
<li>定义setUp和tearDown，在每个测试用例前后做一些辅助工作。</li>
<li>定义测试用例，名字需要以test开头。</li>
<li>一个测试用例原则上只测试一个方面，测试目的和测试内容应很明确。主要是调用assertEqual、assertRaises等断言方法判断程序执行结果和预期值是否相符。</li>
<li>调用unittest.main()启动测试</li>
<li>如果测试未通过，会输出相应的错误提示。如果测试全部通过则不显示任何东西，这时可以添加-v参数显示详细信息。</li>
</ol>

<p>这里举个简单的例子说明：<br/>
<img src="media/15142936231027/15142939572020.png" alt=""/></p>

<p>常用的断言：<br/>
<img src="media/15142936231027/15142939778044.png" alt=""/></p>

<p><strong>Mock</strong></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python学习之整数比较]]></title>
    <link href="https://sparkbye.github.io/myBlog/15142090414246.html"/>
    <updated>2017-12-25T21:37:21+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15142090414246.html</id>
    <content type="html"><![CDATA[
<p>最近学习python，发现整数比较时一个有趣的现象：</p>

<pre><code class="language-python">a = 256
b = 256
print id(a)
print id(b)
print(a == b)
print(a is b)
print(id(a) == id(b))
print(id(a) is id(b))
c = 257
d = 257
print id(c)
print id(d)
print(c == d)
print(c is d)
print(id(c) == id(d))
print(id(c) is id(d))
</code></pre>

<p>在pycharm中运行的结果是：</p>

<pre><code>32019104
32019104
True
True
True
False
40550424
40550424
True
True
True
False
</code></pre>

<p>而在Python IDE中运行：</p>

<pre><code class="language-python">&gt;&gt;&gt; a = 256
&gt;&gt;&gt; b = 256
&gt;&gt;&gt; a == b
True
&gt;&gt;&gt; a is b
True
&gt;&gt;&gt; id(a)
32346576L
&gt;&gt;&gt; id(b)
32346576L
&gt;&gt;&gt; c = 257
&gt;&gt;&gt; d = 257
&gt;&gt;&gt; c == d
True
&gt;&gt;&gt; c is d
False
&gt;&gt;&gt; id(c)
39891736L
&gt;&gt;&gt; id(d)
39891712L
</code></pre>

<p>为什么同样是Python2.7.14，得出的结果迥然不同呢？<br/>
在Python中一切都是对象，因此整数也是对象。对象之间比较是否相等可以用==，也可以用is，两者的区别主要是：<br/>
- is比较的是两个对象的id值是否相等，也就是比较俩对象是否为同一个实例对象，是否指向同一个内存地址。<br/>
- ==比较的是两个对象的内容是否相等，默认会调用对象的__eq__()方法。</p>

<p>因此，代码段中<code>a == b</code>很好理解，因为两个对象的值都是256， 而<code>a is b</code>返回True， 说明a和b都是指向同一对象的。但是当值为257时，为什么指向的不是同一个对象呢？</p>

<p><strong>问题一：256和257，差别在哪里？</strong></p>

<p>出于对性能的考虑，Python内部做了很多的优化工作，对于整数对象，Python把一些频繁使用的整数对象缓存起来，保存到一个叫small_ints的链表中，在Python的整个生命周期内，任何需要引用这些整数对象的地方，都不再重新创建新的对象，而是直接引用缓存中的对象。Python把这些可能频繁使用的整数对象规定在范围[-5, 256)之间的小对象放在small_ints中，注意左闭右开。但凡是需要用些小整数时，就从这里面取，不再去临时创建新的对象。因为257不再小整数范围内，因此尽管a和b的值是一样，但是他们在Python内部却是以两个独立的对象存在的，各自为政，互不干涉。</p>

<p>源码位置：<code>Include/intobject.h | Objects/intobject.c</code></p>

<p><strong>小整数对象池：</strong><br/>
小整数对象池就是一个<strong>PyIntObject指针数组</strong></p>

<pre><code class="language-C">#ifndef NSMALLPOSINTS
#define NSMALLPOSINTS 257
#endif
#ifndef NSMALLNEGINTS
#define NSMALLNEGINTS 5
#endif
#if NSMALLNEGINTS + NSMALLPOSINTS &gt; 0
/* References to small integers are saved in this array so that they can be shared. The integers that are saved are those in the range -NSMALLNEGINTS (inclusive) to NSMALLPOSINTS (not inclusive).*/
static PyIntObject *small_ints[NSMALLNEGINTS + NSMALLPOSINTS];
#endif
</code></pre>

<p>其结构如下：<br/>
<img src="media/15142090414246/15142908389467.png" alt=""/></p>

<p><strong>问题二：都是257，is结局为啥不一样？</strong></p>

<p>其实答案就是如此简单：</p>

<p>对于Python而言，存储好的脚本文件（Script file）和在Console中的交互式（interactive）命令，执行方式不同。对于脚本文件，解释器将其当作整个代码块执行，而对于交互性命令行中的每一条命令，解释器将其当作单独的代码块执行。而Python在执行同一个代码块的初始化对象的命令时，会检查是否其值是否已经存在，如果存在，会将其重用（这句话不够严谨，后面会详谈）。所以在给出的例子中，文件执行时（同一个代码块）会把a、b两个变量指向同一个对象；而在命令行执行时，a、b赋值语句分别被当作两个代码块执行，所以会得到两个不同的对象，因而is判断返回False。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Auto Migrate Tool]]></title>
    <link href="https://sparkbye.github.io/myBlog/15142078830298.html"/>
    <updated>2017-12-25T21:18:03+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15142078830298.html</id>
    <content type="html"><![CDATA[
<p>最近需要测试NFV某个node的性能，所以需要Node ei-0单独在一个computer上，所以写了一个脚本：</p>

<pre><code class="language-sh">function echo__blue()      { echo -e &quot;\e[0;34;1m$1\e[0m&quot;;}
function echo__red()       { echo -e &quot;\e[0;31;1m$1\e[0m&quot;;}
function echo__green()     { echo -e &quot;\e[0;32;1m$1\e[0m&quot;;}
function echo__yellow()    { echo -e &quot;\e[0;33;1m$1\e[0m&quot;;}

COMPUTER_LIST=`nova hypervisor-list | awk &#39;{print $4}&#39; | awk &#39;NR&gt;2&#39;`
UE_NODE_NAME=`nova list | grep ei-0 | awk &#39;{print $4}&#39;`
OPTIMAL_COMPUTER=&#39;&#39;
INIT_USED=8.0
for COMPUTER in $COMPUTER_LIST
    do
        CPUS_USED=`nova hypervisor-show $COMPUTER | grep -i &quot;vcpus_used&quot; | awk &#39;{print $4}&#39; | head -1`
        echo__blue &quot;$COMPUTER node&#39;s vcpus_used is :  $CPUS_USED&quot;
        if [[ $(echo &quot;$CPUS_USED == 0.0&quot;|bc) = 1 ]];then
            echo__blue &quot;Greate! $COMPUTER is a optimal computer.&quot;
            OPTIMAL_COMPUTER=$COMPUTER
            break
        elif [[ $(echo &quot;$CPUS_USED &gt; 0.0&quot;|bc) = 1 ]] &amp;&amp; [[ $(echo &quot;$CPUS_USED &lt; 8.0 &quot;|bc) = 1 ]];then
            echo__green &quot;Maybe $COMPUTER is a selectable computer.&quot;
            if [[ $(echo &quot;$CPUS_USED &lt; $INIT_USED&quot;|bc) = 1 ]];then
                INIT_USED=$CPUS_USED
                OPTIMAL_COMPUTER=$COMPUTER
                echo__blue &quot;Now OPTIMAL_COMPUTER is: $COMPUTER.&quot;
            fi
        elif [[ $(echo &quot;$CPUS_USED &gt;= 8.0&quot;|bc) = 1 ]] &amp;&amp; [[ $(echo &quot;$CPUS_USED &lt;= 13.0 &quot;|bc) = 1 ]];then
            echo__red &quot;Maybe $COMPUTER is not a good choice.&quot;
            INSTANCE_NUMBER=`nova hypervisor-servers compute-159 | awk &#39;{print $4}&#39; | awk &#39;NR&gt;2&#39; | awk &#39;{if(length!=0) print $0}&#39; | wc -l`
            USED_RATE=$(echo &quot;$CPUS_USED / $INSTANCE_NUMBER&quot; | bc)
            echo &quot;===========USED_RATE: $USED_RATE=============&quot;
            if [[ $(echo &quot;$USED_RATE &lt; $INIT_USED&quot;|bc) = 1 ]];then
                INIT_USED=$USED_RATE
                echo &quot;===========INIT_USED: $INIT_USED=============&quot;
                OPTIMAL_COMPUTER=$COMPUTER
                echo__blue &quot;Now OPTIMAL_COMPUTER is: $COMPUTER.&quot;
            else
                continue
            fi
        else
            echo__red &quot;This computer node is full.&quot;
        fi
    done
echo &quot;===========Finally the chosen computer is $OPTIMAL_COMPUTER.==============&quot;
echo__green &quot;==============Begin to migrate UE node to $OPTIMAL_COMPUTER.=====================&quot;
nova live-migration $UE_NODE_NAME $OPTIMAL_COMPUTER
UE_NODE_STATE=`nova list | grep ei-0 | awk &#39;{print $10}&#39;`
if [ &quot;Running&quot; != &quot;$UE_NODE_STATE&quot; ];then
    echo &quot;Still migrating, please wait...&quot;
    sleep 5
fi
echo__green &quot;Live migration is successfully.&quot;  
</code></pre>

<p>shell不是经常使用，所以编写过程中才发现浮点数不能判断以及计算的问题，因此记录下，遇到问题可以这么写：</p>

<ul>
<li><p>通过bc</p>

<p>bc是一种任意精度的计算语言，注意是一种语言，它提供了一些语法结构，比如条件判断、循环等，可以说是很强大的，其中一个用途就是用来进行运算以及进制转换。我们经常使用的expr只支持整数运算，对于浮点运算就无能为力了，而且expr不能进行指数运算，而都有bc这些都不再话下。</p>

<pre><code class="language-sh">$(echo &quot;$CPUS_USED &gt; 0.0&quot;|bc) = 1
</code></pre></li>
<li><p>通过dc<br/>
可能你曾经知道有此命令，也可能你还不知道。dc相比与bc要复杂，但是简单操作还是比较简单。简单的说dc是一直压栈操作，和bc一样，它也可以交互使用，或者与echo一起配合使用，它也支持浮点运算。dc后续再作研究。</p></li>
<li><p>expr<br/>
expr竟然也可以？先保存下来，下次再试试：</p>

<pre><code class="language-sh">if [ `expr $a \&gt; $b` -eq 0 ];then
echo $b is bigger
else
echo $a is bigger
fi
</code></pre></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python格式化输出与format函数]]></title>
    <link href="https://sparkbye.github.io/myBlog/15137747318292.html"/>
    <updated>2017-12-20T20:58:51+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15137747318292.html</id>
    <content type="html"><![CDATA[
<p>本文主要整理和汇总python一系列的格式化输出方式：</p>

<p><strong>打印整数</strong></p>

<pre><code class="language-python">print (&quot;I&#39;m number %d&quot; % (20))

&gt;&gt;&gt; I&#39;m number 20  
</code></pre>

<p><strong>打印浮点数(默认)</strong></p>

<pre><code class="language-python">print(&quot;This book&#39;s weight is %f kg&quot; % (0.85))

&gt;&gt;&gt; This book&#39;s height is 0.850000 kg 
</code></pre>

<p><strong>打印浮点数(指定位数)</strong></p>

<pre><code class="language-python">print(&quot;His height is %.2f m&quot; % (1.73))

&gt;&gt;&gt; His height is 1.73 m 
</code></pre>

<p><strong>打印字符串</strong></p>

<pre><code class="language-python">print(&quot;My name is %s&quot; % (&#39;terry&#39;))

&gt;&gt;&gt; My name is terry 
</code></pre>

<p><strong>打印指定占位符宽度</strong></p>

<pre><code class="language-python">print(&quot;Type:%9s Value:%3d Latency:%5.2f&quot; % (&#39;AVP_KMOD&#39;, 44, 0.45))

&gt;&gt;&gt; Type: AVP_KMOD Value: 44 Latency: 0.45 
</code></pre>

<p><strong>打印指定占位符(左对齐)</strong></p>

<pre><code class="language-python">print(&quot;Name:%-10s Age:%-8d Height:%-8.2f&quot;%(&quot;Terry&quot;,25,1.83))

&gt;&gt;&gt; Name:Terry      Age:25       Height:1.83 
</code></pre>

<p><strong>打印指定占位符(前导0)</strong></p>

<pre><code class="language-python">print (&quot;Speed:%010d Rate:%08d Height:%08.2f&quot;%(1000,25,1.83))

&gt;&gt;&gt; Speed:0000001000 Rate:00000025 Height:00001.83 
</code></pre>

<p>在python2.6之后，又增加了一种格式化字符串的函数str.format()，通过{}来代替%。<br/>
用法主要包含以下几类：</p>

<p><strong>通过位置</strong><br/>
字符串的format函数可以接受不限个参数，位置可以不按顺序，可以不用或者用多次:</p>

<pre><code class="language-python">print(&#39;{0},{1},{0}&#39;.format(&#39;aaa&#39;, &#39;bbb&#39;))

&gt;&gt;&gt; aaa,bbb,aaa  
</code></pre>

<p><strong>通过关键字参数</strong></p>

<pre><code class="language-python">print(&#39;{name},{age}&#39;.format(age=18,name=&#39;Terry&#39;))

&gt;&gt;&gt; Terry,18  
</code></pre>

<p><strong>通过对象属性</strong></p>

<pre><code class="language-python">class Person:
    def __init__(self,name,age):
        self.name = name
        self.age = age

    def __str__(self):
        return &#39;This guy is {self.name},he is {self.age} old.&#39;.format(self=self)

print str(Person(&#39;Terry&#39;,18))

&gt;&gt;&gt; This guy is Terry,he is 18 old.
</code></pre>

<p><strong>通过下标</strong></p>

<pre><code class="language-python">person = [&#39;Terry&#39;,18]
print(&#39;{0[0]},{0[1]}&#39;.format(person))

&gt;&gt;&gt; Terry,18
</code></pre>

<p><strong>通过格式</strong><br/>
如上面的前导0：</p>

<pre><code class="language-python">print(&#39;{:0&gt;8}&#39;.format(&#39;189&#39;))
print(&#39;{:&gt;8}&#39;.format(&#39;189&#39;))
print(&#39;{:a&gt;8}&#39;.format(&#39;189&#39;))

&gt;&gt;&gt; 00000189
&gt;&gt;&gt;      189
&gt;&gt;&gt; aaaaa189
</code></pre>

<p>以及浮点数：</p>

<pre><code class="language-python">print(&#39;{:.2f}&#39;.format(321.33345))

&gt;&gt;&gt; 321.33
</code></pre>

<p><strong>其他类型</strong><br/>
主要就是二进制b、十进制d、八进制o、十六进制x:</p>

<pre><code class="language-python">print(&#39;{:b}&#39;.format(46))
print(&#39;{:d}&#39;.format(46))
print(&#39;{:o}&#39;.format(46))
print(&#39;{:x}&#39;.format(46))

&gt;&gt;&gt; 101110
&gt;&gt;&gt; 46
&gt;&gt;&gt; 56
&gt;&gt;&gt; 2e
</code></pre>

<p>此外， 用逗号还能用来做金额的千位分隔符。</p>

<pre><code class="language-python">print(&#39;{:,}&#39;.format(99988844333))

&gt;&gt;&gt; 99,988,844,333
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python中的__name__和__main__]]></title>
    <link href="https://sparkbye.github.io/myBlog/15096259430881.html"/>
    <updated>2017-11-02T20:32:23+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15096259430881.html</id>
    <content type="html"><![CDATA[
<p>对于大多数编译型编程语言来说， 如C、C++、Java等，都会有一个main函数来作为函数的入口。而python则有所不同，它基本属于脚本语言，即从脚本的第一行开始逐行解释运行，没有统一的入口。而&quot;if <strong>name</strong>==&quot;__main__&quot;:&quot; 这一句可以理解为主程序入口；<br/>
python是使用缩进对齐的方式执行的，对于没有缩进的代码，会在载入时自动执行。另外代码除了直接执行外，还可以作为模块调用。为了区分执行和调用，python引入了内置属性：__name__。</p>

<ol>
<li>当代码被执行时，__name__的值为 ‘__main__’</li>
<li>当代码被调用时，如果在模块中，__name__就表示模块名；如果在类中，__name__就表示类名。</li>
</ol>

<p>举个栗子：<br/>
在test_1.py中写入如下代码：</p>

<pre><code>print &quot;I&#39;m the first...&quot;

def test():
    print &quot;I&#39;m the second...&quot;

print __name__
if __name__ == &quot;__main__&quot;:
    test()
    print &quot;I&#39;m the third...&quot;
else:
    print &quot;I&#39;m the last...&quot;
</code></pre>

<p>直接执行test_1.py，会有如下结果：</p>

<pre><code>C:\Python27\python.exe D:/userdata/f7yang/workspace/Python_test/test_libraries/test_study_10/test_1.py
I&#39;m the first...
__main__
I&#39;m the second...
I&#39;m the third...
</code></pre>

<p>可以看出，此时__name__的值为‘__main__’ ，<br/>
而作为调用来执行时：<br/>
<code>from test_1 import test</code><br/>
会有如下结果：</p>

<pre><code>C:\Python27\python.exe D:/userdata/f7yang/workspace/Python_test/test_libraries/test_study_10/test_2.py
I&#39;m the first...
test_1
I&#39;m the last...
</code></pre>

<p>此时__name__的值为test_1，即模块的名字 。 <br/>
其实简而言之，自动执行类似自己称呼自己，调用则类似别人称呼自己，如是而已。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[通过MWeb上传Blog]]></title>
    <link href="https://sparkbye.github.io/myBlog/15095429404216.html"/>
    <updated>2017-11-01T21:29:00+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15095429404216.html</id>
    <content type="html"><![CDATA[
<h6 id="toc_0">你所需要做的，仅仅是：</h6>

<ol>
<li><p>新增分类 -&gt; CSDN Blog</p></li>
<li><p>右击编辑 -&gt; 高级设置 -&gt; 发布服务， 选择MetaWeblog API</p></li>
</ol>

<p><img src="media/15095429404216/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-01%2021.30.08.png" alt="屏幕快照 2017-11-01 21.30.08"/><br/>
3. 生成网站，并推送到博客</p>

<p><img src="media/15095429404216/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-01%2021.41.21.png" alt="屏幕快照 2017-11-01 21.41.21"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义控件]]></title>
    <link href="https://sparkbye.github.io/myBlog/14991719231835.html"/>
    <updated>2017-07-04T20:38:43+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/14991719231835.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">UIView的封装</h3>

<p>如果一个view内部的子控件比较多，一般会考虑自定义一个view，把它内部子控件的创建屏蔽起来，不让外界关心。外界可以传入对应的模型数据给view，view拿到模型数据后给内部的子控件设置对应的数据继承自系统自带的控件，写一个属于自己的控件。<br/>
* 目的：封装空间内部的细节，不让外界关心</p>

<h3 id="toc_1">UIView的封装有两种方式</h3>

<p>通过纯代码封装：<br/>
1. 新建一个继承UIView的类<br/>
2. 在刚刚新建类的类扩展中添加子控件属性（用weak声明，防止内存泄露）<br/>
3. 在initWithFrame:方法中添加子控件<br/>
4. 在layoutSubviews方法中设置子控件的frame（在该方法中一定要调用[super layoutSubviews]方法）<br/>
5. 提供一个模型属性，重写模型属性的set方法<br/>
6. 在该setter方法中取出模型属性，给对应的子控件赋值<br/>
UIView的封装代码如下：</p>

<pre><code> /**
  *  CustomView.h文件
  */

 // 步骤1 新建一个继承UIView的类
 #import &lt;UIKit/UIKit.h&gt;
 @class CustomModel;
 @interface CustomView : UIView
 // 在这里为了方便，可以自行添加构造方法，方便使用
 // 步骤5 提供一个`模型`属性，重写模型属性的set方法
 @property (nonatomic, strong) CustomModel *model;
 @end
</code></pre>

<pre><code>/**
 *  CustomView.m文件
 */
 #import &quot;CustomView.h&quot;
 #import &quot;CustomModel.h&quot;
 @interface CustomView ()
 // 步骤2 在刚刚新建类的`类扩展`中添加子控件属性（用`weak`声明，防止内存泄露）
 @property (nonatomic, weak) UIImageView *iconImageView;
 @property (nonatomic, weak) UILabel *nameLabel;
 @end

 @implementation CustomView
 // 步骤3 在initWithFrame:方法中添加子控件
 - (instancetype)initWithFrame:(CGRect)frame
 {
     if (self = [super initWithFrame:frame]) {
     // 注意：该处不要给子控件设置frame与数据，可以在这里初始化子控件的属性
     UIImageView *iconImageView = [[UIImageView alloc] init];
     self.iconImageView = iconImageView;
     [self addSubview:iconImageView];

     UILabel *nameLabel = [[UILabel alloc] init];
     // 设置子控件的属性
     nameLabel.textAlignment = NSTextAlignmentCenter;
     nameLabel.font = [UIFont systemFontOfSize:10];
     self.nameLabel = nameLabel;
     [self addSubview:nameLabel];
     }
     return self;
 }

 // 步骤4 在`layoutSubviews`方法中设置子控件的`frame`（在该方法中一定要调用`[super layoutSubviews]`方法）
 - (void)layoutSubviews
 {
     [super layoutSubviews];

     CGFloat iconImageViewX = 0;
     CGFloat iconImageViewY = 0;
     CGFloat iconImageViewW = self.bounds.size.width;
     CGFloat iconImageViewH = 80;
     self.iconImageView.frame = CGRectMake(iconImageViewX, iconImageViewY, iconImageViewW, iconImageViewH);

     CGFloat nameLabelX = 0;
     CGFloat nameLabelY = iconImageViewH;
     CGFloat nameLabelW = iconImageViewW;
     CGFloat nameLabelH = self.bounds.size.height - iconImageViewH;
     self.iconImageView.frame = CGRectMake(nameLabelX, nameLabelY, nameLabelW, nameLabelH);
 }

 // 步骤6 在该`setter`方法中取出模型属性，给对应的子控件赋值
 - (void)setModel:(CustomModel *)model
 {
     _model = model;
     self.iconImageView.image = [UIImage imageNamed:model.icon];
     self.nameLabel.text = model.name;
 }
 @end
</code></pre>

<p>layoutSubviews在以下情况下会被调用：<br/>
1. init初始化不会触发layoutSubviews<br/>
2. addSubview会触发layoutSubviews<br/>
3. 设置view的Frame会触发layoutSubviews，当然前提是frame的值设置前后发生了变化<br/>
4. 滚动一个UIScrollView会触发layoutSubviews<br/>
5. 旋转Screen会触发父UIView上的layoutSubviews事件<br/>
6. 改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件</p>

<p>模型代码如下：</p>

<pre><code> /**
  *  CustomModel.h文件
  */
 #import &lt;Foundation/Foundation.h&gt;

 @interface CustomModel : NSObject
    /**
     *  名字
     */
 @property (nonatomic, copy) NSString *name;
    /**
     *  图片
     */
 @property (nonatomic, copy) NSString *icon;

 + (instancetype)modelWithName:(NSString *)name icon:(NSString *)icon;
 - (instancetype)initWithName:(NSString *)name icon:(NSString *)icon;

 @end
</code></pre>

<pre><code> /**
  *  CustomModel.m文件
  */
 #import &quot;CustomModel.h&quot;

 @implementation CustomModel
 + (instancetype)modelWithName:(NSString *)name icon:(NSString *)icon
 {
     return [[self alloc] initWithName:name icon:icon];
 }

 - (instancetype)initWithName:(NSString *)name icon:(NSString *)icon
 {
     if (self = [super init]) {
         self.name = name;
         self.icon = icon;
     }
     return self;
 }
 @end
</code></pre>

<p>如何使用？只需在控制器代码中执行4个步骤，简单方便：</p>

<pre><code>// 创建自定义的View
 CustomView *customView = [[CustomView alloc] init];
// 设置数据
 CustomModel *model = [CustomModel modelWithName:@&quot;hosea_zhou&quot; icon:@&quot;1&quot;];
 customView.model = model;
// 设置frame
 customView.frame = CGRectMake(100, 100, 67, 100);
// 添加子控件
 [self.view addSubview:customView];
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIButton]]></title>
    <link href="https://sparkbye.github.io/myBlog/14976187081535.html"/>
    <updated>2017-06-16T21:11:48+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/14976187081535.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">UIButton的状态</h3>

<ul>
<li><p>normal(普通状态)</p>

<ul>
<li>默认情况（DEFAULT）</li>
<li>对应的枚举常量： UIControlStateNormal</li>
</ul></li>
<li><p>highlighted (高亮状态)</p>

<ul>
<li>按钮被按下去的时候</li>
<li>对应的枚举常量： UIControlStateHighlighted</li>
</ul></li>
<li><p>disabled (失效状态)</p>

<ul>
<li>如果enabled属性为NO，就是出于disabled状态，代表按钮不可以被点击</li>
<li>对应的枚举变量： UIControlStateDisabled</li>
</ul></li>
</ul>

<h3 id="toc_1">UIButton代码应用</h3>

<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
    UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom];
    button.frame = CGRectMake(100, 300, 200, 100);
    button.backgroundColor = [UIColor redColor];
    [button setTitle:@&quot;Mytest&quot; forState:UIControlStateNormal];
    [button setTitleColor:[UIColor yellowColor] forState:UIControlStateNormal];
    [button setTitle:@&quot;HighLight&quot; forState:UIControlStateHighlighted];
    [button setTitleColor:[UIColor blueColor] forState:UIControlStateHighlighted];
    [button setImage:[UIImage imageNamed:@&quot;makefg&quot;] forState:UIControlStateNormal];

    [self.view addSubview:button];
    [button addTarget:self action:@selector(clickButton:) forControlEvents:UIControlEventTouchDown];
}

-(IBAction)clickButton:(UIButton *)button {
    button.enabled = NO;

}
</code></pre>

<h3 id="toc_2">九宫格布局</h3>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UILable]]></title>
    <link href="https://sparkbye.github.io/myBlog/14966683926548.html"/>
    <updated>2017-06-05T21:13:12+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/14966683926548.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">UILable常见属性</h3>

<p><code>@property(nonatomic, copy) NSString *text;</code><br/>
* 显示文字</p>

<p><code>@property(nonatomic, retain) UIFont *font;</code><br/>
* 显示字体</p>

<p><code>@property(nonatomic, retain) UIColor *textColor;</code><br/>
* 文字颜色</p>

<p><code>@property(nonatomic) NSTextAlignment textAlignment;</code><br/>
* 对齐模式(左对齐，居中对齐， 右对齐)</p>

<p><code>@property(nonatomic) NSInteger numberOfLines;</code><br/>
*文字行数</p>

<p><code>property(nonatomic) NSLineBreakMode lineBreakMode;</code><br/>
* 换行模式</p>

<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
    UILabel *lable = [[UILabel alloc] init];
    
    lable.frame = CGRectMake(50, 300, 300, 200);
    lable.backgroundColor = [UIColor redColor];
    lable.text = @&quot;你这头猪&quot;;
    lable.textAlignment = NSTextAlignmentCenter;
    lable.font = [UIFont systemFontOfSize:20.f];
    lable.font = [UIFont boldSystemFontOfSize:20.f];
    lable.textColor = [UIColor purpleColor];
    lable.shadowOffset = CGSizeMake(4, -10);
    lable.shadowColor = [UIColor blueColor];
    lable.lineBreakMode = NSLineBreakByClipping;
    [self.view addSubview:lable];   
}
</code></pre>

<h3 id="toc_1">UIImageView</h3>

<p><img src="media/14966683926548/14967586896546.jpg" alt=""/></p>

<h3 id="toc_2">毛玻璃效果</h3>

<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
    
    UIImageView *imageView = [[UIImageView alloc] init];
    imageView.backgroundColor = [UIColor redColor];
    imageView.frame = self.view.bounds;
    imageView.image = [UIImage imageNamed:@&quot;IMG_2585&quot;];
    imageView.contentMode = UIViewContentModeScaleAspectFill;
    
    UIToolbar *toolBar = [[UIToolbar alloc] init];
    toolBar.frame = imageView.bounds;
    toolBar.barStyle = UIBarStyleBlack;
    toolBar.alpha = 0.85;
    [imageView addSubview:toolBar];
    
    [self.view addSubview:imageView];
}
</code></pre>

<h3 id="toc_3">四种设置UIImage尺寸的方法</h3>

<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
    UIImageView *imageView = [[UIImageView alloc] init];
    //第一种方式
    imageView.frame = CGRectMake(100, 100, 200, 200);
    imageView.backgroundColor = [UIColor purpleColor];
    imageView.image = [UIImage imageNamed:@&quot;1&quot;];
    imageView.contentMode = UIViewContentModeScaleAspectFill;
    //第二种方式
    UIImage *image = [UIImage imageNamed:@&quot;1&quot;];
    imageView.frame = CGRectMake(0, 0, image.size.width, image.size.height);
    imageView.backgroundColor = [UIColor purpleColor];
    imageView.image = image;
    //第三种方式
    UIImageView *imageView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@&quot;1&quot;]];
    imageView.center = CGPointMake(100, 300);
    //第四种方式
    UIImageView *imageView = [[UIImageView alloc] initWithFrame:(CGRectMake(100, 100, 200, 200))];
    UIImage *image = [UIImage imageNamed:@&quot;1&quot;];
    imageView.image = image;
    
    [self.view addSubview:imageView];
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIView]]></title>
    <link href="https://sparkbye.github.io/myBlog/14965374170472.html"/>
    <updated>2017-06-04T08:50:17+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/14965374170472.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">UIView常见属性</h3>

<p><code>@property(nonatomic, readonly) UIView *superview;</code><br/>
* 获取自己的父控件对象</p>

<p><code>@property(nonatomic, readonly, copy) NSArray *subviews;</code><br/>
* 获取自己的子控件对象</p>

<p><code>@property(nonatomic) NSInteger tag;</code><br/>
* 控件的ID，父控件可以通过tag来找到对应的子控件</p>

<p><code>@property(nonatomic) CGAffineTransform transform;</code><br/>
* 控件的形变属性(可以设置旋转角度、比例缩放、平移等属性)</p>

<p><code>@property(nonatomic) CGRect frame;</code><br/>
* 控件矩形框在父控件中的位置和尺寸</p>

<p><code>@property(nonatomic) CGRect bounds;</code><br/>
* 控件矩形框的位置和尺寸</p>

<p><code>@property(nonatomic) CGPoint center;</code><br/>
* 控件重点的位置</p>

<pre><code>#import &quot;ViewController.h&quot;

@interface ViewController ()

@property(weak, nonatomic) UILabel *lable;

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
    
    UILabel *lable = [[UILabel alloc] init];
    lable.frame = CGRectMake(200, 100, 100, 60);
    lable.backgroundColor = [UIColor redColor];
    [self.view addSubview:lable];
    self.lable = lable;
}

- (IBAction)bounds {
    self.lable.bounds = CGRectMake(0, 0, 200, 40);
}

- (IBAction)center {
    self.lable.center = CGPointMake(self.view.frame.size.width * 0.5, self.view.frame.size.height * 0.5);
}
@end

</code></pre>

<h3 id="toc_1">常见的方法</h3>

<pre><code>-(void)loadView{
    [super loadView];
}

-(void)viewDidLoad{
    [super viewDidLoad];
} 

-(void)didReceiveMemoryWarning{
    [super didReceiveMemoryWarning];
}
</code></pre>

<h5 id="toc_2">viewDidLoad</h5>

<ul>
<li>系统调用</li>
<li>controller的View加载完毕的时候调用</li>
<li>控件的初始化，数据的初始化(懒加载)</li>
</ul>

<h5 id="toc_3">didReceiveMemoryWarning</h5>

<ul>
<li>系统调用</li>
<li>当控制器接受到内存警告调用</li>
<li>去除一些不必要的内存，去除耗时的内存</li>
</ul>

<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
//    NSLog(@&quot;%@&quot;, self.greenView.superview);
//    NSLog(@&quot;%@&quot;, self.greenView.subviews);
//    NSLog(@&quot;%@&quot;, self.view.subviews);
    UISwitch *sw = [[UISwitch alloc] init];
    [sw setHighlighted:true];
    [self.view addSubview:sw];
    [sw removeFromSuperview];
}
</code></pre>

<h5 id="toc_4">addSubview</h5>

<ul>
<li>添加一个子控件
##### removeFromSuperview</li>
<li>从父控件中移除
##### -(UIView *)viewwithTag:(NSInteger)tag;</li>
<li>根据一个tag找出对应的控件</li>
<li>不推荐使用tag

<ul>
<li>tag的效率差</li>
<li>tag容易乱</li>
</ul></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Block]]></title>
    <link href="https://sparkbye.github.io/myBlog/14950245211652.html"/>
    <updated>2017-05-17T20:35:21+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/14950245211652.html</id>
    <content type="html"><![CDATA[
<ul>
<li>Block是一个数据类型；</li>
</ul>

<hr/>

<p>既然block是一个数据类型，那么我们自然可以声明一个block类型的变量，那么block变量中存储的是什么呢？</p>

<hr/>

<blockquote>
<p>block类型的变量中存储的是代码段（可以有参数，可以有返回值）。</p>
</blockquote>

<h3 id="toc_0">如何声明一个block变量</h3>

<pre><code>void (^myBlock1)();
int (^myBlock2)();
int (^myBlock3)(int num1, int num2);
</code></pre>

<h3 id="toc_1">block变量的初始化</h3>

<pre><code>void (^myBlock1)() = ^void(){
        NSLog(@&quot;test&quot;);
    };

int (^myBlock2)() = ^int(){
    int num1 = 10 + 20;
    return num1;
};

int (^myblock3)(int num1, int num2) = ^int(int num1, int num2){
    int num3 = num1 + num2;
    return num3;
};
</code></pre>

<blockquote>
<p>赋值给block变量的代码段必须要符合block变量的要求。</p>
</blockquote>

<pre><code>#import &lt;Foundation/Foundation.h&gt;

int main(int argc, const char * argv[]) {
    
    void (^myBlock1)();
    myBlock1 = ^void(){
        NSLog(@&quot;test&quot;);
    };
    myBlock1();
    
    int (^myBlock2)() = ^int(){
        int num1 = 10 + 20;
        return num1;
    };
    int sum = myBlock2();
    NSLog(@&quot;sum = %d&quot;, sum);
    
    int (^myblock3)(int num1, int num2) = ^int(int num1, int num2){
        int num3 = num1 + num2;
        return num3;
    };
    
    int res = myblock3(10, 100);
    NSLog(@&quot;res = %d&quot;, res);
    
    
    return 0;
}
</code></pre>

<h3 id="toc_2">block的简写</h3>

<ol>
<li>如果代码段没有返回值，那么代码段的void可以省略：</li>
</ol>

<pre><code>//既没有参数也没有返回值的，void和（）都可以省略
void (^myBlock1)() = ^(){
        NSLog(@&quot;test&quot;);
    };
</code></pre>

<ol>
<li>如果代码段没有参数，代码段的（）也可以省略：</li>
</ol>

<pre><code>int (^myBlock2)() = ^int{
    int num1 = 10 + 20;
    return num1;
};
</code></pre>

<ol>
<li> 如果有指定参数，可以只写参数类型而不写参数名称：</li>
</ol>

<pre><code>int (^myblock3)(int, int) = ^int(int num1, int num2){
    int num3 = num1 + num2;
    return num3;
};
</code></pre>

<ol>
<li><p>无论代码段是否有返回值，在写代码段的时候可以不写返回值的类型：</p></li>
</ol>

<ul>
<li>如果代码段省略了返回值，系统会自动确定返回值的类型</li>
<li>如果代码段有返回值，return的数据是什么类型，系统就会认为代码段是什么类型；</li>
</ul>

<pre><code>int (^myBlock4)(int, int) = ^(int num1, int num2){
    int num3 = num1 + num2;
    return num3;
};
    
int result = myBlock4(20, 30);
NSLog(@&quot;result is %d&quot;, result);
</code></pre>

<h3 id="toc_3">简化block的定义</h3>

<ol>
<li>typedef: 将block定义为一个短类型。</li>
</ol>

<pre><code>typedef void (^NewType)();
NewType block1 = ^void(){
    NSLog(@&quot;Hello&quot;);
};
block1();
</code></pre>

<ul>
<li>block内部可以取外部的局部变量和全局变量的值</li>
<li>block内部可以修改全部变量的值，但是无法修改外部局部变量的值</li>
<li>如果需要修改，则局部变量定义方式为__block int num = 100;</li>
</ul>

<h3 id="toc_4">block作为函数的参数</h3>

<ol>
<li>可以在函数中声明一个指定格式的block：</li>
</ol>

<pre><code>void test(void (^block1)()){
    NSLog(@&quot;~~~~~~~~&quot;);
    block1();
    NSLog(@&quot;~~~~~~~~&quot;);
}
</code></pre>

<ol>
<li>使用typedef简化定义：</li>
</ol>

<pre><code>typedef void (^NewBlock) ();

void test_2(NewBlock block2){
    NSLog(@&quot;~~~~~~~~&quot;);
    block2();
    NSLog(@&quot;~~~~~~~~&quot;);
}
</code></pre>

<ol>
<li>如何调用：</li>
</ol>

<pre><code>#import &lt;Foundation/Foundation.h&gt;

typedef void (^NewBlock) ();

void test(void (^block1)()){
    NSLog(@&quot;~~~~~~~~&quot;);
    block1();
    NSLog(@&quot;~~~~~~~~&quot;);
}

void test_2(NewBlock block2){
    NSLog(@&quot;~~~~~~~~&quot;);
    block2();
    NSLog(@&quot;~~~~~~~~&quot;);
}

int main(int argc, const char * argv[]) {

    NewBlock type = ^{
        NSLog(@&quot;hahahah&quot;);
    };
    
    test_2(type);
    
    test_2(^{
        NSLog(@&quot;hahahah&quot;);
    });
    
    return 0;
}
</code></pre>

<p>在这个状态下直接敲回车：<br/>
<img src="media/14950245211652/14955458877653.jpg" alt=""/><br/>
可以转换成：<br/>
<img src="media/14950245211652/14955459281745.jpg" alt=""/><br/>
然后直接补充代码即可：<br/>
<img src="media/14950245211652/14955459527916.jpg" alt=""/></p>

<blockquote>
<p>将block作为函数的参数可以实现什么效果？</p>
</blockquote>

<pre><code>⁃ 可以将调用者所写的代码放到函数的内部去执行；
</code></pre>

]]></content>
  </entry>
  
</feed>
