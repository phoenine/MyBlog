<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Ascetic in the deadlock]]></title>
  <link href="https://sparkbye.github.io/myBlog/atom.xml" rel="self"/>
  <link href="https://sparkbye.github.io/myBlog/"/>
  <updated>2020-06-23T22:03:19+08:00</updated>
  <id>https://sparkbye.github.io/myBlog/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[**高性能 Pandas 方法：query 和 eval**]]></title>
    <link href="https://sparkbye.github.io/myBlog/15929209495893.html"/>
    <updated>2020-06-23T22:02:29+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15929209495893.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">为什么不喜欢写方括号</h2>

<p>对于一个最开始从 R 语言的 Tidyverse 生态中转到 Pandas 中的人来说，除了管道操作符和链式调用的方式外，最不习惯的方式就是 Pandas 在对 DataFrame 做条件筛选或查询时，使用过多的方括号。</p>

<p>先看看在 R 语言的 Tidyverse 生态中筛选操作是怎样的（主要基于 <code>dplyr</code> 包），这里以 iris 数据集为例。</p>

<pre><code>library(tidyverse)

# normal way
iris[which(iris$Sepal.Length &gt; 5 &amp; iris$Petal.Length &lt;= 1.5), ]

# Tidyverse way
iris %&gt;% filter(
    Sepal.Length &gt; 5 &amp; 
    Petal.Length &lt;= 1.5
)
</code></pre>

<p>虽然在 R 语言也可以用方括号加 <code>which</code> 的方式来进行行索引定位，但是相比于 <code>filter</code> 来说反而略显啰嗦。因此 <code>filter</code> 的方式反而更容易被记住且频繁使用。</p>

<p>在 Pandas 中，大部分人往往在初学时最先接触到的就是通过方括号的形式来进行筛选查询，像是这样：</p>

<pre><code># !pip install seaborn
import pandas as pd
import seaborn as sns

# Load iris dataset
iris = sns.load_dataset(&#39;iris&#39;)

# 等价于 iris[(iris.sepal_length &gt; 5) &amp; (iris.petal_length &lt;= 1.5)]
iris[(iris[&#39;sepal_length&#39;] &gt; 5) &amp; (iris[&#39;petal_length&#39;] &lt;= 1.5)]
</code></pre>

<p>尽管可以直接通过 <code>iris.column</code> 的形式来调用相应的字段，但是这很容易和方法混在一起，因此在实际项目中往往我更偏好用方括号和引号来表示字段，以增强可读性并同方法相区分。</p>

<p>可我们也很容易看到 Pandas 的筛选写法其实相当冗长，同时这样的形式即便是熟练使用 Pandas 的「老鸟」也会经常这么写，甚至在各种课程中也屡见不鲜。</p>

<p>但其实对于每个使用 Pandas 库的人来说，让代码更简洁才符合 <strong>Pythonic</strong> 的风格。这就是为什么本文所要谈论 <code>query</code> 和 <code>eval</code> 这两个方法的原因。</p>

<h2 id="toc_1">query 和 eval</h2>

<p><code>query</code> 和 <code>eval</code> 方法在 2014年 1 月 3 日的 0.13.0 版本中首次加入，它们允许使用者以传入字符串表达式（Expression）的形式来对 DataFrame 进行操作。</p>

<h3 id="toc_2">用法一：条件筛选与查询</h3>

<p>前面分所述的写法其实可以变成这样：</p>

<pre><code># query
iris.query(&quot;sepal_length &gt; 5 &amp; petal_length &lt;= 1.5&quot;)

# eval
cond = iris.eval(&quot;sepal_length &gt; 5 &amp; petal_length &lt;= 1.5&quot;)
iris[cond]
</code></pre>

<p>相比于传统的括号写法，<code>query</code> 和<code>eval</code> 方法能有效减少在筛选查询时符号冗余的情况，尤其是 <code>query</code> 方法能够紧密地同链式调用相结合从而达到了 R 语言 Tidyverse 中的 <code>filter</code> 用法，类似于这样：</p>

<pre><code>(iris
    .query(&quot;sepal_length &gt; 5 &amp; petal_length &lt;= 1.5&quot;)
    .assign(sepal_len_cut = lambda df: df[&#39;sepal_length&#39;]
                .pipe(pd.cut, bins=3), 
            petal_len_cut = lambda df: df[&#39;petal_length&#39;]
                .pipe(pd.cut, bins=3))
    .groupby([&#39;sepal_len_cut&#39;, &#39;petal_len_cut&#39;])
    .sum()
    .dropna()
)
</code></pre>

<p>当筛选的条件为多条件时，除了使用六个引号的长字符串之外，还<strong>需要注意</strong>的就是手动加上<code>\</code> 进行断行，就像这样：</p>

<pre><code>iris.query(
    &quot;&quot;&quot;
    sepal_length &gt; 5 &amp; \
    petal_length &lt;= 1.5
    &quot;&quot;&quot;
)
</code></pre>

<p>否则会导致报错，因为这段查询表达式的字符串中<strong>多出了不恰当的换行符</strong>，从而导致表达式不能够被正确解析。</p>

<p>同时需要注意的是，如果你的数据字段命存在一些空格或者下划线之类的特殊符号，那么可能也会同样导致报错。在 R 语言中你可以通过加上反引号「``」（键盘上 Esc 键下面的那个符号）来避免，就像这样：</p>

<pre><code>library(tidyverse)

df &lt;- data.frame(
  A = seq(0,10,2),
  B = seq(1,11,2)
) 

df %&gt;% 
  rename(`B B` = &quot;B&quot;) %&gt;% 
  filter(`B B` &gt; 5)
</code></pre>

<p>当然，在 Python 中你也可以同样如此，Pandas 对此也已经进行了支持：</p>

<pre><code>df = pd.DataFrame(np.arange(12).reshape(6,2), columns=[&quot;A&quot;, &quot;B B&quot;])

df.query(&quot;B B == 3&quot;) # error
df.query(&quot;`B B` == 3&quot;) # right
</code></pre>

<h3 id="toc_3">用法二：结合 DataFrame 之外的其他对象进行操作</h3>

<p><code>query</code> 和<code>eval</code> 方法还能有效将数据同非 DataFrame 之外的变量进行结合并操作，只需要在表达式字符串中加入<code>@</code>符号，就像这样：</p>

<pre><code>sepal_len, petal_len = 5, 1.5
iris.query(
    &quot;&quot;&quot;
    sepal_length &gt; @sepal_len &amp; \
    petal_length &lt;= @petal_len
    &quot;&quot;&quot;
)
</code></pre>

<p>当条件过长时，对条件进行适当分解之后通过这样的用法，也能提高代码的可读性以及简洁程度。</p>

<p>除此之外，你也可以用来创建新字段、对字段作运算等（限于 <code>eval</code>），以下例子源自于 Pandas 官方文档，详细的示例可以参考Pandas 官方的这部分内容。</p>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/5mt0ewv9OS36LnibQdlw6GL75pcjQRKsSghaTv14YnII1IFibuscYbgjRpFgkkCGTroIkBJdbWeowINPqaiaVpyTg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"/></p>

<p>eval官方例子</p>

<p>你甚至也可以直接在表达式字符串中写入代码语句，但是我<strong>不太建议你这么操作</strong>，即便是可行的。因为一旦表达式在执行时出现错误，Debug 时很有可能无法定位到当中代码语句的错误。</p>

<pre><code>other = iris.copy()

iris.query(
    &quot;&quot;&quot;
    species in @other.query(&quot;species==&#39;setosa&#39;&quot;)[&#39;species&#39;]
    &quot;&quot;&quot;
)
</code></pre>

<h1 id="toc_4">尾巴</h1>

<p><code>query</code> 和 <code>eval</code> 方法应该是每个适用 Pandas 应该掌握的一种技巧，当进行多条件索引筛选或查询时，裹脚布般的方括号及当中的条件括号简直就是噩梦般的存在。</p>

<p>这两个方法都是基于 <code>numexpr</code> 这一个库实现，该库由 C/C++ 编写，在性能上就不用多说；同时，在官方文档中也可以看到，处理大数据集时使用 <code>query</code> 或 <code>eval</code> 方法是多么高效：</p>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/5mt0ewv9OS36LnibQdlw6GL75pcjQRKsSKyE66UfaZZNR5GS8IIBQhuicDH9HMaarPYb9XqoKfg7z45b7StVfBJg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"/></p>

<p>numexpr性能表现</p>

<p>尽管官方文档中有说明，当数据中的记录小于 10000 行时，性能表现上 <code>numexpr</code> 略逊于 Python 原生的解析器；但是从图可以看到，在小数据集中使用二者的差别连一秒钟都不到，因此也不必有所顾虑。</p>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/5mt0ewv9OS36LnibQdlw6GL75pcjQRKsS2jQlTRibTkuTxKYMkwk4ShFcVhIQaa671aWcl0fTiaENKLKyFibFecicCw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"/></p>

<p>原生解析器表现</p>

<p>虽然 <code>query</code> 和 <code>eval</code> 默认使用 <code>numexpr</code> 作为解析引擎，但在源码中可以发现，在你使用这两个方法时，都会预先检查你是否安装了 <code>numexpr</code> 库，如果不存在则会调用 Python 原生的解析器，这一点在文档中也有所说明。</p>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/5mt0ewv9OS36LnibQdlw6GL75pcjQRKsSNiaOP14zq7JjfF22aaWnNKfeTvs7gOUCBx4TKiak7vuYhQGNf75thiaHw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"/></p>

<p>引擎检查源码</p>

<p>如果不需要中间变量、步骤不需要分解且保证最后返回的就是 DataFrame 类型，那么就愉快地使用链式调用方法来完成你的数据流程吧！</p>

<blockquote>
<p>转载自微信，仅供个人学习使用</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[超详解 matplotlib 中的折线图方法 plot()]]></title>
    <link href="https://sparkbye.github.io/myBlog/15929209361947.html"/>
    <updated>2020-06-23T22:02:16+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15929209361947.html</id>
    <content type="html"><![CDATA[
<pre><code class="language-python">import pandas as pd 
import numpy as np
import matplotlib.pyplot as plt
import matplotlib 
</code></pre>

<h1 id="toc_0">目的</h1>

<ul>
<li>对最基本的折线图plot做详细的解读，为绘制其他类型的图形打好基础。</li>
</ul>

<h1 id="toc_1">plt.plot()的定义及调用</h1>

<p>定义：</p>

<ul>
<li>plt.plot(*args, scalex=True, scaley=True, data=None, **kwargs)</li>
</ul>

<p>调用：</p>

<ul>
<li>plot([x], y, [fmt], *, data=None, **kwargs)</li>
<li>plot([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)</li>
</ul>

<p>位置参数：</p>

<ul>
<li class="task-list-item"><input disabled="disabled" type="checkbox" checked />, y, [fmt]
</li>
</ul>

<p>关键字传参：</p>

<ul>
<li>*后面的参数</li>
</ul>

<h1 id="toc_2">x序列的不同类型</h1>

<h2 id="toc_3">文本型的x序列</h2>

<pre><code class="language-python"># data
X = [8,3,5,&#39;t&#39;] # 会按顺序【0,1,2,3】被定位在x轴的刻度上
Y = [1,2,3,4]


plt.plot(X,Y,marker = &#39;o&#39;,c=&#39;g&#39;)

ax = plt.gca()
print(&#39;x轴刻度：&#39;,plt.xticks())  #list
xticklabels_lst = ax.get_xticklabels()
print(&#39;-&#39;*70)
x轴刻度：([0, 1, 2, 3], &lt;a list of 4 Text xticklabel objects&gt;)
----------------------------------------------------------------------
</code></pre>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/5mt0ewv9OS3ovSxAycsQ0mSDsAv7ST390MkazC65gic6xXs71nTgFic392z2PGvEqRYyRP6RWDKpwYowicxoicm1WQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"/></p>

<pre><code class="language-python">print(&#39;x轴刻度标签：&#39;,list(xticklabels_lst))  #是个文本标签
x轴刻度标签：[Text(0, 0, &#39;8&#39;), Text(1, 0, &#39;3&#39;), Text(2, 0, &#39;5&#39;), Text(3, 0, &#39;t&#39;)]
</code></pre>

<h2 id="toc_4">数字型的x序列</h2>

<pre><code class="language-python"># data
X = [8,3,5,1] # 会按数字【8，3,5,1】被定位在x轴的刻度上

Y = [1,2,3,4]

plt.plot(X,Y,marker = &#39;o&#39;,c=&#39;g&#39;)

ax = plt.gca()

print(&#39;x轴刻度：&#39;,plt.xticks()) # array
xticklabels_lst = ax.get_xticklabels()
print(&#39;-&#39;*70)
x轴刻度：(array([0., 1., 2., 3., 4., 5., 6., 7., 8., 9.]), &lt;a list of 10 Text xticklabel objects&gt;)
----------------------------------------------------------------------
</code></pre>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/5mt0ewv9OS3ovSxAycsQ0mSDsAv7ST39OKgxoQ3cmeYtXvz9Bh9qia1rBAgWnowab9IWHnRNCBDPXKia0icQuBPLA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"/></p>

<pre><code class="language-python">print(&#39;x轴刻度标签：&#39;,list(xticklabels_lst))  #是个按序号排列的文本标签
x轴刻度标签：[Text(0.0, 0, &#39;0&#39;), Text(1.0, 0, &#39;1&#39;), Text(2.0, 0, &#39;2&#39;), Text(3.0, 0, &#39;3&#39;), Text(4.0, 0, &#39;4&#39;), Text(5.0, 0, &#39;5&#39;), Text(6.0, 0, &#39;6&#39;), Text(7.0, 0, &#39;7&#39;), Text(8.0, 0, &#39;8&#39;), Text(9.0, 0, &#39;9&#39;)]
</code></pre>

<h2 id="toc_5">2种类型-2条线</h2>

<pre><code class="language-python"># data
X1 = [8,3,5,&#39;t&#39;]
X2 = [8,3,5,1]
Y = [1,2,3,4]

plt.plot(X2,Y,marker = &#39;o&#39;,c=&#39;r&#39;)
plt.plot(X1,Y,marker = &#39;o&#39;,c=&#39;g&#39;)

ax = plt.gca()

print(&#39;x轴刻度：&#39;,plt.xticks())
xticklabels_lst = ax.get_xticklabels()
print(&#39;-&#39;*70)
x轴刻度：([0, 1, 2, 3], &lt;a list of 4 Text xticklabel objects&gt;)
----------------------------------------------------------------------
</code></pre>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/5mt0ewv9OS3ovSxAycsQ0mSDsAv7ST39A8sPBEXTRvWeaDtSEFCX2F44brXCQkdRWYvq7D2fz1owcbRg5CZrLA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"/></p>

<pre><code class="language-python">print(&#39;x轴刻度标签：&#39;,list(xticklabels_lst)) 
x轴刻度标签：[Text(0, 0, &#39;8&#39;), Text(1, 0, &#39;3&#39;), Text(2, 0, &#39;5&#39;), Text(3, 0, &#39;t&#39;)]
</code></pre>

<h1 id="toc_6">提供不同数量的位置参数</h1>

<p>几种方式的调用</p>

<h2 id="toc_7">无参数</h2>

<pre><code class="language-python">#返回一个空列表
plt.plot()
[]
</code></pre>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/5mt0ewv9OS3ovSxAycsQ0mSDsAv7ST39yDIvkHokd5EXMXzl0lJFoH1mD6CIjjFv23b2vgSkYl3CE28ic4A00rw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"/></p>

<p>plot([x], y, [fmt], *, data=None, **kwargs) plot([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)</p>

<h2 id="toc_8">1个参数</h2>

<pre><code class="language-python">#提供一个数（点）
plt.plot(4.5,marker=&#39;o&#39;)
[&lt;matplotlib.lines.Line2D at 0x7f6f0352f978&gt;]
</code></pre>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/5mt0ewv9OS3ovSxAycsQ0mSDsAv7ST390MFB3c55Dd4fctH67xEdZAjBAccicZR9xibGX9KpwgPurCWvhgTriaJ2A/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"/></p>

<pre><code class="language-python">#提供一个数字序列
plt.plot([4.5,2,3],marker=&#39;o&#39;)
[&lt;matplotlib.lines.Line2D at 0x7f6f0350d438&gt;]
</code></pre>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/5mt0ewv9OS3ovSxAycsQ0mSDsAv7ST39QRWpOpOvC9h6pqVAMUkNtDiadpgPBIfBz6MenvTCib4lbPDQkKRWcGPA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"/></p>

<h2 id="toc_9">2个参数</h2>

<p>自动解析位置参数的原则</p>

<h3 id="toc_10">(x,y）形式</h3>

<pre><code class="language-python"># x/y 为序列
plt.plot([2,1,3],[0.5,2,2.5],marker=&#39;o&#39;)
[&lt;matplotlib.lines.Line2D at 0x7f6f034735c0&gt;]
</code></pre>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/5mt0ewv9OS3ovSxAycsQ0mSDsAv7ST397PIE0wXefnff0seMFesYiavgIC3k9xUAkSUkIqlUVhaTXP608fiafrZg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"/></p>

<pre><code class="language-python"># x/y 为标量
plt.plot(2,[&#39;z&#39;],marker = &#39;o&#39;) 
[&lt;matplotlib.lines.Line2D at 0x7f6f03461b38&gt;]
</code></pre>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/5mt0ewv9OS3ovSxAycsQ0mSDsAv7ST39CZ8MdAibecAibWlkD3L6wSJzKwumMsyRWvAaRq17GOicCR9HVP2huQutw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"/></p>

<h3 id="toc_11">(y,fmt)形式</h3>

<pre><code class="language-python"># plt.plot(2,&#39;z&#39;,marker = &#39;o&#39;) #Unrecognized character z in format string
# y 为标量 
plt.plot(2,&#39;r&#39;,marker = &#39;o&#39;) 
[&lt;matplotlib.lines.Line2D at 0x7f6f033b7cf8&gt;]
</code></pre>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/5mt0ewv9OS3ovSxAycsQ0mSDsAv7ST3938jXcMiarekvStV0e2aI3K1RjGibvo5iaP964zY7fA0dmibH94q66UB0Zw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"/></p>

<pre><code class="language-python"># y 为序列
plt.plot([2,1,3],&#39;r--*&#39;) 
[&lt;matplotlib.lines.Line2D at 0x7f6f033a1cf8&gt;]
</code></pre>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/5mt0ewv9OS3ovSxAycsQ0mSDsAv7ST39QiboMicydP9kTiaiajMK6UEqqTQnfNHyp3NySbvMsRp1UfD76WgAklnsoA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"/></p>

<h2 id="toc_12">3个参数</h2>

<h3 id="toc_13">（[x],y,[fmt]）形式</h3>

<pre><code class="language-python">plt.plot([2,1,3],[0.5,2,2.5],&#39;p--g&#39;, 
#          marker=&#39;o&#39;
         markersize = 15
        )
[&lt;matplotlib.lines.Line2D at 0x7f6f0331e048&gt;]
</code></pre>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/5mt0ewv9OS3ovSxAycsQ0mSDsAv7ST39U9qQviar0ovic5XJdITv7UuBDNGC7g9l7TV0PeaJfJeQpdT5LWYWPUQQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"/></p>

<pre><code class="language-python"># fmt不写，或者‘’，则使用默认样式
plt.plot([2,1,3],[0.5,2,2.5],&#39;&#39;,
#          marker=&#39;o&#39;
         markersize = 15
        )
[&lt;matplotlib.lines.Line2D at 0x7f6f03289390&gt;]
</code></pre>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/5mt0ewv9OS3ovSxAycsQ0mSDsAv7ST39yKjNZACg9R33F1DvfW9AARQERJyCNQxuPWExRdrfjhS5tNIksMlh4A/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"/></p>

<h1 id="toc_14">绘图Line2D</h1>

<h2 id="toc_15">仅画线：绘图的默认情况</h2>

<p>默认样式：蓝色的【线】【无标记】</p>

<pre><code class="language-python"># marker = None 表示不做设置
plt.plot([2,2.5,1])
[&lt;matplotlib.lines.Line2D at 0x7f6f031f86a0&gt;]
</code></pre>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/5mt0ewv9OS3ovSxAycsQ0mSDsAv7ST39fG59O2RMPT6hQiaNhDYFw7ficIrT7JobbBbcQrdAFpFSqljdNxemicnWw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"/></p>

<h2 id="toc_16">仅画标记</h2>

<pre><code class="language-python">plt.plot([2,2.5,1],&#39;o&#39;)
[&lt;matplotlib.lines.Line2D at 0x7f6f03afcba8&gt;]
</code></pre>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/5mt0ewv9OS3ovSxAycsQ0mSDsAv7ST39cZMibaLWr6wotXqib2UoGnPO2MBCmm3qOr6MDO7XibUyE06ibZDMFWx3zw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"/></p>

<h2 id="toc_17">画线+标记</h2>

<pre><code class="language-python">plt.plot([2,2.5,1],&#39;o-&#39;)
[&lt;matplotlib.lines.Line2D at 0x7f6f031d62e8&gt;]
</code></pre>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/5mt0ewv9OS3ovSxAycsQ0mSDsAv7ST39I4BQ2ZiawZjxsJlpkiadlktj9zJxQCwdJbKHNHic2Fu4gehN8YAr6vD0Q/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"/></p>

<pre><code class="language-python">plt.plot([2,1,3],&#39;bo--&#39;)
[&lt;matplotlib.lines.Line2D at 0x7f6f0317b128&gt;]
</code></pre>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/5mt0ewv9OS3ovSxAycsQ0mSDsAv7ST39Rj7EuEPqtXJbKE81a9tL3ec0sQaum1XN8VYI2CTGNgXWkbzz3rNo8w/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"/></p>

<h1 id="toc_18">fmt的组合顺序随意的？</h1>

<h2 id="toc_19">6图合一及结论</h2>

<pre><code class="language-python"># 6种组合
# [color][marker][line],3种任意组合为6种可能

# b :蓝色
# o: 圆圈标记
# --：虚线

fmt = [&#39;bo--&#39;,&#39;b--o&#39;,&#39;ob--&#39;,&#39;o--b&#39;,&#39;--bo&#39;,&#39;--ob&#39;]
for i in range(len(fmt)):
    plt.subplot(2,3,i+1)
    plt.plot([2,1,3],fmt[i])
    
# 结论：[color][marker][line]，每个都是可选的，每个属性可以选择写或者不写
# 而且与组合中它们所在的位置顺序无关
</code></pre>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/5mt0ewv9OS3ovSxAycsQ0mSDsAv7ST39WhhJjtR4ibibs2l3ggYbcLeqUovOYdV0J4xBpiaogusYV3mWAr9SRWuFQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"/></p>

<h2 id="toc_20">fmt支持的【线】-line</h2>

<p><strong>Line Styles</strong></p>

<p>==== character description ====</p>

<p><code>&#39;-&#39;</code> solid line style <code>&#39;--&#39;</code> dashed line style <code>&#39;-.&#39;</code> dash-dot line style <code>&#39;:&#39;</code> dotted line style </p>

<h2 id="toc_21">fmt支持的【标记】-marker</h2>

<p><strong>Markers</strong></p>

<p>==== character description ====</p>

<p><code>&#39;.&#39;</code> point marker <code>&#39;,&#39;</code> pixel marker <code>&#39;o&#39;</code> circle marker <code>&#39;v&#39;</code> triangle_down marker <code>&#39;^&#39;</code> triangle_up marker <code>&#39;&lt;&#39;</code> triangle_left marker <code>&#39;&gt;&#39;</code> triangle_right marker <code>&#39;1&#39;</code> tri_down marker <code>&#39;2&#39;</code> tri_up marker <code>&#39;3&#39;</code> tri_left marker <code>&#39;4&#39;</code> tri_right marker <code>&#39;s&#39;</code> square marker <code>&#39;p&#39;</code> pentagon marker <code>&#39;*&#39;</code> star marker <code>&#39;h&#39;</code> hexagon1 marker <code>&#39;H&#39;</code> hexagon2 marker <code>&#39;+&#39;</code> plus marker <code>&#39;x&#39;</code> x marker <code>&#39;D&#39;</code> diamond marker <code>&#39;d&#39;</code> thin_diamond marker <code>&#39;|&#39;</code> vline marker <code>&#39;_&#39;</code> hline marker</p>

<h2 id="toc_22">fmt支持的【颜色】-color</h2>

<p><strong>Colors</strong></p>

<p>The supported color abbreviations are the single letter codes</p>

<p>==== character color ====</p>

<p><code>&#39;b&#39;</code> blue <code>&#39;g&#39;</code> green <code>&#39;r&#39;</code> red <code>&#39;c&#39;</code> cyan <code>&#39;m&#39;</code> magenta <code>&#39;y&#39;</code> yellow <code>&#39;k&#39;</code> black <code>&#39;w&#39;</code> white </p>

<h2 id="toc_23">所有样式：标记、线、颜色参考大全</h2>

<p>链接：<strong><a href="https://www.kesci.com/home/project/5ea4e5da105d91002d506ac6">https://www.kesci.com/home/project/5ea4e5da105d91002d506ac6</a></strong></p>

<pre><code>
</code></pre>

<h1 id="toc_24">样式属性</h1>

<h2 id="toc_25">线条的属性</h2>

<pre><code class="language-python"># 包含：(颜色除外）
# 线的样式、线的宽度
# linestyle or ls: {&#39;-&#39;, &#39;--&#39;, &#39;-.&#39;, &#39;:&#39;, &#39;&#39;, }
# linewidth or lw: float

ls_lst = [&#39;-&#39;, &#39;--&#39;, &#39;-.&#39;, &#39;:&#39;,] 
lw_lst = [1,3,5,7]
for i in range(len(ls_lst)):
    plt.plot([1,2,3,4],[i+1]*4,ls_lst[i],lw = lw_lst[i])
</code></pre>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/5mt0ewv9OS3ovSxAycsQ0mSDsAv7ST39c0a9u0s52BHVc7JsJkAWtBdB7ibCRy7ZPUIuulVU3jT0yNxicoIz5fMA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"/></p>

<h2 id="toc_26">标记的属性</h2>

<pre><code class="language-python"># 包含：
&#39;&#39;&#39;
marker: marker style
#边框（颜色及边框粗细）
markeredgecolor or mec: color
markeredgewidth or mew: float
#面颜色
markerfacecolor or mfc: color
markerfacecoloralt or mfcalt: color  #备用标记颜色
#标记的大小
markersize or ms: float
markevery: None or int or (int, int) or slice or List[int] or float or (float, float)
&#39;&#39;&#39;

# linestyle = None 表示不做设置，以默认值方式
# linestyle = &#39;&#39;  linestyle = &#39;none&#39; 表示无格式，无线条

plt.plot([4,2,1,3],linestyle = &#39;none&#39;, 
         marker = &#39;o&#39;,
         markersize = 30,
         # edge
         markeredgecolor = &#39;r&#39;,
         markeredgewidth = 5,
         # face 
         markerfacecolor = &#39;g&#39;,
#          markerfacecolor = &#39;none&#39;,
#          markerfacecolor = None,
        )
[&lt;matplotlib.lines.Line2D at 0x7f6f02f085c0&gt;]
</code></pre>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/5mt0ewv9OS3ovSxAycsQ0mSDsAv7ST39IO2mK8Wc6op7qb66crQZnTNFhvKICicMBQZOhPAoDeYFsRxDPZ1b77Q/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"/></p>

<h1 id="toc_27">综合：带有空心圆标记的线条图</h1>

<pre><code class="language-python">&#39;&#39;&#39;
标记点是覆盖在线条的上面，位于上层

图层层次：[top]  spines &gt; marker &gt; line &gt; backgroud  [bottom]
spines：轴的4个边框
spines 将线条图围在里面
&#39;&#39;&#39;

plt.plot([1,5,3,4], 
         marker = &#39;o&#39;,
         markersize = 20,
         # edge
         markeredgecolor = &#39;r&#39;,
         markeredgewidth = 5,
         # face 
         markerfacecolor = &#39;w&#39;,    # 白色，与背景色相同，把线条覆盖着，营造空心的视觉效果
#          markerfacecolor = &#39;none&#39;, # 无色，透明，会看到线条
#          markerfacecolor = None, # 不设置，默认颜色
        )

# markerfacecolor = &#39; &#39;, # 无法识别
# markerfacecolor = &#39;&#39;, # 无法识别
[&lt;matplotlib.lines.Line2D at 0x7f6f02e6e470&gt;]
</code></pre>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/5mt0ewv9OS3ovSxAycsQ0mSDsAv7ST39RUIgr2Mu3lWzya5OMyP8nBWDINmXrBBw2accly5s8e5smh6xNumicng/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"/></p>

<h1 id="toc_28">data关键字的使用</h1>

<h2 id="toc_29">字典数据</h2>

<pre><code class="language-python">#字典数据
d = {&#39;name&#39;:list(&#39;abcd&#39;),&#39;age&#39;:[22,20,18,27]}
plt.plot(&#39;name&#39;,&#39;age&#39;,data = d)
[&lt;matplotlib.lines.Line2D at 0x7f6f02e52e48&gt;]
</code></pre>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/5mt0ewv9OS3ovSxAycsQ0mSDsAv7ST39RdZ6iaHpKRvD3iblvyZe6dzeuhiaxXiaUemmGUj0qfn24xo2Mg2PHGyZpA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"/></p>

<h2 id="toc_30">DataFrame数据</h2>

<pre><code class="language-python">#DataFrame数据
d = {&#39;name&#39;:list(&#39;abcd&#39;),&#39;age&#39;:[22,20,18,27]}
df = pd.DataFrame(d)
df
</code></pre>

<table>
<thead>
<tr>
<th style="text-align: left"></th>
<th style="text-align: left">name</th>
<th style="text-align: left">age</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">0</td>
<td style="text-align: left">a</td>
<td style="text-align: left">22</td>
</tr>
<tr>
<td style="text-align: left">1</td>
<td style="text-align: left">b</td>
<td style="text-align: left">20</td>
</tr>
<tr>
<td style="text-align: left">2</td>
<td style="text-align: left">c</td>
<td style="text-align: left">18</td>
</tr>
<tr>
<td style="text-align: left">3</td>
<td style="text-align: left">d</td>
<td style="text-align: left">27</td>
</tr>
</tbody>
</table>

<pre><code>plt.plot(&#39;name&#39;,&#39;age&#39;,data = df)
[&lt;matplotlib.lines.Line2D at 0x7f6f02d7a940&gt;]
</code></pre>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/5mt0ewv9OS3ovSxAycsQ0mSDsAv7ST39RdZ6iaHpKRvD3iblvyZe6dzeuhiaxXiaUemmGUj0qfn24xo2Mg2PHGyZpA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"/></p>

<h1 id="toc_31">总结</h1>

<p>定义：</p>

<ul>
<li>plt.plot(<em>args,scalex = True,scaley = True,data = None ,</em>*kwargs)</li>
</ul>

<p>调用：</p>

<ul>
<li>plot([x], y, [fmt], *, data=None, **kwargs)</li>
<li>plot([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)</li>
</ul>

<p>x,y,fmt均不能使用关键字传参</p>

<p>推荐使用：</p>

<ul>
<li>plt.plot(x,y,fmt)</li>
<li>多组数据时，再次调用</li>
<li>plt.plot(x2,y2,fmt2) 画第2条线即可...</li>
<li>默认样式：蓝色的【线】+【无标记】，即无标记的线</li>
<li>可使用fmt来快捷控制线条的基本属性：颜色、线、标记</li>
<li>[color][marker][line]</li>
<li>fmt与关键字属性可混合使用，当两者有冲突时，以关键字的为准。</li>
<li>对于已有的带标签的数据如df，可使用</li>
<li>plt.plot(&#39;columns_name1&#39;,&#39;columns_name2&#39;,data = df)</li>
</ul>

<blockquote>
<p>转载自微信，仅供个人学习使用</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python数据形态及IO操作]]></title>
    <link href="https://sparkbye.github.io/myBlog/15929209176741.html"/>
    <updated>2020-06-23T22:01:57+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15929209176741.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">1.数据型态</h2>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/aSJyGw23SZD4C1QiceHyVNSicwKEUvlgkN0CekufXU3LkIdEkDb0UUKKhXO9gkCo10kicveu17cyRWhRjmhFqtaSw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"/></p>

<ul>
<li><strong>定性数据（Qualitative or Categorical Data）：是一组表示事物性质、规定事物类别的文字表述型数据，不能将其量化，只能将其定性。</strong></li>
<li>叙述特性或种类</li>
<li><strong>定量数据（Quantitative or Numerical Data）：可以被计数或测量。</strong></li>
</ul>

<blockquote>
<ul>
<li>定性分析与定量分析应该是统一的，相互补充的；定性分析是定量分析的基本前提，没有定性的定量是一种盲目的、毫无价值的定量；定量分析使定性分析更加科学、准确，它可以促使定性分析得出广泛而深入的结论。</li>
<li>定量分析是依据统计数据，建立数学模型，并用数学模型计算出分析对象的各项指标及其数值的一种方法。定性分析则是主要凭分析者的直觉、经验，凭分析对象过去和现在的延续状况及最新的信息资料，对分析对象的性质、特点、发展变化规律作出判断的一种方法。</li>
<li>相比而言，前一种方法更加科学，但需要较高深的数学知识，而后一种方法虽然较为粗糙，但在数据资料不够充分或分析者数学基础较为薄弱时比较适用，更适合于一般的投资者与经济工作者。但是必须指出，两种分析方法对数学知识的要求虽然有高有低，但并不能就此把定性分析与定量分析截然划分开来。事实上，现代定性分析方法同样要采用数学工具进行计算，而定量分析则必须建立在定性预测基础上，二者相辅相成，定性是定量的依据，定量是定性的具体化，二者结合起来灵活运用才能取得最佳效果。</li>
<li>不同的分析方法各有其不同的特点与性能，但是都具有一个共同之处，即它们一般都是通过比较对照来分析问题和说明问题的。正是通过对各种指标的比较或不同时期同一指标的对照才反映出数量的多少、质量的优劣、效率的高低、消耗的大小、发展速度的快慢等等，才能作为鉴别、下判断提供确凿有据的信息。</li>
</ul>
</blockquote>

<p>举个例子：</p>

<p><strong>◆ 定性分析：</strong><br/>
分析: _ 知几写了很多篇文章<br/>
<strong>◆ 定量分析：</strong><br/>
分析:_ 知几写了107篇文章。</p>

<blockquote>
<p>我的理解是定量分析主要关注的是频率；定性分析关注的是意义。</p>
</blockquote>

<h3 id="toc_1">定量数据又可分为：</h3>

<ul>
<li><p><strong>离散数据（Discrete Data）：</strong>指其数值只能用自然数或整数单位计算，例如企业的人数</p></li>
<li><ul>
<li>只能用自然数或整数单位计算</li>
</ul>

<ul>
<li>只能按计量单位数计数，可由一般计数方法取得</li>
</ul></li>
<li><p><strong>连续数据（Continuous Data）：</strong>在一定区间内可以任意取值的数据，其数值是连续不断的，例如人的身高</p></li>
<li><ul>
<li>一定区间内可以任意取值的数据，其数值是连续不断的，相邻两个数值可取无限个数值</li>
</ul>

<ul>
<li>其数值只能用测量或计量的方法获得</li>
</ul></li>
</ul>

<h2 id="toc_2">2.结构化vs半结构化vs非结构化数据</h2>

<ul>
<li>结构化数据</li>
<li>每笔数据都有固定的字段、固定的格式，方便程序进行后续取用与分析</li>
<li>例如数据库</li>
<li>半结构化数据</li>
<li>数据介于数据化结构与非结构化数据之间</li>
<li>数据具有字段，也可以依据字段来进行查找，使用方便，但每笔数据的字段可能不一致</li>
<li>例如：XML，JSON</li>
<li>非结构化数据</li>
<li>没有固定的格式，必须整理以后才能存取</li>
<li>没有格式的文字、网页数据</li>
</ul>

<h3 id="toc_3">1.结构化数据</h3>

<ul>
<li>结构化数据也称作行数据，是由二维表结构来逻辑表达和实现的数据，严格地遵循数据格式与长度规范，主要通过关系型数据库进行存储和管理。</li>
<li>对数据的处理和捞取可以通过<strong>SQL语句</strong>。</li>
</ul>

<h3 id="toc_4">2.半结构化数据 - XML</h3>

<pre><code>&lt;users&gt;
    &lt;user&gt;
        &lt;name&gt;xsl&lt;/name&gt;
        &lt;gender&gt;boy&lt;/gender&gt;
        &lt;age&gt;23&lt;/age&gt;
    &lt;/user&gt;
    &lt;user&gt;
      &lt;name&gt;xlm&lt;/name&gt;
      &lt;gender&gt;girl&lt;/gender&gt;
    &lt;/user&gt;
&lt;/users&gt;
</code></pre>

<ul>
<li>可以使用字段存储数据内容</li>
<li>字段不固定，例如xlm就少了age字段</li>
<li>可以弹性的存放各种字段格式的数据</li>
</ul>

<h3 id="toc_5">3.半结构化数据 - JSON</h3>

<pre><code>[
  user:{
    name:xsl,
    gender:boy,
    age:12,
},
  user:{
    name:xsl,
    gender:girl,
}
]
</code></pre>

<ul>
<li>如同XML可以使用字段存储数据内容</li>
<li>使用<code>Key:Value</code>存放数据</li>
<li>不用宣告字段的结尾，可以比XML更快更有效传输数据</li>
</ul>

<h3 id="toc_6">4.非结构化数据</h3>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/aSJyGw23SZD4C1QiceHyVNSicwKEUvlgkNu1m3OjWzaOCHJ7cvHFBh32b80KuXjY9HkhUCpKNEkd28852RPs6V5A/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"/></p>

<ul>
<li>没有固定的数据格式</li>
<li>例如网站数据</li>
<li>必须透过ETL(Extract,Transformation,Loading)工具将数据转换为结构化数据才能取用</li>
</ul>

<p>由于我们常见的数据是非结构化数据，为了进行数据分析，我们就需要从非结构化数据中挖掘数据，我们就需要先把非结构化数据转换成结构化数据，此时我们就可以使用ETL工具。</p>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/aSJyGw23SZD4C1QiceHyVNSicwKEUvlgkNiaHTjH8cxjFFfJOufjXPnMFibxZ1VvhSja3LiabTMiaicQKkIbSk0KPteOA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="数据抽取、转换、存储过程"/></p>

<p>​                                                                                                   数据抽取、转换、存储过程</p>

<h2 id="toc_7">3.Python IO与档案处理</h2>

<p>Python提供了默认操作文件所必需的基本功能和方法。可以使用文件对象执行大部分文件操作。</p>

<h3 id="toc_8">打开文件</h3>

<p>在读取或写入文件之前，需要使用Python的内置<code>open()</code>函数打开文件。此函数创建一个文件对象，该对象将用于调用与其相关联的其他支持方法。</p>

<p><strong>语法：</strong></p>

<pre><code>f = open(file_name [, access_mode][, buffering])
</code></pre>

<ul>
<li><code>file_name</code>参数是一个字符串值，指定要访问的文件的名称。</li>
<li><code>access_mode</code>确定文件打开的模式，即读取，写入，追加等。可能的值的完整列表如下表所示。这是一个可选参数，默认文件访问模式为(r - 也就是只读)。</li>
<li><code>bufferin</code>如果buffering值设置为0，则不会发生缓冲。如果缓冲值buffering为1，则在访问文件时执行行缓冲。如果将缓冲值buffering指定为大于1的整数，则使用指定的缓冲区大小执行缓冲操作。如果为负，则缓冲区大小为系统默认值(默认行为)。</li>
</ul>

<table>
<thead>
<tr>
<th style="text-align: center">编号</th>
<th style="text-align: left">模式</th>
<th style="text-align: left">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">1</td>
<td style="text-align: left"><code>r</code></td>
<td style="text-align: left">打开的文件为只读模式。文件指针位于文件的开头，这是默认模式。</td>
</tr>
<tr>
<td style="text-align: center">2</td>
<td style="text-align: left"><code>rb</code></td>
<td style="text-align: left">打开仅用二进制格式读取的文件。文件指针位于文件的开头，这是默认模式。</td>
</tr>
<tr>
<td style="text-align: center">3</td>
<td style="text-align: left"><code>r+</code></td>
<td style="text-align: left">打开读写文件。文件指针放在文件的开头。</td>
</tr>
<tr>
<td style="text-align: center">4</td>
<td style="text-align: left"><code>rb+</code></td>
<td style="text-align: left">以二进制格式打开一个用于读写文件。文件指针放在文件的开头。</td>
</tr>
<tr>
<td style="text-align: center">5</td>
<td style="text-align: left"><code>w</code></td>
<td style="text-align: left">打开仅供写入的文件。如果文件存在，则覆盖该文件。如果文件不存在，则创建一个新文件进行写入。</td>
</tr>
<tr>
<td style="text-align: center">6</td>
<td style="text-align: left"><code>wb</code></td>
<td style="text-align: left">打开仅用二进制格式写入的文件。如果文件存在，则覆盖该文件。如果文件不存在，则创建一个新文件进行写入。</td>
</tr>
<tr>
<td style="text-align: center">7</td>
<td style="text-align: left"><code>w+</code></td>
<td style="text-align: left">打开写入和取读的文件。如果文件存在，则覆盖现有文件。如果文件不存在，创建一个新文件进行阅读和写入。</td>
</tr>
<tr>
<td style="text-align: center">8</td>
<td style="text-align: left"><code>wb+</code></td>
<td style="text-align: left">打开一个二进制格式的写入和读取文件。如果文件存在，则覆盖现有文件。如果文件不存在，创建一个新文件进行阅读和写入。</td>
</tr>
<tr>
<td style="text-align: center">9</td>
<td style="text-align: left"><code>a</code></td>
<td style="text-align: left">打开一个文件进行追加。如果文件存在，则文件指针位于文件末尾。也就是说，文件处于追加模式。如果文件不存在，它将创建一个新文件进行写入。</td>
</tr>
<tr>
<td style="text-align: center">10</td>
<td style="text-align: left"><code>ab</code></td>
<td style="text-align: left">打开一个二进制格式的文件。如果文件存在，则文件指针位于文件末尾。也就是说，文件处于追加模式。如果文件不存在，它将创建一个新文件进行写入。</td>
</tr>
<tr>
<td style="text-align: center">11</td>
<td style="text-align: left"><code>a+</code></td>
<td style="text-align: left">打开一个文件，用于追加和阅读。如果文件存在，则文件指针位于文件末尾。文件以附加模式打开。如果文件不存在，它将创建一个新文件进行阅读和写入。</td>
</tr>
<tr>
<td style="text-align: center">12</td>
<td style="text-align: left"><code>ab+</code></td>
<td style="text-align: left">打开一个二进制格式的附加和读取文件。如果文件存在，则文件指针位于文件末尾。文件以附加模式打开。如果文件不存在，它将创建一个新文件进行读取和写入。</td>
</tr>
</tbody>
</table>

<ul>
<li><strong>write()方法</strong>：将任何字符串写入打开的文件。重要的是要注意，Python字符串可以是二进制数据，而不仅仅是文本。</li>
<li><strong>close()方法</strong>：刷新任何未写入的信息并关闭文件对象，之后不能再进行写入操作。</li>
</ul>

<pre><code>f =open(&#39;zj.txt&#39;, &#39;w&#39;)  #读写模式
f.write(&#39;hello xlm&#39;) #写入 hello xlm
f.close() 关闭文件

#用with写
with open(&#39;zj.txt&#39;, &#39;r&#39;) as f:
    print(f.read()) #全部读取

with open(&#39;zj.txt&#39;, &#39;r&#39;) as f:
    for line in f.readlines():
        print(line)   #分行打印出来
        print(line.strip())  #去除多余的换行
</code></pre>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/aSJyGw23SZD4C1QiceHyVNSicwKEUvlgkNR8icWZHiaC8ZV2fcvDKsicUUJlR2D9J9HJAYnBlpolnXUtKcsLc0TWW1A/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="打开本地文件，可以看到&lt;code&gt;hello xlm&lt;/code&gt; 已经写入文件"/>   </p>

<p>打开本地文件，可以看到<code>hello xlm</code> 已经写入文件</p>

<blockquote>
<p>转载自微信，仅供个人学习使用</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python 为什么要保留显式的 self]]></title>
    <link href="https://sparkbye.github.io/myBlog/15929207363484.html"/>
    <updated>2020-06-23T21:58:56+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15929207363484.html</id>
    <content type="html"><![CDATA[
<p>布鲁斯·埃克尔（Bruce Eckel）<strong>发了篇博文</strong>[1]，提议从类方法的形参列表中删除“self”。我将解释为什么这个提议不能通过。（译注：Bruce 是《Thinking in Java》、《Thinking in C++》等多本书籍的作者，也是个 Python 开发者。他的文章总结了当年在巴西 Pycon 上的一次讨论，主要观点是在定义类方法时，形参中的“self”是多余的，而且由它引发的报错信息具有一定的误导性。）</p>

<h2 id="toc_0"><strong>Bruce 的提议</strong></h2>

<p>Bruce 知道，我们需要一种方法来区分对实例变量的引用和对其它变量的引用，因此他建议将“self”设为关键字。</p>

<p>考虑一种典型的类，它有一个方法，例如：</p>

<pre><code class="language-C">class C:
   def meth(self, arg):
      self.val = arg
      return self.val
</code></pre>

<p>跟据 Bruce 的提议，这将变为：</p>

<pre><code class="language-C">class C:
   def meth(arg):# Look ma, no self!
      self.val = arg
      return self.val
</code></pre>

<p>这样每个方法会节省 6 个字符。但我不觉得 Bruce 提出这个建议是为了减少打字。</p>

<p>我认为他真正关心的是程序员（可能来自其它语言）所浪费的时间，有时候似乎不需要指定“self”参数，而且他们偶尔忘记了要加（即使他们十分清楚——习惯是一种强大的力量）。确实，与忘记在实例变量或方法引用之前键入“self.”相比，从参数列表中省略“self”，往往会导致很模糊的错误消息。</p>

<p>也许更糟糕的是（如 Bruce 所述），当正确地声明了方法，但是在调用时的参数数量不对，这时收到的错误消息。如 Bruce 给出的以下示例：</p>

<pre><code>Traceback (most recent call last):
File &quot;classes.py&quot;, line 9, in
   obj.m2(1)
TypeError: m2() takes exactly 3 arguments (2 given)
</code></pre>

<p>我赞同它是令人困惑的，但是我宁愿去解决此错误消息，而不是修改语言。</p>

<h2 id="toc_1"><strong>为什么 Bruce 的提议不可行</strong></h2>

<p>首先，让我提出一些与 Bruce 的提议相反的典型论点。</p>

<p>这有一个很好的论据可以证明，在参数列表中使用显式的“self”，可以增强以下两种调用方法在理论上的等效性。假设“ foo”是“C”的一个实例：</p>

<pre><code>foo.meth(arg) == C.meth(foo, arg)
</code></pre>

<p>（译注：说实话，我没有理解这个例子的意思。以下仅是个人看法。在类的内部定义方法时，可能会产生几种不同的方法：<strong>实例方法</strong>、<strong>类方法</strong>和 <strong>静态方法</strong>。它们的作用和行为是不同的，那么在定义和调用时怎么做区分呢？Python 约定了一种方式，即在定义时用第一个参数作区分：self 表示实例方法、cls或其它符号 表示类方法……三种方法都可以被类的实例调用，而且看起来一模一样，如上例的等号左侧那样。这时候就要靠定义时赋予的参数来区分了，像上例等号右侧，第一个参数是实例对象，表明此处是个实例方法。）</p>

<p>另一个论据是，在参数列表中使用显式的“self”，将一个函数插入一个类，获得动态地修改一个类的能力，创建出相应的一个类方法。</p>

<p>例如，我们可以创建一个与上面的“C”完全等效的类，如下所示：</p>

<pre><code># Define an empty class:
class C:
   pass

# Define a global function:
def meth(myself, arg):
   myself.val = arg
   return myself.val

# Poke the method into the class:
C.meth = meth
</code></pre>

<p>请注意，我将“self”参数重命名为“myself”，以强调（在语法上）我们不是在此处定义一个方法（译注：类外部的是<strong>函数</strong>，即 function，类内部的是<strong>方法</strong>，即 method）。</p>

<p>这样之后，C 的实例就具有了一个“meth”方法，该方法有一个参数，且功能跟之前的完全一样。对于在把方法插入类之前就创建的那些 C 的实例，它甚至也适用。</p>

<p>我想 Bruce 并不特别在意前述的等效性。我同意这只是理论上的重要。我能想到的唯一例外是旧式的调用超级方法的习语（idiom）。但是，这个习语很容易出错（正是由于需要显式地传递&quot;self&quot;的原因），这就是为什么在 Python 3000中，我建议在所有情况下都使用&quot;super()&quot;的原因。</p>

<p>Bruce 可能会想到一种使第二个等效例子起作用的方法——在某些情况下，这种等效性真的很重要。我不知道 Bruce 花了多少时间思考如何实现他的提议，但是我想他正在考虑将一个名为“self”的额外形参自动地添加到直接地在类内部定义的所有方法的思路（我必须说是“直接地”，以便那些嵌套在方法内部的函数，能免于这种自动操作）。这样，可以使第一个等效例子保持等效。</p>

<p>但是，有一种情况我认为 Bruce 不能在不向编译器中添加某种 ESP 的情况下解决：<strong>装饰器。</strong>我相信这是 Bruce 的提议的最终败笔。</p>

<p>当装饰一个方法时，我们不知道是否要自动地给它加一个“self”参数：装饰器可以将函数变成一个静态方法（没有“self”）或一个类方法（有一个有趣的 self，它指向一个类而不是一个实例），或者可以做一些完全不同的事情（用纯 Python 实现“ @classmethod”或“ @staticmethod”的装饰器是繁琐的）。除非知道装饰器的用途，否则没有其它办法来确定是否要赋予正在定义的方法一个隐式的“self”参数。</p>

<p>我拒绝诸如特殊包装的“@classmethod”和“@staticmethod”之类的黑科技。我也认为除了自检外，自动地确定某个方法是类方法（class method）、实例方法（instance method）还是静态方法（static method），这不是一个好主意（就像在 Bruce 的文章的评论中，有人建议的那样）：这使得很难仅仅根据方法前的“def”，来决定应该怎样调用该方法。</p>

<p>（译注：对于一个方法，在当前的添加了相应参数的情况下，可以简单地加装饰器，区分它是哪种方法，调用时也容易区分调用；但是，如果没有加参数，即使可以用神奇的自动机制来区分出它是哪种方法，但在调用时，你不好确定该怎么调用）。</p>

<p>在评论中，我看到了一些非常极端的对 Bruce 的提议的附和，但通常的代价是使得规则难以遵循，或者要求对语言进行更深层的修改，这令我们极其难以接受它，特别是合入 Python 3.1。顺便说一句，对于 3.1，再次声明我们的规则，新特性只有在保持向后兼容的情况下才是可接受的。</p>

<p>有一个似乎可行的建议（可以使它向后兼容）是把类中的</p>

<pre><code>def foo(self, arg): ...
</code></pre>

<p>改成这样的语法糖：</p>

<pre><code>def self.foo(arg): ...
</code></pre>

<p>但我不认同它把“self”变为保留字（reserved word），或者要求前缀必须是“self”。如果这样做了，那对于类方法，很容易也出现这种情况：</p>

<pre><code>@classmethod
def cls.foo(arg): ...
</code></pre>

<p>好了，相比于现状，我并没有更喜欢这个。但是相比于 Bruce 的提议或在他的博客评论区中提出的更极端的说法，我认为这个要好得多，而且它具有向后兼容的巨大优势，并且不需要很费力，就可以写成带有参考实现的 PEP。（我想 Bruce 应该会发现自己提案中的缺陷，如果他真的付出努力尝试编写可靠的 PEP 或者尝试实现它。）</p>

<p>我可以继续聊很多，但这是一个阳光明媚的周日早晨，而我还有其它的计划... :-)</p>

<p>作者：Guido van Rossum，写于：2008.10.26</p>

<p><strong>参考资料</strong></p>

<p>[1] Bruce博文：<a href="http://www.artima.com/weblogs/viewpost.jsp?thread=239003">http://www.artima.com/weblogs/viewpost.jsp?thread=239003</a></p>

<p>[2] Guido原文: <a href="https://neopythonic.blogspot.com/2008/10/why-explicit-self-has-to-stay.html">https://neopythonic.blogspot.com/2008/10/why-explicit-self-has-to-stay.html</a></p>

<blockquote>
<p>转载自微信，仅供个人学习使用</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[详解Python 3.8的海象算子]]></title>
    <link href="https://sparkbye.github.io/myBlog/15928352455072.html"/>
    <updated>2020-06-22T22:14:05+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15928352455072.html</id>
    <content type="html"><![CDATA[
<p>最近，Python 社区发布了该语言的 3.8 版本。作为 Python 语法糖的爱好者，我探索了发布说明，关注到了其中一个独特的算子。这个算子被称为「海象算子（Walrus Operator）」或「命名表达式算子（Named Expression operator）」，符号为「:=」。</p>

<h2 id="toc_0"><b>海象算子</b></h2>

<blockquote>
<p>官网介绍：Assignment expressions（赋值表达式）<br/>
There is new syntax := that assigns values to variables as part of a larger expression. It is affectionately known as “the walrus operator” due to its resemblance to the eyes and tusks of a walrus.</p>
</blockquote>

<p>这个新算子（:=）能让我们为表达式中的一个变量赋值。这个符号看起来颇有些类似于海象的眼睛和犬齿。</p>

<p>我们先来看看下面一段代码：</p>

<pre><code class="language-python">countries = [&quot;India&quot;, &quot;USA&quot;, &quot;France&quot;, &quot;Germany&quot;]
</code></pre>

<pre><code class="language-python">if len(countries) &lt; 5:
    print(&quot;Length of countries is {}&quot;.format(len(countries)))
</code></pre>

<pre><code>Length of countries is 4
</code></pre>

<p>在上面的代码段中，我们两次调用了函数 len()。我们可以避免重复计算以提升可读性吗？当然可以，我们可对这段代码进行如下改进：</p>

<pre><code class="language-python">country_size = len(countries)
if country_size &lt; 5:
    print (&quot;Length of countries is {}&quot;.format(country_size))
</code></pre>

<pre><code>Length of countries is 4
</code></pre>

<p>还有进一步改进的空间吗？我们可以不用单独一行来给「country_size」赋值吗？</p>

<pre><code class="language-python">if (country_size := len(countries)) &lt; 5 :
        print (&quot;Length of countries is {}&quot;.format(country_size))
</code></pre>

<pre><code>Length of countries is 4
</code></pre>

<p>这就是 Python 3.8 引入的海象算子的用武之地。我们可以在 if 语句之中直接执行声明和赋值操作。我们下面进一步探索该算子的能力。</p>

<h2 id="toc_1"><b>代码行数与复杂度的平衡</b></h2>

<p>先看看以下示例:</p>

<pre><code class="language-python">def get_count():
    &quot;Fetches count of records from a database&quot;
    return 100
    
powers = [get_count(), get_count()**2, get_count()**3]
print(powers)
</code></pre>

<pre><code>[100, 10000, 1000000]
</code></pre>

<p>上面的示例是通过多次调用一个高成本的函数 get_count() 来填充一个列表。 </p>

<p>有了海象算子的帮助，我们可以避免多次调用函数 get_count()，其具体的功能是将结果存储到一个变量中，然后我们可在后续的计算中复用同一个变量。下面演示了海象算子的用法：</p>

<pre><code class="language-python">powers =[result:= get_count(), result**2, result**3]
print(powers)
</code></pre>

<pre><code>[100, 10000, 1000000]
</code></pre>

<p>从上面的例子可以看到，海象算子可以减少代码行数，让代码更可读，因此能简化代码审查人员的工作。此外，这也能实现代码行数和代码复杂度的平衡。</p>

<h2 id="toc_2"><b>解决理解低效的问题</b></h2>

<p>看下面这个例子：</p>

<pre><code class="language-python">employees = []
employee_ids = {1:&quot;Tommy&quot;, 2:&quot;Tobey&quot;, 3:&quot;Evan&quot;, 4:&quot;Golf&quot;}
for key in employee_ids:
    employee = employee_ids[key]
    if employee:
        employees.append(employee)
print(employees)
</code></pre>

<pre><code>[&#39;Tommy&#39;, &#39;Tobey&#39;, &#39;Evan&#39;, &#39;Golf&#39;]
</code></pre>

<p>上面的示例需要多次执行循环。一开始，我们创建一个空列表，然后在 id 列表上迭代并通过检查结果是否有效来填充我们创建的列表。</p>

<p>我们可以简化上面的代码，将其浓缩为一行：</p>

<pre><code class="language-python">employees = [result for key in employee_ids if (result:= employee_ids[key])]
print(employees)
</code></pre>

<pre><code>[&#39;Tommy&#39;, &#39;Tobey&#39;, &#39;Evan&#39;, &#39;Golf&#39;]
</code></pre>

<h2 id="toc_3"><b>文件分块处理</b></h2>

<p>在处理大文件时，我们会将文件分块读取。每当读取一个分块时，都会检查它的值，并且该值也是 while 循环的终止条件。</p>

<pre><code class="language-python">chunk = file.read(256)

while chunk:
    process(chunk)
    chunk = file.read(256)
</code></pre>

<p>我们可以在 while 循环表达式中读取数据以及为要读取的数据赋值。由此我们就能避免在 while 循环之外显式地声明变量。如下示例：</p>

<pre><code class="language-python">while (chunk := file.read(256)):
    process(chunk)
</code></pre>

<h2 id="toc_4"><b>正则表达式匹配</b></h2>

<p>正则表达式匹配是一个两步式过程。第一步是检查是否有匹配，第二步是提取匹配的部分。</p>

<pre><code class="language-python">import re
obj = re.match(r&quot;(\d+)\.(\d+)&quot;, &quot;24.1632&quot;).group(1) if re.match(r&quot;(\d+)\.(\d+)&quot;, &quot;24.1632&quot;) else None
print(obj)
</code></pre>

<pre><code>24
</code></pre>

<p>从上面的代码可以观察到，我们在一次匹配中重复计算了 re.match(r&quot;(\d+).(\d+)&quot;, &quot;24.1632&quot;)。这会减慢该程序的执行速度，而且数据量越大减慢得越明显。上面的代码可以重写为如下形式，从而避免重复计算：</p>

<pre><code class="language-python">obj = match.group(1) if (match := re.match(r&quot;(\d+)\.(\d+)&quot;, &quot;24.1632&quot;)) else None
print(obj)
</code></pre>

<pre><code>24
</code></pre>

<h2 id="toc_5"><b>不能使用海象算子的地方</b></h2>

<h3 id="toc_6">为变量赋值</h3>

<pre><code class="language-python">a = 5 # 有效
a := 5 # 无效
</code></pre>

<pre><code>  File &quot;&lt;ipython-input-50-7471f449f795&gt;&quot;, line 2
    a := 5 # 无效
      ^
SyntaxError: invalid syntax
</code></pre>

<pre><code class="language-python">empty_list = [] # 有效
empty_list := [] # 无效
</code></pre>

<pre><code>  File &quot;&lt;ipython-input-51-c637bed9e3c4&gt;&quot;, line 2
    empty_list := [] # 无效
               ^
SyntaxError: invalid syntax
</code></pre>

<p>如上所示，我们不能使用 := 替代 =。海象算子只能是一个表达式的一部分。</p>

<h3 id="toc_7">加法/减法赋值</h3>

<pre><code class="language-python">a += 5 # 有效
a :+=5 # 无效
</code></pre>

<pre><code>  File &quot;&lt;ipython-input-52-d36dacdf957b&gt;&quot;, line 2
    a :+=5 # 无效
       ^
SyntaxError: invalid syntax
</code></pre>

<h3 id="toc_8">在 lambda 函数中为表达式赋值</h3>

<pre><code class="language-python">(lambda: a:= 5) # 无效
(lambda: (a := 5)) # 有效但无用
(var := lambda: 5) # 有效
</code></pre>

<pre><code>  File &quot;&lt;ipython-input-53-257421e1abae&gt;&quot;, line 1
    (lambda: a:= 5) # 无效
     ^
SyntaxError: cannot use named assignment with lambda
</code></pre>

<h3 id="toc_9">PEP-572 及其争议</h3>

<p>海象算子是作为 PEP-572（Python 改进提议）的一部分而引入的。如果要为 Python 语言引入一项新功能，总是需要经由 PEP 来实现，而且必须得到 Python 的发明者 Guido van Rossum 或他选择的代表的批准。</p>

<p>围绕海象算子的争议非常多，而且由此引发的「战争」导致了 Python 之父 Guido van Rossum 告退，不再担任 Python 社区的终身仁慈独裁者（BDFL）。海象算子的争议点有很多，下面是其中几个：</p>

<ul>
<li>句法变化问题：开发者们为 := 提议了多种替代方案，比如「表达式 -&gt; NAME」、「NAME -&gt; 表达式」、「{表达式} NAME」等等。少数人建议使用现有的关键字，其他人则使用了新的算子。</li>
<li>后向兼容问题：这个特性无法向后兼容，也无法运行在之前的 Python 版本上。</li>
<li>算子名称问题：人们建议不要使用「海象算子」这样的代号，而是使用「赋值算子」、「命名表达式算子」、「成为算子」等术语，以免人们不明白。</li>
</ul>

<blockquote>
<p>转载自微信，仅供个人学习使用</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift基本语法]]></title>
    <link href="https://sparkbye.github.io/myBlog/15726710349835.html"/>
    <updated>2019-11-02T13:03:54+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15726710349835.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">1. Swift交互式解释器</h3>

<h4 id="toc_1">1.1 Terminal上运行swift进入REPL解释器</h4>

<pre><code class="language-swift">  1&gt; let a = &quot;100&quot;
a: String = &quot;100&quot;
  2&gt; Int(a)
$R0: Int? = 100
  3&gt; let b = $R0 + 50
error: repl.swift:3:9: error: value of optional type &#39;Int?&#39; must be unwrapped to a value of type &#39;Int&#39;
let b = $R0 + 50
        ^

repl.swift:3:9: note: coalesce using &#39;??&#39; to provide a default when the optional value contains &#39;nil&#39;
let b = $R0 + 50
        ^
        (   ?? &lt;#default value#&gt;)

repl.swift:3:9: note: force-unwrap using &#39;!&#39; to abort execution if the optional value contains &#39;nil&#39;
let b = $R0 + 50
        ^
           !
  3&gt; let b = $R0! + 50
b: Int = 150
</code></pre>

<blockquote>
<p>$R0 : Int?  </p>
</blockquote>

<p>可选值， 需要解包</p>

<h4 id="toc_2">1.2 swift palyground 学习的乐园</h4>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[]]></title>
    <link href="https://sparkbye.github.io/myBlog/15726710075785.html"/>
    <updated>2019-11-02T13:03:27+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15726710075785.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Modules - 03 - Python itertools]]></title>
    <link href="https://sparkbye.github.io/myBlog/15662172714318.html"/>
    <updated>2019-08-19T20:21:11+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15662172714318.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">Module-1: itertools 模块总结</h4>

<p>我们知道，迭代器的特点是：惰性求值（Lazy evaluation），即只有当迭代至某个值时，它才会被计算，这个特点使得迭代器特别适合于遍历大文件或无限集合等，因为我们不用一次性将它们存储在内存中。</p>

<p>Python 内置的 itertools 模块包含了一系列用来产生不同类型迭代器的函数或类，这些函数的返回都是一个迭代器，我们可以通过 for 循环来遍历取值，也可以使用 next() 来取值。<br/><br/>
itertools 模块提供的迭代器函数有以下几种类型：<br/>
- 无限迭代器：生成一个无限序列，比如自然数序列 1, 2, 3, 4, ...；<br/>
- 有限迭代器：接收一个或多个序列（sequence）作为参数，进行组合、分组和过滤等；<br/>
- 组合生成器：序列的排列、组合，求序列的笛卡儿积等；</p>

<pre><code class="language-python">import itertools
</code></pre>

<p><b>无限迭代器</b></p>

<p>itertools 模块提供了三个函数（事实上，它们是类）用于生成一个无限序列迭代器：<br/>
- count(firstval=0, step=1)创建一个从 firstval (默认值为 0) 开始，以 step (默认值为 1) 为步长的的无限整数迭代器<br/>
- cycle(iterable)对 iterable 中的元素反复执行循环，返回迭代器<br/>
- repeat(object [,times]反复生成 object，如果给定 times，则重复次数为 times，否则为无限</p>

<ol>
<li><b>count</b></li>
</ol>

<p>count() 接收两个参数，第一个参数指定开始值，默认为 0，第二个参数指定步长，默认为 1：</p>

<pre><code class="language-python">nums = itertools.count()
for i in nums:
    if i &gt; 5:
        break
    print(i)
</code></pre>

<pre><code>0
1
2
3
4
5
</code></pre>

<pre><code class="language-python">nums = itertools.count(10, 2)
for i in nums:
    if i &gt; 20:
        break
    print(i)
</code></pre>

<pre><code>10
12
14
16
18
20
</code></pre>

<ol>
<li><b>cycle</b></li>
</ol>

<p>cycle() 用于对 iterable 中的元素反复执行循环：</p>

<pre><code class="language-python">cycle_strings = itertools.cycle(&#39;ABC&#39;)
i = 1
for string in cycle_strings:
    if i == 10:
        break
    print(i, string)
    i += 1
</code></pre>

<pre><code>1 A
2 B
3 C
4 A
5 B
6 C
7 A
8 B
9 C
</code></pre>

<ol>
<li><b>repeat</b></li>
</ol>

<p>repeat() 用于反复生成一个 object：</p>

<pre><code class="language-python">for item in itertools.repeat(&#39;hello world&#39;, 3):
    print(item)
</code></pre>

<pre><code>hello world
hello world
hello world
</code></pre>

<p><b>有限迭代器</b></p>

<p>itertools 模块提供了多个函数（类），接收一个或多个迭代对象作为参数，对它们进行组合、分组和过滤等：<br/>
- chain()<br/>
- compress()<br/>
- dropwhile()<br/>
- groupby()<br/>
- ifilter()<br/>
- ifilterfalse()<br/>
- islice()<br/>
- imap()<br/>
- starmap()<br/>
- tee()<br/>
- takewhile()<br/>
- izip()<br/>
- izip_longest()</p>

<ol>
<li><b>chain</b></li>
</ol>

<p>chain 的使用形式如下：</p>

<blockquote>
<p>chain(iterable1, iterable2, iterable3, ...)     </p>
</blockquote>

<p>chain 接收多个可迭代对象作为参数，将它们『连接』起来，作为一个新的迭代器返回。</p>

<pre><code class="language-python">from itertools import chain
for item in chain([1, 2, 3], [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]):
    print(item)
</code></pre>

<pre><code>1
2
3
a
b
c
</code></pre>

<p>chain 还有一个常见的用法：</p>

<blockquote>
<p>chain.from_iterable(iterable)</p>
</blockquote>

<p>接收一个可迭代对象作为参数，返回一个迭代器：</p>

<pre><code class="language-python">#扁平列表
a = [[1, 2], [3, 4], [5, 6]]
b = list(chain.from_iterable(a))
print(b)

#还有个更有意思的扁平列表
print(sum(a, []))

str = chain.from_iterable(&#39;ABCDEF&#39;)
# 注意python3是next(), python2是.next()
print(next(str))
</code></pre>

<pre><code>[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
A
</code></pre>

<ol>
<li><b>compress</b></li>
</ol>

<p>compress 的使用形式如下：</p>

<blockquote>
<p>compress(data, selectors)</p>
</blockquote>

<p>compress 可用于对数据进行筛选，当 selectors 的某个元素为 true 时，则保留 data 对应位置的元素，否则去除：</p>

<pre><code class="language-python">from itertools import compress
a = list(compress(&#39;ABCDEF&#39;, [1, 1, 0, 1, 0, 1]))
print(a)
b = list(compress(&#39;ABCDEF&#39;, [1, 1, 0, 1]))
print(b)
c = list(compress(&#39;ABCDEF&#39;, [True, False, True]))
print(c)
</code></pre>

<pre><code>[&#39;A&#39;, &#39;B&#39;, &#39;D&#39;, &#39;F&#39;]
[&#39;A&#39;, &#39;B&#39;, &#39;D&#39;]
[&#39;A&#39;, &#39;C&#39;]
</code></pre>

<ol>
<li><b>dropwhile</b></li>
</ol>

<p>dropwhile 的使用形式如下：</p>

<blockquote>
<p>dropwhile(predicate, iterable)</p>
</blockquote>

<p>其中，predicate 是函数，iterable 是可迭代对象。对于 iterable 中的元素，如果 predicate(item) 为 true，则丢弃该元素，否则返回该项及所有后续项。<br/><br/>
predicate 断言，断定。 注意其返回项是丢弃元素判定失败后的后续项</p>

<pre><code class="language-python">from itertools import dropwhile
a = list(dropwhile(lambda x: x &lt; 5, [1, 3, 6, 2, 1]))
print(a)
b = list(dropwhile(lambda x: x &gt; 3, [2, 1, 6, 5, 4]))
print(b)
</code></pre>

<pre><code>[6, 2, 1]
[2, 1, 6, 5, 4]
</code></pre>

<ol>
<li><b>groupby</b></li>
</ol>

<p>groupby 用于对序列进行分组，它的使用形式如下：</p>

<blockquote>
<p>groupby(iterable[, keyfunc])</p>
</blockquote>

<p>其中，iterable 是一个可迭代对象，keyfunc 是分组函数，用于对 iterable 的连续项进行分组，如果不指定，则默认对 iterable 中的连续相同项进行分组，返回一个 (key, sub-iterator) 的迭代器。</p>

<pre><code class="language-python">from itertools import groupby
for key, value_iter in groupby(&#39;aaabbbaaccd&#39;):
    print(key, &#39;:&#39;, list(value_iter))
print(&quot;================================&quot;)
data = [&#39;a&#39;, &#39;bb&#39;, &#39;ccc&#39;, &#39;dd&#39;, &#39;eee&#39;, &#39;f&#39;]
for key, value_iter in groupby(data, len):   # 使用 len 函数作为分组函数
    print(key, &#39;:&#39;, list(value_iter))
print(&quot;================================&quot;)
data = [&#39;a&#39;, &#39;bb&#39;, &#39;cc&#39;, &#39;ddd&#39;, &#39;eee&#39;, &#39;f&#39;]
for key, value_iter in groupby(data, len):
    print(key, &#39;:&#39;, list(value_iter))
</code></pre>

<pre><code>a : [&#39;a&#39;, &#39;a&#39;, &#39;a&#39;]
b : [&#39;b&#39;, &#39;b&#39;, &#39;b&#39;]
a : [&#39;a&#39;, &#39;a&#39;]
c : [&#39;c&#39;, &#39;c&#39;]
d : [&#39;d&#39;]
================================
1 : [&#39;a&#39;]
2 : [&#39;bb&#39;]
3 : [&#39;ccc&#39;]
2 : [&#39;dd&#39;]
3 : [&#39;eee&#39;]
1 : [&#39;f&#39;]
================================
1 : [&#39;a&#39;]
2 : [&#39;bb&#39;, &#39;cc&#39;]
3 : [&#39;ddd&#39;, &#39;eee&#39;]
1 : [&#39;f&#39;]
</code></pre>

<ol>
<li><b>ifilter</b> (Python3已不再提供)</li>
</ol>

<p>ifilter 的使用形式如下：</p>

<blockquote>
<p>ifilter(function or None, sequence)</p>
</blockquote>

<p>将 iterable 中 function(item) 为 True 的元素组成一个迭代器返回，如果 function 是 None，则返回 iterable 中所有计算为 True 的项。</p>

<pre><code class="language-python">#from itertools import ifilter          # Python3已经不再提供，python3使用filter()

#a = list(ifilter(lambda x: x &lt; 6, range(10)))
a = list(filter(lambda x: x &lt; 6, range(10)))
print(a)
#b = list(ifilter(None, [0, 1, 2, 0, 3, 4]))
b = list(filter(None, [0, 1, 2, 0, 3, 4]))
print(b)
</code></pre>

<pre><code>[0, 1, 2, 3, 4, 5]
[1, 2, 3, 4]
</code></pre>

<ol>
<li><b>ifilterfalse</b> (Python3已不再提供)</li>
</ol>

<p>ifilterfalse 的使用形式和 ifilter 类似，它将 iterable 中 function(item) 为 False 的元素组成一个迭代器返回，如果 function 是 None，则返回 iterable 中所有计算为 False 的项。</p>

<pre><code class="language-python">#from itertools import ifilterfalse
#list(ifilterfalse(lambda x: x &lt; 6, range(10)))
#[6, 7, 8, 9]
#list(ifilter(None, [0, 1, 2, 0, 3, 4]))
#[0, 0]
</code></pre>

<ol>
<li><b>islice</b></li>
</ol>

<p>islice 是切片选择，它的使用形式如下：</p>

<blockquote>
<p>islice(iterable, [start,] stop [, step])</p>
</blockquote>

<p>其中，iterable 是可迭代对象，start 是开始索引，stop 是结束索引，step 是步长，start 和 step 可选。</p>

<pre><code class="language-python">from itertools import count, islice
a = list(islice([10, 6, 2, 8, 1, 3, 9], 5))
print(a)
b = list(islice(count(), 6))
print(b)
c = list(islice(count(), 3, 10))
print(c)
d = list(islice(count(), 3, 10 ,2))
print(d)
</code></pre>

<pre><code>[10, 6, 2, 8, 1]
[0, 1, 2, 3, 4, 5]
[3, 4, 5, 6, 7, 8, 9]
[3, 5, 7, 9]
</code></pre>

<ol>
<li><b>imap</b> (Python3已不再提供) </li>
</ol>

<p>imap 类似 map 操作，它的使用形式如下：</p>

<blockquote>
<p>imap(func, iter1, iter2, iter3, ...)</p>
</blockquote>

<p>imap 返回一个迭代器，元素为 func(i1, i2, i3, ...)，i1，i2 等分别来源于 iter, iter2。</p>

<pre><code class="language-python">#from itertools import imap
#print(imap(str, [1, 2, 3, 4]))
#&lt;itertools.imap object at 0x10556d050&gt;
#print(list(imap(str, [1, 2, 3, 4])))
#[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;]
#print(list(imap(pow, [2, 3, 10], [4, 2, 3])))
#[16, 9, 1000]
</code></pre>

<ol>
<li><b>tee</b></li>
</ol>

<p>tee 的使用形式如下：</p>

<blockquote>
<p>tee(iterable [,n])</p>
</blockquote>

<p>tee 用于从 iterable 创建 n 个独立的迭代器，以元组的形式返回，n 的默认值是 2。</p>

<pre><code class="language-python">from itertools import tee
print(tee(&#39;abcd&#39;))   # n 默认为 2，创建两个独立的迭代器
iter1, iter2 = tee(&#39;abcde&#39;)
print(list(iter1))
print(list(iter2))
print(tee(&#39;abc&#39;, 3))  # 创建三个独立的迭代器
</code></pre>

<pre><code>(&lt;itertools._tee object at 0x000001F91721CF88&gt;, &lt;itertools._tee object at 0x000001F917221788&gt;)
[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]
[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]
(&lt;itertools._tee object at 0x000001F917221848&gt;, &lt;itertools._tee object at 0x000001F917221608&gt;, &lt;itertools._tee object at 0x000001F917221888&gt;)
</code></pre>

<ol>
<li><b>takewhile</b></li>
</ol>

<p>takewhile 的使用形式如下：</p>

<blockquote>
<p>takewhile(predicate, iterable)</p>
</blockquote>

<p>其中，predicate 是函数，iterable 是可迭代对象。对于 iterable 中的元素，如果 predicate(item) 为 true，则保留该元素，只要 predicate(item) 为 false，则立即停止迭代。</p>

<pre><code class="language-python">from itertools import takewhile
a = list(takewhile(lambda x: x &lt; 5, [1, 3, 6, 2, 1]))
print(a)
b = list(takewhile(lambda x: x &gt; 3, [2, 1, 6, 5, 4]))
print(b)
</code></pre>

<pre><code>[1, 3]
[]
</code></pre>

<ol>
<li><b>zip</b> (Python3已不再提供) </li>
</ol>

<p>izip 用于将多个可迭代对象对应位置的元素作为一个元组，将所有元组『组成』一个迭代器，并返回。它的使用形式如下：</p>

<blockquote>
<p>izip(iter1, iter2, ..., iterN)</p>
</blockquote>

<p>如果某个可迭代对象不再生成值，则迭代停止。</p>

<pre><code class="language-python">#from itertools import izip
#for item in izip(&#39;ABCD&#39;, &#39;xy&#39;):
#    print(item)    
#for item in izip([1, 2, 3], [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]):
#    print(item)
</code></pre>

<ol>
<li><b>izip_longest</b> (Python3已不再提供) </li>
</ol>

<p>izip_longest 跟 izip 类似，但迭代过程会持续到所有可迭代对象的元素都被迭代完。它的形式如下：</p>

<blockquote>
<p>izip_longest(iter1, iter2, ..., iterN, [fillvalue=None])</p>
</blockquote>

<p>如果有指定 fillvalue，则会用其填充缺失的值，否则为 None。</p>

<pre><code class="language-python">#from itertools import izip_longest
#for item in izip_longest(&#39;ABCD&#39;, &#39;xy&#39;):
#    print(item)
#for item in izip_longest(&#39;ABCD&#39;, &#39;xy&#39;, fillvalue=&#39;-&#39;):
#    print(item)

####output:
#(&#39;A&#39;, &#39;x&#39;)
#(&#39;B&#39;, &#39;y&#39;)
#(&#39;C&#39;, None)
#(&#39;D&#39;, None)

#(&#39;A&#39;, &#39;x&#39;)
#(&#39;B&#39;, &#39;y&#39;)
#(&#39;C&#39;, &#39;-&#39;)
#(&#39;D&#39;, &#39;-&#39;)
</code></pre>

<p><b>组合生成器</b></p>

<p>itertools 模块还提供了多个组合生成器函数，用于求序列的排列、组合等：<br/><br/>
- product<br/>
- permutations<br/>
- combinations<br/>
- combinations_with_replacement    </p>

<p>这些都是排列组合必备良方</p>

<ol>
<li><b>product</b></li>
</ol>

<p>product 用于求多个可迭代对象的笛卡尔积，它跟嵌套的 for 循环等价。它的一般使用形式如下：</p>

<blockquote>
<p>product(iter1, iter2, ... iterN, [repeat=1])</p>
</blockquote>

<p>其中，repeat 是一个关键字参数，用于指定重复生成序列的次数，</p>

<pre><code class="language-python">from itertools import product
for item in product(&#39;ABCD&#39;, &#39;xy&#39;):
    print(item)
</code></pre>

<pre><code>(&#39;A&#39;, &#39;x&#39;)
(&#39;A&#39;, &#39;y&#39;)
(&#39;B&#39;, &#39;x&#39;)
(&#39;B&#39;, &#39;y&#39;)
(&#39;C&#39;, &#39;x&#39;)
(&#39;C&#39;, &#39;y&#39;)
(&#39;D&#39;, &#39;x&#39;)
(&#39;D&#39;, &#39;y&#39;)
</code></pre>

<pre><code class="language-python">a = list(product(&#39;ab&#39;, range(3)))
print(a)
</code></pre>

<pre><code>[(&#39;a&#39;, 0), (&#39;a&#39;, 1), (&#39;a&#39;, 2), (&#39;b&#39;, 0), (&#39;b&#39;, 1), (&#39;b&#39;, 2)]
</code></pre>

<pre><code class="language-python">b = list(product((0,1), (0,1), (0,1)))
print(b)
</code></pre>

<pre><code>[(0, 0, 0), (0, 0, 1), (0, 1, 0), (0, 1, 1), (1, 0, 0), (1, 0, 1), (1, 1, 0), (1, 1, 1)]
</code></pre>

<pre><code class="language-python">c = list(product(&#39;ABC&#39;, repeat=2))
print(c)
</code></pre>

<pre><code>[(&#39;A&#39;, &#39;A&#39;), (&#39;A&#39;, &#39;B&#39;), (&#39;A&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;A&#39;), (&#39;B&#39;, &#39;B&#39;), (&#39;B&#39;, &#39;C&#39;), (&#39;C&#39;, &#39;A&#39;), (&#39;C&#39;, &#39;B&#39;), (&#39;C&#39;, &#39;C&#39;)]
</code></pre>

<ol>
<li><b>permutations</b></li>
</ol>

<p>permutations 用于生成一个排列，它的一般使用形式如下：</p>

<blockquote>
<p>permutations(iterable[, r])</p>
</blockquote>

<p>其中，r 指定生成排列的元素的长度，如果不指定，则默认为可迭代对象的元素长度。</p>

<pre><code class="language-python">from itertools import permutations
a = permutations(&#39;ABC&#39;, 2)
print(a)
b = list(permutations(&#39;ABC&#39;, 2))
print(b)
c = list(permutations(&#39;ABC&#39;))
print(c)
</code></pre>

<pre><code>&lt;itertools.permutations object at 0x000001F9171C7DB0&gt;
[(&#39;A&#39;, &#39;B&#39;), (&#39;A&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;A&#39;), (&#39;B&#39;, &#39;C&#39;), (&#39;C&#39;, &#39;A&#39;), (&#39;C&#39;, &#39;B&#39;)]
[(&#39;A&#39;, &#39;B&#39;, &#39;C&#39;), (&#39;A&#39;, &#39;C&#39;, &#39;B&#39;), (&#39;B&#39;, &#39;A&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;C&#39;, &#39;A&#39;), (&#39;C&#39;, &#39;A&#39;, &#39;B&#39;), (&#39;C&#39;, &#39;B&#39;, &#39;A&#39;)]
</code></pre>

<ol>
<li><b>combinations</b></li>
</ol>

<p>combinations 用于求序列的组合，它的使用形式如下：</p>

<blockquote>
<p>combinations(iterable, r)</p>
</blockquote>

<p>其中，r 指定生成组合的元素的长度。</p>

<pre><code class="language-python">from itertools import combinations
list(combinations(&#39;ABC&#39;, 2))
</code></pre>

<pre><code>[(&#39;A&#39;, &#39;B&#39;), (&#39;A&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;C&#39;)]
</code></pre>

<ol>
<li><b>combinations_with_replacement</b></li>
</ol>

<p>combinations_with_replacement 和 combinations 类似，但它生成的组合包含自身元素。</p>

<pre><code class="language-python">from itertools import combinations_with_replacement
list(combinations_with_replacement(&#39;ABC&#39;, 2))
</code></pre>

<pre><code>[(&#39;A&#39;, &#39;A&#39;), (&#39;A&#39;, &#39;B&#39;), (&#39;A&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;B&#39;), (&#39;B&#39;, &#39;C&#39;), (&#39;C&#39;, &#39;C&#39;)]
</code></pre>

<blockquote>
<p>转载自微信，仅供个人学习使用</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Modules - 02 - Python collections]]></title>
    <link href="https://sparkbye.github.io/myBlog/15662171970710.html"/>
    <updated>2019-08-19T20:19:57+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15662171970710.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">Module-1: collections 模块总结</h4>

<p>Python为我们提供了4种基本的数据结构：list, tuple, dict, set，但是在处理数据量较大的情形的时候，这4种数据结构就明显过于单一了，比如list作为单向链表在某些情形插入的效率会比较低，有时候我们也需要维护一个有序的dict。所以这个时候我们就要用到Python标准库为我们提供的collections包了，它提供了多个有用的集合类，熟练掌握这些集合类，不仅可以让我们让写出的代码更加Pythonic，也可以提高我们程序的运行效率。</p>

<ol>
<li><b>defaultdict的使用</b></li>
</ol>

<p>defaultdict(default_factory)在普通的dict(字典)之上添加了default_factory，使得key(键)不存在时会自动生成相应类型的value(值)，default_factory参数可以指定成list, set, int等各种合法类型。</p>

<pre><code class="language-python">from collections import defaultdict
s = [(&#39;red&#39;, 1), (&#39;blue&#39;, 2), (&#39;red&#39;, 3), (&#39;blue&#39;, 4), (&#39;red&#39;, 1), (&#39;blue&#39;, 4)]
</code></pre>

<p>我们现在有上面这样一组list(列表)，虽然我们有6组数据，但是仔细观察后发现其实我们只有两种color(颜色)，但是每一个color对应多个值。现在我们想要将这个list转换成一个dict(字典)，这个dict的key(键)对应一种color，dict的value(值)设置为一个list存放color对应的多个值。我们可以使用defaultdict(list)来解决这个问题。</p>

<pre><code class="language-python">d = defaultdict(list)
for k, v in s:
    d[k].append(v)
print(d)
</code></pre>

<pre><code>defaultdict(&lt;class &#39;list&#39;&gt;, {&#39;red&#39;: [1, 3, 1], &#39;blue&#39;: [2, 4, 4]})
</code></pre>

<p>上面这个例子中有一些不完美的地方，比如说{‘blue’: [2, 4, 4], ‘red’: [1, 3, 1]}这个defaultdict中blue颜色中包含两个4，red颜色中包含两个1，但是我们不希望含有重复的元素，这个时候可以考虑使用defaultdict(set)来解决这个问题。set(集合)相比list(列表)的不同之处在于set中不允许存在相同的元素。</p>

<pre><code class="language-python">d = defaultdict(set)
for k, v in s:
    d[k].add(v)
print(d) 
</code></pre>

<pre><code>defaultdict(&lt;class &#39;set&#39;&gt;, {&#39;red&#39;: {1, 3}, &#39;blue&#39;: {2, 4}})
</code></pre>

<p>通过使用defaultdict(int)的形式我们来统计一个字符串中每个字符出现的个数。</p>

<pre><code class="language-python">s = &#39;hello world&#39;
d = defaultdict(int)
for k in s:
    d[k] += 1
print(d)
</code></pre>

<pre><code>defaultdict(&lt;class &#39;int&#39;&gt;, {&#39;h&#39;: 1, &#39;e&#39;: 1, &#39;l&#39;: 3, &#39;o&#39;: 2, &#39; &#39;: 1, &#39;w&#39;: 1, &#39;r&#39;: 1, &#39;d&#39;: 1})
</code></pre>

<ol>
<li><b>OrderedDict的使用</b></li>
</ol>

<p>我们知道默认的dict(字典)是无序的，但是在某些情形我们需要保持dict的有序性，这个时候可以使用OrderedDict，它是dict的一个subclass(子类)，但是在dict的基础上保持了dict的有序型，下面我们来看一下使用方法。</p>

<pre><code class="language-python">from collections import OrderedDict
d = {&#39;banana&#39;: 3, &#39;apple&#39;: 4, &#39;pear&#39;: 1, &#39;orange&#39;: 2}
</code></pre>

<p>这是一个无序的dict(字典)，现在我们可以使用OrderedDict来让这个dict变得有序。</p>

<pre><code class="language-python"># 将d按照key来排序
a = OrderedDict(sorted(d.items(), key=lambda t: t[0]))
print(a)
# 将d按照value来排序
b = OrderedDict(sorted(d.items(), key=lambda t: t[1]))
print(b)
# 将d按照key的长度来排序
c = OrderedDict(sorted(d.items(), key=lambda t: len(t[0])))
print(c)
</code></pre>

<pre><code>OrderedDict([(&#39;apple&#39;, 4), (&#39;banana&#39;, 3), (&#39;orange&#39;, 2), (&#39;pear&#39;, 1)])
OrderedDict([(&#39;pear&#39;, 1), (&#39;orange&#39;, 2), (&#39;banana&#39;, 3), (&#39;apple&#39;, 4)])
OrderedDict([(&#39;pear&#39;, 1), (&#39;apple&#39;, 4), (&#39;banana&#39;, 3), (&#39;orange&#39;, 2)])
</code></pre>

<p>使用popitem(last=True)方法可以让我们按照LIFO(先进后出)的顺序删除dict中的key-value，即删除最后一个插入的键值对，如果last=False就按照FIFO(先进先出)删除dict中key-value。</p>

<pre><code class="language-python">d = {&#39;banana&#39;: 3, &#39;apple&#39;: 4, &#39;pear&#39;: 1, &#39;orange&#39;: 2}
# 将d按照key来排序
d = OrderedDict(sorted(d.items(), key=lambda t: t[0]))
print(d)
# 使用popitem()方法来移除最后一个key-value对
print(d.popitem())
# 使用popitem(last=False)来移除第一个key-value对
print(d.popitem(last=False))
</code></pre>

<pre><code>OrderedDict([(&#39;apple&#39;, 4), (&#39;banana&#39;, 3), (&#39;orange&#39;, 2), (&#39;pear&#39;, 1)])
(&#39;pear&#39;, 1)
(&#39;apple&#39;, 4)
</code></pre>

<p>使用move_to_end(key, last=True)来改变有序的OrderedDict对象的key-value顺序，通过这个方法我们可以将排序好的OrderedDict对象中的任意一个key-value插入到字典的开头或者结尾。</p>

<pre><code class="language-python">d = OrderedDict.fromkeys(&#39;abcde&#39;)
print(d)
# 将key为b的key-value对移动到dict的最后
d.move_to_end(&#39;b&#39;)
print(d)
print(&#39;&#39;.join(d.keys()))
# 将key为b的key-value对移动到dict的最前面
d.move_to_end(&#39;b&#39;, last=False)
print(&#39;&#39;.join(d.keys()))
</code></pre>

<pre><code>OrderedDict([(&#39;a&#39;, None), (&#39;b&#39;, None), (&#39;c&#39;, None), (&#39;d&#39;, None), (&#39;e&#39;, None)])
OrderedDict([(&#39;a&#39;, None), (&#39;c&#39;, None), (&#39;d&#39;, None), (&#39;e&#39;, None), (&#39;b&#39;, None)])
acdeb
bacde
</code></pre>

<ol>
<li><b>deque的使用</b></li>
</ol>

<p>list存储数据的优势在于按找索引查找元素会很快，但是插入和删除元素就很慢了，因为它是是单链表的数据结构。deque是为了高效实现插入和删除操作的双向列表，适合用于队列和栈，而且线程安全。</p>

<p>list只提供了append和pop方法来从list的尾部插入/删除元素，但是deque新增了appendleft/popleft允许我们高效的在元素的开头来插入/删除元素。而且使用deque在队列两端添加（append）或弹出（pop）元素的算法复杂度大约是O(1)，但是对于list对象改变列表长度和数据位置的操作例如 pop(0)和insert(0, v)操作的复杂度高达O(n)。由于对deque的操作和list基本一致，这里就不重复了。</p>

<pre><code class="language-python">from collections import deque
d1=deque()
d1.extend(&#39;abcdefg&#39;)
print(&#39;extend: %s&#39;% d1)
d1.append(&#39;h&#39;)
print(&#39;append: %s&#39;% d1)

d2=deque()
d2.extendleft(range(6))
print(&#39;extendleft: %s&#39;% d2)
d2.appendleft(6)
print(&#39;appendleft: %s&#39;% d2)
</code></pre>

<pre><code>extend: deque([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;])
append: deque([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;])
extendleft: deque([5, 4, 3, 2, 1, 0])
appendleft: deque([6, 5, 4, 3, 2, 1, 0])
</code></pre>

<p>从输出的结果，我们可以看到，append默认从集合的右边增加数组元素，而另一个appendleft可以从集合的左边增加元素</p>

<p>与append和appendleft方法对应的还有pop和popleft方法分别用于从集合中取出元素，看下面的例子:</p>

<pre><code class="language-python">print(&quot;From the right:&quot;)  
d = deque(&#39;abcdefg&#39;)  
while True:  
    try:  
        print(d.pop())
    except IndexError:  
        break  

print(&#39;\n From the left:&#39;)  
d = deque(range(6))  
while True:  
    try:  
        print(d.popleft())  
    except IndexError:  
        break  
</code></pre>

<pre><code>From the right:
g
f
e
d
c
b
a

 From the left:
0
1
2
3
4
5
</code></pre>

<p>最后值得一提的是，deque是线程安全的，也就是说你可以同时从deque集合的左边和右边进行操作而不会有影响，看下面的代码：</p>

<pre><code class="language-python">import collections  
import threading  
import time  
candle = collections.deque(range(5))  
def burn(direction,nextSource):  
    while True:  
        try:  
            next=nextSource()  
        except IndexError:  
            break  
        else:  
            print(&#39;%s : %s&#39; % (direction,next))  
            time.sleep(0.1)  
    print(&quot;done %s&quot; % direction)  
    return  

left=threading.Thread(target=burn,args=(&#39;left&#39;,candle.popleft))  
right=threading.Thread(target=burn,args=(&#39;right&#39;,candle.pop))  
  
left.start()  
right.start() 

left.join()  
right.join()
</code></pre>

<pre><code>left : 0
right : 4
left : 1
right : 3
left : 2
done right
done left
</code></pre>

<ol>
<li><b>ChainMap的使用</b></li>
</ol>

<p>ChainMap用来将多个dict(字典)组成一个list(只是比喻)，可以理解成合并多个字典，但和update不同，而且效率更高。  </p>

<pre><code class="language-python">from collections import ChainMap
a = {&quot;x&quot;:1, &quot;z&quot;:3}
b = {&quot;y&quot;:2, &quot;z&quot;:4}
# 构造一个ChainMap对象
m = ChainMap(a, b)
print(m)
print(&quot;x: {}, y: {}, z: {}&quot;.format(m[&quot;x&quot;], m[&quot;y&quot;], m[&quot;z&quot;]))

# 将m变成一个list
print(m.maps)

# ChainMap进行修改的时候总是只会对第一个字典进行修改
m[&quot;z&quot;] = 4
print(m)
m.pop(&#39;z&#39;)
print(m)

# 从m复制一个ChainMap对象，更新这个复制的对象并不会对m造成影响
m2 = m.new_child()
m2[&#39;z&#39;] = &#39;f&#39;
print(m[&#39;z&#39;])
print(m2.parents)
</code></pre>

<pre><code>ChainMap({&#39;x&#39;: 1, &#39;z&#39;: 3}, {&#39;y&#39;: 2, &#39;z&#39;: 4})
x: 1, y: 2, z: 3
[{&#39;x&#39;: 1, &#39;z&#39;: 3}, {&#39;y&#39;: 2, &#39;z&#39;: 4}]
ChainMap({&#39;x&#39;: 1, &#39;z&#39;: 4}, {&#39;y&#39;: 2, &#39;z&#39;: 4})
ChainMap({&#39;x&#39;: 1}, {&#39;y&#39;: 2, &#39;z&#39;: 4})
4
ChainMap({&#39;x&#39;: 1}, {&#39;y&#39;: 2, &#39;z&#39;: 4})
</code></pre>

<p>从原理上面讲，ChainMap实际上是把放入的字典存储在一个队列中，当进行字典的增加删除等操作只会在第一个字典上进行，当进行查找的时候会依次查找，new_child()方法实质上是在列表的第一个元素前放入一个字典，默认是{}，而parents是去掉了列表开头的元素。也正是因为底层是列表实现的，所以实际上ChainMap查询的字典实际上还是原来的字典的引用</p>

<pre><code class="language-python">a = {&quot;x&quot;:1, &quot;z&quot;:3}
b = {&quot;y&quot;:2, &quot;z&quot;:4}
c = ChainMap(a,b)
print(c)
print(c.maps)
print(c.parents)
print(c.parents.maps)
print(c.parents.parents)
</code></pre>

<pre><code>ChainMap({&#39;x&#39;: 1, &#39;z&#39;: 3}, {&#39;y&#39;: 2, &#39;z&#39;: 4})
[{&#39;x&#39;: 1, &#39;z&#39;: 3}, {&#39;y&#39;: 2, &#39;z&#39;: 4}]
ChainMap({&#39;y&#39;: 2, &#39;z&#39;: 4})
[{&#39;y&#39;: 2, &#39;z&#39;: 4}]
ChainMap({})
</code></pre>

<ol>
<li><b>Counter的使用</b></li>
</ol>

<p>Counter也是dict的一个subclass，它是一个无序容器，可以看做一个计数器，用来统计相关元素出现的个数。</p>

<pre><code class="language-python">from collections import Counter
cnt = Counter()
# 统计列表中元素出现的个数
for word in [&#39;red&#39;, &#39;blue&#39;, &#39;red&#39;, &#39;green&#39;, &#39;blue&#39;, &#39;blue&#39;]:
    cnt[word] += 1
print(cnt)

# 统计字符串中元素出现的个数
cnt = Counter()
for ch in &#39;hello&#39;:
    cnt[ch] = cnt[ch] + 1
print(cnt)
</code></pre>

<pre><code>Counter({&#39;blue&#39;: 3, &#39;red&#39;: 2, &#39;green&#39;: 1})
Counter({&#39;l&#39;: 2, &#39;h&#39;: 1, &#39;e&#39;: 1, &#39;o&#39;: 1})
</code></pre>

<p>使用elements()方法按照元素的出现次数返回一个iterator(迭代器)，元素以任意的顺序返回，如果元素的计数小于1，将忽略它。</p>

<pre><code class="language-python">c = Counter(a=4, b=2, c=0, d=-2)
print(c)
d = c.elements()
print(next(d))
print(sorted(c.elements()))
</code></pre>

<pre><code>Counter({&#39;a&#39;: 4, &#39;b&#39;: 2, &#39;c&#39;: 0, &#39;d&#39;: -2})
a
[&#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;]
</code></pre>

<p>使用most_common(n)返回一个list, list中包含Counter对象中出现最多前n个元素。</p>

<pre><code class="language-python">c = Counter(&#39;abracadabra&#39;)
print(c)
print(c.most_common(3))
</code></pre>

<pre><code>Counter({&#39;a&#39;: 5, &#39;b&#39;: 2, &#39;r&#39;: 2, &#39;c&#39;: 1, &#39;d&#39;: 1})
[(&#39;a&#39;, 5), (&#39;b&#39;, 2), (&#39;r&#39;, 2)]
</code></pre>

<ol>
<li><b>namedtuple的使用</b></li>
</ol>

<p>Python中存储系列数据，比较常见的数据类型有list，除此之外，还有tuple数据类型。相比与list，tuple中的元素不可修改，在映射中可以当键使用。tuple元组的item只能通过index访问，collections模块的namedtuple子类不仅可以使用item的index访问item，还可以通过item的name进行访问。可以将namedtuple理解为c中的struct结构，其首先将各个item命名，然后对每个item赋予数据。<br/><br/>
使用namedtuple(typename, field_names)命名tuple中的元素来使程序更具可读性。</p>

<pre><code class="language-python">from collections import namedtuple
Point = namedtuple(&#39;PointExtension&#39;, [&#39;x&#39;, &#39;y&#39;])
p = Point(1, 2)
print(p.__class__.__name__)
print(p.x)
print(p.y)
</code></pre>

<pre><code>PointExtension
1
2
</code></pre>

<pre><code class="language-python">from collections import namedtuple  
  
websites = [  
    (&#39;Sohu&#39;, &#39;http://www.sohu.com/&#39;, u&#39;Zhang Chaoyang&#39;),  
    (&#39;Sina&#39;, &#39;http://www.sina.com.cn/&#39;, u&#39;Wang Zhidong&#39;),  
    (&#39;163&#39;, &#39;http://www.163.com/&#39;, u&#39;Ding Lei&#39;)  
]  
  
Website = namedtuple(&#39;Website&#39;, [&#39;name&#39;, &#39;url&#39;, &#39;founder&#39;])
  
for website in websites:  
    website = Website._make(website)  
    print(website)
    print(website.name)
</code></pre>

<pre><code>Website(name=&#39;Sohu&#39;, url=&#39;http://www.sohu.com/&#39;, founder=&#39;Zhang Chaoyang&#39;)
Sohu
Website(name=&#39;Sina&#39;, url=&#39;http://www.sina.com.cn/&#39;, founder=&#39;Wang Zhidong&#39;)
Sina
Website(name=&#39;163&#39;, url=&#39;http://www.163.com/&#39;, founder=&#39;Ding Lei&#39;)
163
</code></pre>

<blockquote>
<p>转载自微信，仅供个人学习使用</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Modules - 01 - Python random]]></title>
    <link href="https://sparkbye.github.io/myBlog/15662171354673.html"/>
    <updated>2019-08-19T20:18:55+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15662171354673.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">Module-1: random 模块总结</h4>

<p>Python中的random模块用于生成随机数。下面介绍一下random模块中最常用的几个函数。</p>

<pre><code class="language-python">import random
</code></pre>

<ol>
<li><b>random.random</b></li>
</ol>

<p>random.random()用于生成一个0到1的随机符点数: 0 &lt;= n &lt; 1.0</p>

<pre><code class="language-python">a = random.random()
print(a)
</code></pre>

<pre><code>0.6898048215526792
</code></pre>

<ol>
<li><b>random.uniform</b></li>
</ol>

<p>random.uniform的函数原型为：random.uniform(a, b)，用于生成一个指定范围内的随机符点数，两个参数其中一个是上限，一个是下限。如果a &gt; b，则生成的随机数n: b &lt;= n &lt;= a。如果 a &lt;b， 则 a &lt;= n &lt;= b。</p>

<pre><code class="language-python">a = random.uniform(1000, 18888)
print(a)
b = random.uniform(1000, 18888)
print(b)
</code></pre>

<pre><code>8052.755100232027
2137.3131503870227
</code></pre>

<ol>
<li><b>random.randint</b></li>
</ol>

<p>random.randint()的函数原型为：random.randint(a, b)，用于生成一个指定范围内的整数。其中参数a是下限，参数b是上限，生成的随机数n: a &lt;= n &lt;= b</p>

<pre><code class="language-python">a = random.randint(10, 20)
print(a)
</code></pre>

<pre><code>18
</code></pre>

<ol>
<li><b>random.randrange</b></li>
</ol>

<p>random.randrange的函数原型为：random.randrange(start, stop, step)，从指定范围内，按指定基数递增的集合中获取一个随机数。   </p>

<pre><code class="language-python">a = random.randrange(10, 20, 3)         #在[10，13， 16， 19]中选择
print(a)
</code></pre>

<pre><code>10
</code></pre>

<ol>
<li><b>random.choice</b></li>
</ol>

<p>random.choice从序列中获取一个随机元素。其函数原型为：random.choice(sequence)，参数sequence表示一个有序类型。<br/><br/>
这里要说明 一下：sequence在python不是一种特定的类型，而是泛指一系列的类型。list, tuple, 字符串都属于sequence。</p>

<pre><code class="language-python">a = &quot;mylittlepolly&quot;
print(random.choice(a))
b = [&#39;sun&#39;, &#39;moon&#39;, &#39;star&#39;]
print(random.choice(b))
</code></pre>

<pre><code>l
moon
</code></pre>

<ol>
<li><b>random.shuffle</b></li>
</ol>

<p>random.shuffle的函数原型为：random.shuffle(x[, random])，用于将一个列表中的元素打乱。</p>

<pre><code class="language-python">a = [&quot;Python&quot;, &quot;is&quot;, &quot;powerful&quot;, &quot;simple&quot;, &quot;and so on...&quot;]
random.shuffle(a)
print(a)
</code></pre>

<pre><code>[&#39;and so on...&#39;, &#39;simple&#39;, &#39;powerful&#39;, &#39;Python&#39;, &#39;is&#39;]
</code></pre>

<ol>
<li><b>random.sample</b></li>
</ol>

<p>random.sample的函数原型为：random.sample(sequence, k)，从指定序列中随机获取指定长度的片断。sample函数不会修改原有序列。</p>

<pre><code class="language-python">a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
b = random.sample(a, 5)
print(b)
</code></pre>

<pre><code>[9, 8, 1, 7, 3]
</code></pre>

<blockquote>
<p>转载自微信，仅供个人学习使用</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python常见的错误<十六>]]></title>
    <link href="https://sparkbye.github.io/myBlog/15662167164116.html"/>
    <updated>2019-08-19T20:11:56+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15662167164116.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">常见错误16: Python 特殊方法</h4>

<p>我写了一个通过重载 <b> new </b> 方法来实现单例模式的类。</p>

<pre><code class="language-python">class Singleton(object):
    _instance = None
    def __new__(cls, *args, **kwargs):
        if cls._instance:
            return cls._instance
        cls._isntance = cv = object.__new__(cls, *args, **kwargs)
        return cv
</code></pre>

<pre><code class="language-python">sin1 = Singleton()
sin2 = Singleton()
print(sin1 is sin2)
</code></pre>

<pre><code>False
</code></pre>

<p>现在我有一堆类要实现为单例模式，所以我打算照葫芦画瓢写一个<b>元类</b>，这样可以让代码复用：</p>

<pre><code class="language-python">class SingleMeta(type):
    def __init__(cls, name, bases, dict):
        cls._instance = None
        __new__o = cls.__new__
        def __new__(cls, *args, **kwargs):
            if cls._instance:
                return cls._instance
        cls._instance = cv = __new__o(cls, *args, **kwargs)
        return cv
    
    cls.__new__ = __new__
    
class A(object):
    __metaclass__ = SingleMeta

a1 = A()
</code></pre>

<pre><code>---------------------------------------------------------------------------

NameError                                 Traceback (most recent call last)

&lt;ipython-input-12-f4e661bbbe74&gt; in &lt;module&gt;
----&gt; 1 class SingleMeta(type):
      2     def __init__(cls, name, bases, dict):
      3         cls._instance = None
      4         __new__o = cls.__new__
      5         def __new__(cls, *args, **kwargs):


&lt;ipython-input-12-f4e661bbbe74&gt; in SingleMeta()
      9         return cv
     10 
---&gt; 11     cls.__new__ = __new__
     12 
     13 class A(object):


NameError: name &#39;__new__&#39; is not defined
</code></pre>

<p>哎呀，好气啊，为啥这会报错啊，我明明之前用这种方法给 <strong>getattribute</strong> 打补丁的，下面这段代码能够捕获一切属性调用并打印参数</p>

<pre><code class="language-python">class TraceAttribute(type):
    def __init__(cls, name, bases, dict):
        __getattribute__o = cls.__getattribute__
        def __getattribute__(self, *args, **kwargs):
            print(&#39;__getattribute__:&#39;, args, kwargs)
            return __getattribute__o(self, *args, **kwargs)
        cls.__getattribute__ = __getattribute__

class A(object):
    __metaclass__ = TraceAttribute
    a = 1
    b = 2

a = A()
print(a.a)
print(a.b)
</code></pre>

<pre><code>1
2
</code></pre>

<p>试解释为什么给 <b> getattribute </b> 打补丁成功，而 <b> new </b> 打补丁失败。 如果我坚持使用元类给 <b> new </b> 打补丁来实现单例模式，应该怎么修改？ </p>

<p>其实这是最气人的一点，类里的 <strong>new</strong> 是一个 staticmethod 因此替换的时候必须以 staticmethod 进行替换。答案如下：</p>

<pre><code class="language-python">class SingleMeta(type):
    def __init__(cls, name, bases, dict):
        cls._instance = None
        __new__o = cls.__new__
    
        @staticmethod
        def __new__(cls, *args, **kwargs):
            if cls._instance:
                return cls._instance
            cls._instance = cv = __new__o(cls, *args, **kwargs)
            return cv
        cls.__new__ = __new__
    
class A(object):
    __metaclass__ = SingleMeta

print(A() is A())
</code></pre>

<pre><code>False
</code></pre>

<blockquote>
<p>转载自微信，仅供个人学习使用</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python常见的错误<十五>]]></title>
    <link href="https://sparkbye.github.io/myBlog/15662166109209.html"/>
    <updated>2019-08-19T20:10:10+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15662166109209.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">常见错误15: 描述符的坑</h4>

<p>我想写一个 Exam 类，其属性 math 为 [0,100] 的整数，若赋值时不在此范围内则抛出异常，我决定用描述符来实现这个需求。</p>

<pre><code class="language-python">class Grade(object):
    def __init__(self):
        self._score = 0
    def __get__(self, instance, owner):
        return self._score
    def __set__(self, instance, value):
        if 0 &lt;= value &lt;= 100:
            self._score = value
        else:
            raise ValueError(&#39;grade must be between 0 and 100.&#39;)
</code></pre>

<pre><code class="language-python">class Exam(object):
    math = Grade()
    def __init__(self, math):
        self.math = math
</code></pre>

<pre><code class="language-python">lucy = Exam(math=90)
print(lucy.math)
snake = Exam(math=75)
print(snake.math)
snake.math = 120
</code></pre>

<pre><code>90
75



---------------------------------------------------------------------------

ValueError                                Traceback (most recent call last)

&lt;ipython-input-9-d59603acfa1c&gt; in &lt;module&gt;
      3 snake = Exam(math=75)
      4 print(snake.math)
----&gt; 5 snake.math = 120


&lt;ipython-input-7-edf3703e2b81&gt; in __set__(self, instance, value)
      8             self._score = value
      9         else:
---&gt; 10             raise ValueError(&#39;grade must be between 0 and 100.&#39;)


ValueError: grade must be between 0 and 100.
</code></pre>

<p>看起来一切正常。不过这里面有个巨大的问题，尝试说明是什么问题？<br/><br/>
为了解决这个问题，我改写了 Grade 描述符如下：<br/><br/>
不过这样会导致更大的问题，请问该怎么解决这个问题？</p>

<pre><code class="language-python">class Gradee(object):
    def __init__(self):
        self._grade_pool = {}
    def __get__(self, instance, owner):
        return self._grade_pool.get(instance, None)
    def __set__(self, instance, value):
        if 0 &lt;= value &lt;= 100:
            _grade_pool = self.__dict__.setdefault(&#39;_grade_pool&#39;, {})
            _grade_pool[instance] = value
        else:
            raise ValueError(&#39;fuuuuuuuuuck!!&#39;)
</code></pre>

<pre><code class="language-python">class Exam(object):
    grammer = Gradee()
    def __init__(self, grammer):
        self.grammer = grammer
</code></pre>

<pre><code class="language-python">lucy = Exam(grammer=90)
print(lucy.grammer)
snake = Exam(grammer=75)
print(snake.grammer)
snake.grammer = 120
</code></pre>

<pre><code>90
75



---------------------------------------------------------------------------

ValueError                                Traceback (most recent call last)

&lt;ipython-input-12-1302d1b3a522&gt; in &lt;module&gt;
      3 snake = Exam(grammer=75)
      4 print(snake.grammer)
----&gt; 5 snake.grammer = 120


&lt;ipython-input-10-aa15607fb158&gt; in __set__(self, instance, value)
      9             _grade_pool[instance] = value
     10         else:
---&gt; 11             raise ValueError(&#39;fuuuuuuuuuck!!&#39;)


ValueError: fuuuuuuuuuck!!
</code></pre>

<ol>
<li><p>第一个问题的其实很简单，如果你再运行一次 print ( lucy.math ) 你就会发现，输出值是 75 ，那么这是为什么呢？这就要先从 Python 的调用机制说起了。<br/><br/>
我们如果调用一个属性，那么其顺序是优先从实例的 __dict__ 里查找，然后如果没有查找到的话，那么一次查询类字典，父类字典，直到彻底查不到为止。<br/><br/>
好的，现在回到我们的问题。<br/><br/>
我们发现，在我们的类 Exam 中，其 self.math 的调用过程是，首先在实例化后的实例的 __dict__ 中进行查找，没有找到，接着往上一级，在我们的类 Exam 中进行查找，好的找到了，返回。<br/><br/>
那么这意味着，我们对于 self.math 的所有操作都是对于类变量 math 的操作。因此造成变量污染的问题。那么该则怎么解决呢？<br/><br/>
很多同志可能会说，恩，在 __set__ 函数中将值设置到具体的实例字典不就行了。<br/><br/>
那么这样可不可以呢？<br/><br/>
答案是，很明显不得行啊，至于为什么，就涉及到我们 Python 描述符的机制了，描述符指的是实现了描述符协议的特殊的类，三个描述符协议指的是 __get__ , __set__ , __delete__ 以及 Python 3.6 中新增的 __set_name__ 方法，其中实现了__get__ 以及 __set__ / __delete__ / __set_name__ 的是 <b>Data descriptors</b> ，而只实现了 __get__ 的是 <b>Non-Data descriptor</b> 。<br/><br/>
那么有什么区别呢，前面说了， <b>我们如果调用一个属性，那么其顺序是优先从实例的 <strong>dict</strong> 里查找，然后如果没有查找到的话，那么一次查询类字典，父类字典，直到彻底查不到为止。</b><br/><br/>
但是，这里没有考虑描述符的因素进去，如果将描述符因素考虑进去，那么正确的表述应该是我们如果调用一个属性，那么其顺序是优先从实例的 __dict__ 里查找，然后如果没有查找到的话，那么一次查询类字典，父类字典，直到彻底查不到为止。其中如果在类实例字典中的该属性是一个 Data descriptors ，那么无论实例字典中存在该属性与否，无条件走描述符协议进行调用，在类实例字典中的该属性是一个 Non - Data descriptors ，那么优先调用实例字典中的属性值而不触发描述符协议，如果实例字典中不存在该属性值，那么触发 Non - Data descriptor 的描述符协议。回到之前的问题，我们即使在 __set__ 将具体的属性写入实例字典中，但是由于类字典中存在着 Data descriptors，因此，我们在调用 math 属性时，依旧会触发描述符协议。</p></li>
<li><p>经过改良的做法，利用 dict 的 key 唯一性，将具体的值与实例进行绑定，但是同时带来了内存泄露的问题。<br/><br/>
那么为什么会造成内存泄露呢，首先复习下我们的 dict 的特性， dict 最重要的一个特性，就是凡可 hash 的对象皆可为 key ， dict 通过利用的 hash 值的唯一性（严格意义上来讲并不是唯一，而是其 hash 值碰撞几率极小，近似认定其唯一）来保证 key 的不重复性。<br/><br/>
同时（敲黑板，重点来了），<br/><br/>
dict 中的 key 引用是强引用类型，会造成对应对象的引用计数的增加，可能造成对象无法被 gc ，从而产生内存泄露。<br/><br/>
那么这里该怎么解决呢？两种方法 第一种：  </p></li>
</ol>

<pre><code class="language-python">class Grad(object):
    def __init__(self):
        import weakref
        self._grade_pool = weakref.WeakKeyDictionary()
    def __get__(self, instance, owner):
        return self._grade_pool.get(instance, None)
    def __set__(self, instance, value):
        if 0 &lt;= value &lt;= 100:
            _grade_pool = self.__dict__.setdefault(&#39;_grade_pool&#39;, {})
            _grade_pool[instance] = value
        else:
            raise ValueError(&#39;fuuuuuuuuuck!!&#39;)
</code></pre>

<p>weakref 库中的 WeakKeyDictionary 所产生的字典的 key 对于对象的引用是弱引用类型，其不会造成内存引用计数的增加，因此不会造成内存泄露。<br/><br/>
同理，如果我们为了避免 value 对于对象的强引用，我们可以使用 WeakValueDictionary 。 </p>

<p>第二种：在 Python 3.6 中，实现的 PEP 487 提案，为描述符新增加了一个协议，我们可以用其来绑定对应的对象：</p>

<pre><code class="language-python">class Grad(object):
    def __get__(self, instance, owner):
        return instance.__dict__[self.key]
    def __set__(self, instance, value):
        if 0 &lt;= value &lt;= 100:
            instance.__dict__[self.key] = value
        else:
            raise ValueError(&#39;fuuuuuuuuuck!!&#39;)
    def __set_name__(self, owner, name):
        self.key = name
</code></pre>

<p>这道题涉及的东西比较多，这里给出一点参考链接， invoking-descriptors , Descriptor HowTo Guide , PEP 487 , what`s new in Python 3.6 。</p>

<blockquote>
<p>转载自微信，仅供个人学习使用</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python常见的错误<十四>]]></title>
    <link href="https://sparkbye.github.io/myBlog/15662165783528.html"/>
    <updated>2019-08-19T20:09:38+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15662165783528.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">常见错误14: Python 调用机制</h4>

<p>我们知道 __call__ 方法可以用来重载圆括号调用，好的，以为问题就这么简单？ Naive ！</p>

<pre><code class="language-python">class A(object):
    def __call__(self):
        print(&quot;invoking __call__ from A!&quot;)
</code></pre>

<pre><code class="language-python">a = A()
a()
</code></pre>

<pre><code>invoking __call__ from A!
</code></pre>

<p>现在我们可以看到 a() 似乎等价于 a.__call__() ,看起来很 Easy 对吧，好的，我现在想作死，又写出了如下的代码:</p>

<pre><code class="language-python">a.__call__ = lambda: &quot;invoking __call__ from lambda&quot;
print(a.__call__())
a()
</code></pre>

<pre><code>invoking __call__ from lambda
invoking __call__ from A!
</code></pre>

<p>为什么 a() 没有调用出 a.__call__()</p>

<p>原因在于，在 Python 中，新式类（ new class  )的内建特殊方法，和实例的属性字典是相互隔离的，具体可以看看 Python 官方文档对于这一情况的说明:</p>

<blockquote>
<p>For new - style classes , implicit invocations of special methods are only guaranteed to work correctly if defined on an object &#39; s type , not in the object &#39; s instance dictionary. <br/>
That behaviour is the reason why the following code raises an exception  ( unlike the equivalent example with old - style classes ):</p>
</blockquote>

<p>同时官方也给出了一个例子：</p>

<pre><code class="language-python">class C(object):
    pass

c = C()
c.__len__ = lambda: 5
len(c)
</code></pre>

<pre><code>---------------------------------------------------------------------------

TypeError                                 Traceback (most recent call last)

&lt;ipython-input-4-7039f902a29c&gt; in &lt;module&gt;
      4 c = C()
      5 c.__len__ = lambda: 5
----&gt; 6 len(c)


TypeError: object of type &#39;C&#39; has no len()
</code></pre>

<pre><code class="language-python">c.__len__()
</code></pre>

<pre><code>5
</code></pre>

<p>回到我们的例子上来，当我们在执行 a.__call__ = lambda :&quot; invoking __call__ from lambda &quot; 时，的确在我们在 a.__dict__ 中新增加了一个 key 为 __call__ 的 item ，但是当我们执行 a () 时，因为涉及特殊方法的调用，因此我们的调用过程不会从 a.__dict__ 中寻找属性，而是从 tyee ( a ). __dict__ 中寻找属性。因此，就会出现如上所述的情况。</p>

<blockquote>
<p>转载自微信，仅供个人学习使用</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python常见的错误<十三>]]></title>
    <link href="https://sparkbye.github.io/myBlog/15662165446488.html"/>
    <updated>2019-08-19T20:09:04+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15662165446488.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">常见错误13: 装饰器</h4>

<p>我想写一个类装饰器用来度量函数/方法运行时间：</p>

<pre><code class="language-python">import time

class Timeit(object):
    def __init__(self, func):
        self._wrapped = func
    
    def __call__(self, *args, **kws):
        start_time = time.time()
        result = self._wrapped(*args, **kws)
        print(&quot;elapsed time is %s &quot; % (time.time() - start_time))
        return result
</code></pre>

<p>希望这个装饰器能够运行在普通函数上：</p>

<pre><code class="language-python">@Timeit
def func():
    time.sleep(1)
    return &quot;invoking function func&quot;
</code></pre>

<p>这个装饰器能够运行在普通函数上：</p>

<pre><code class="language-python">func()
</code></pre>

<pre><code>elapsed time is 1.0005531311035156 





&#39;invoking function func&#39;
</code></pre>

<p>但是运行在方法上会报错，为什么？</p>

<pre><code class="language-python">class A(object):
    @Timeit
    def func(self):
        time.sleep(1)
        return &#39;invoking method func&#39;
</code></pre>

<pre><code class="language-python">a = A()
a.func()
</code></pre>

<pre><code>---------------------------------------------------------------------------

TypeError                                 Traceback (most recent call last)

&lt;ipython-input-27-27f4a5f7197a&gt; in &lt;module&gt;
      1 a = A()
----&gt; 2 a.func()


&lt;ipython-input-25-0a38ed0ff6ce&gt; in __call__(self, *args, **kws)
      7     def __call__(self, *args, **kws):
      8         start_time = time.time()
----&gt; 9         result = self._wrapped(*args, **kws)
     10         print(&quot;elapsed time is %s &quot; % (time.time() - start_time))
     11         return result


TypeError: func() missing 1 required positional argument: &#39;self&#39;
</code></pre>

<p>使用类装饰器后，在调用 func 函数的过程中其对应的 instance 并不会传递给 __call__ 方法，造成其 mehtod unbound ,那么解决方法是什么呢？</p>

<pre><code class="language-python">class Timeite(object):
    def __init__(self, func):
        self.func = func
    def __call__(self, *args, **kws):
        print(&#39;invoking Timer&#39;)
    def __get__(self, instance, owner):
        return lambda *args, **kws: self.func(instance, *args, **kws)
</code></pre>

<pre><code class="language-python">class A(object):
    @Timeite
    def func(self):
        time.sleep(1)
        return &#39;invoking method func&#39;
    
a = A()
a.func()
</code></pre>

<pre><code>&#39;invoking method func&#39;
</code></pre>

<blockquote>
<p>转载自微信，仅供个人学习使用</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python常见的错误<十二>]]></title>
    <link href="https://sparkbye.github.io/myBlog/15657075853367.html"/>
    <updated>2019-08-13T22:46:25+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15657075853367.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">常见错误12: 链式赋值的坑</h4>

<p>在我们使用Python的过程中, 经常遇到赋值语句, 就像下面的那样:<br/><br/>
a = 3<br/><br/>
b = 3<br/><br/>
而链式赋值是同时对几个变量进行赋值，如：<br/><br/>
a = b = c = 3<br/><br/>
我们来看看这段代码输出的是什么？</p>

<pre><code class="language-python">s = [1, 2, 3, 4, 5, 6]
i = 0
i = s[i] = 3
print(i)
print(s)
</code></pre>

<pre><code>3
[1, 2, 3, 3, 5, 6]
</code></pre>

<p>i 的值: 3<br/><br/>
---这个好解释<br/><br/>
s 的值: [1, 2, 3, 3, 5, 6]<br/><br/>
？？？<br/><br/>
s的列表, 并没有像我们想象中的那样, 就i=0位置上的元素, 变成3, 而是将i=3位置的元素改成3了, 为什么会这样? 一起来解析下吧, 上dis大杀器!</p>

<pre><code class="language-python">def test():
    s = [1, 2, 3, 4, 5, 6] 
    i = 0
    i = s[i] = 3
    print(i)
    print(s)

import dis
dis.dis(test)
</code></pre>

<pre><code>  2           0 LOAD_CONST               1 (1)
              2 LOAD_CONST               2 (2)
              4 LOAD_CONST               3 (3)
              6 LOAD_CONST               4 (4)
              8 LOAD_CONST               5 (5)
             10 LOAD_CONST               6 (6)
             12 BUILD_LIST               6
             14 STORE_FAST               0 (s)

  3          16 LOAD_CONST               7 (0)
             18 STORE_FAST               1 (i)

  4          20 LOAD_CONST               3 (3)
             22 DUP_TOP
             24 STORE_FAST               1 (i)
             26 LOAD_FAST                0 (s)
             28 LOAD_FAST                1 (i)
             30 STORE_SUBSCR

  5          32 LOAD_GLOBAL              0 (print)
             34 LOAD_FAST                1 (i)
             36 CALL_FUNCTION            1
             38 POP_TOP

  6          40 LOAD_GLOBAL              0 (print)
             42 LOAD_FAST                0 (s)
             44 CALL_FUNCTION            1
             46 POP_TOP
             48 LOAD_CONST               0 (None)
             50 RETURN_VALUE
</code></pre>

<p>解释如下：<br/><br/>
第一列的数字, 代表中间的字节码是属于哪一行代码的.<br/><br/>
第1~2行简单解释下:<br/><br/>
分别LOAD_CONST5个数字, 组成一个列表, 赋值给s,再取一个0, 赋值给i.接下来的就是我们关心的, 也是带给我们意外的代码.<br/><br/>
第3行:<br/><br/>
LOAD_CONST取出常量3, 它并不是像上面执行STORE_NAME, 而是采用DUP_TOP, 这是什么鬼, 我们这要去看下这指令具体是干嘛的:<br/><br/>
//取自 python/ceval.c <br/>
PyEval_EvalFrameEx(PyFrameObject *f, int throwflag)<br/><br/>
{<br/>
        ... (省略)<br/><br/>
        TARGET_NOARG(DUP_TOP)<br/><br/>
        {<br/><br/>
            v = TOP();    // 复制运行栈帧的顶部值<br/><br/>
            Py_INCREF(v); // 增加引用计数<br/><br/>
            PUSH(v);      // 再压入运行栈帧<br/><br/>
            FAST_DISPATCH();<br/><br/>
        }<br/><br/>
        ... (省略)<br/><br/>
}<br/><br/>
DUP_TOP指令说白了, 就是将刚才LOAD_CONST指令取出的常量3, 复制一份给v,然后再压回去运行栈帧, 这样就有两个3了, 为什么要这么做, 可能个大家已经猜到了, 不过我们还是得继续看具体是不是像我们想的那样, 继续看会字节码:<br/>
             24 STORE_FAST               1 (i)<br/>
             26 LOAD_FAST                0 (s)<br/>
             28 LOAD_FAST                1 (i)<br/>
             30 STORE_SUBSCR<br/>
果然不出我们所料, 开始将这些3通过STORE_NAME赋值给i, 而对于s, 它反而是, 再一次LOAD_NAME取出i的值, 此时i的值是3, 不是一开始的0了, 在通过STORE_SUBSCR指令, 将刚才压入运行时时栈的3赋值给位置是3的元素, 具体的源码就不再看, 到这就够了.</p>

<p>所以看到这, 相信大家都能清楚, 为什么结果是 [1, 2, 3, 3, 5, 6]<br/><br/>
这跟我们想象中的链式赋值很不同, 我们以前总是觉得, 赋值要从右到左依次执行, 先执行 s[i] = 3, 再执行 i=3, 然而这些是类似c语言这类支持表达式赋值才允许的. 在c语言中, s = 3表达式是有返回值的. 它会返回赋值的结果3, 所以在它们的链式赋值中, 是将右边表达式的返回值, 再赋值给左边的, 例如:  </p>

<p>a = s = 3<br/><br/>
等价于:<br/><br/>
a = (s = 3)<br/><br/>
也就是 s=3 返回3, 再赋值给a  </p>

<p>而在python是不支持这种表达式赋值的, 也就是表达式是没有返回值的, 如果硬要a = (s = 3)只会触发SyntaxError: invalid syntax<br/><br/>
希望大家以后在用到这种链式赋值时, 尽量避免这些问题哦.</p>

<p>支持表达式赋值是Python语言的核心，比如a = b + 3。这里的 b + 3 就是表达式。如果不支持表达式赋值就没法继续下去了。<br/><br/>
a = (s = 3)出错的原因是因为s = 3是赋值语句，而不是表达式。<br/><br/>
Python的表达式是由操作符连接而成的，但“=”在Python中并不是操作符（Operator），只是语法分隔符（Delimiters）。<br/><br/>
参见：<a href="https://docs.python.org/release/3.6.1/reference/lexical_analysis.html">https://docs.python.org/release/3.6.1/reference/lexical_analysis.html</a>  </p>

<blockquote>
<p>转载自微信，仅供个人学习使用</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python常见的错误<十一>]]></title>
    <link href="https://sparkbye.github.io/myBlog/15657061085965.html"/>
    <updated>2019-08-13T22:21:48+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15657061085965.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">常见错误11: 列表的缺陷</h4>

<p>来看看下面代码的输出结果将是什么？</p>

<pre><code class="language-python">list = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]
print(list[10:])
print(list[10])
</code></pre>

<pre><code>[]



---------------------------------------------------------------------------

IndexError                                Traceback (most recent call last)

&lt;ipython-input-5-7b4a48b0e416&gt; in &lt;module&gt;
      1 list = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]
      2 print(list[10:])
----&gt; 3 print(list[10])


IndexError: list index out of range
</code></pre>

<p>上面的代码将输出[]，不会产生IndexError错误。就像所期望的那样，尝试用超出成员的个数的index来获取某个列表的成员。<br/><br/>
例如，尝试获取list[10]和之后的成员，会导致IndexError。<br/><br/>
然而，尝试获取列表的切片，开始的index超过了成员个数不会产生IndexError,而是仅仅返回一个空列表。<br/><br/>
这成为特别让人恶心的疑难杂症，因为运行的时候没有错误产生，导致bug很难被追踪到。 </p>

<p>我们再来看看这段代码，猜想一下，输出是什么？</p>

<pre><code class="language-python">list = [ [ ] ] * 5
print(list)  # output?
list[0].append(10)
print(list)  # output?
list[1].append(20)
print(list)   # output?
list.append(30)
print(list)   # output?
</code></pre>

<pre><code>[[], [], [], [], []]
[[10], [10], [10], [10], [10]]
[[10, 20], [10, 20], [10, 20], [10, 20], [10, 20]]
[[10, 20], [10, 20], [10, 20], [10, 20], [10, 20], 30]
</code></pre>

<p>解释如下：<br/><br/>
第一行的输出结果直觉上很容易理解，例如 list = [ [ ] ] * 5 就是简单的创造了5个空列表。<br/><br/>
然而，理解表达式list=[ [ ] ] * 5的关键一点是它不是创造一个包含五个独立列表的列表，而是它是一个<b>创建了包含对同一个列表五次引用的列表。</b><br/><br/>
只有了解了这一点，我们才能更好的理解接下来的输出结果。<br/><br/>
list[0].append(10) 将10附加在第一个列表上。<br/>
但由于所有5个列表是引用的同一个列表，所以这个结果将是：<br/><br/>
[[10], [10], [10], [10], [10]]。<br/><br/>
同理，list[1].append(20)将20附加在第二个列表上。但同样由于5个列表是引用的同一个列表，所以输出结果现在是：<br/><br/>
[[10, 20], [10, 20], [10, 20], [10, 20], [10, 20]]<br/><br/>
作为对比， list.append(30)是将整个新的元素附加在外列表上，因此产生的结果是：[[10, 20], [10, 20], [10, 20], [10, 20], [10, 20], 30]。</p>

<blockquote>
<p>转载自微信，仅供个人学习使用</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python常见的错误<十>]]></title>
    <link href="https://sparkbye.github.io/myBlog/15656215590319.html"/>
    <updated>2019-08-12T22:52:39+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15656215590319.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">常见错误10: 浮点与整除</h4>

<p>下面这段代码在Python2下输出结果将是什么？请解释。</p>

<pre><code class="language-python">def div1(x,y):
    print(&quot;%s/%s = %s&quot; % (x, y, x/y))
def div2(x,y):
    print(&quot;%s//%s = %s&quot; % (x, y, x//y))
div1(5,2)
div1(5.,2)
div2(5,2)
div2(5.,2.)
</code></pre>

<pre><code>5/2 = 2.5
5.0/2 = 2.5
5//2 = 2
5.0//2.0 = 2.0
</code></pre>

<p>在Python3下结果会有怎样的不同？<br/><br/>
在Python2中，上述代码输出将是<br/><br/>
5/2 = 2<br/><br/>
5.0/2 = 2.5<br/><br/>
5//2 = 2<br/><br/>
5.0//2.0 = 2.0  </p>

<p>默认情况下，Python 2 自动执行整形计算如果两者都是整数。因此,5/2 结果是2，而5./2结果是2.5。<br/><br/>
注意，在Python2中，你可以通过增加以下引用来覆写这个行为。  </p>

<pre><code class="language-python">from future import division
</code></pre>

<p>同时要注意的是，//操作符将总是执行整形除法，不管操作符的类型。这就是为什么即使在Python 2中5.0//2.0的结果是2.0。<br/><br/>
然而在Python3中，没有此类特性。例如，在两端都是整形的情况下，它不会执行整形除法。<br/><br/>
因此，在Python3中，将会是如下结果：<br/><br/>
5/2 = 2.5<br/><br/>
5.0/2 = 2.5<br/><br/>
5//2 = 2<br/><br/>
5.0//2.0 = 2.0  </p>

<p>注：在 Python 3 中，/ 操作符是做浮点除法，而 // 是做整除（即商没有余数，比如 10 // 3 其结果就为 3，余数会被截除掉，而 (-7) // 3 的结果却是 -3。这个算法与其它很多编程语言不一样，需要注意，它们的整除运算会向0的方向取值。而在 Python 2 中，/ 就是整除，即和 Python 3 中的 // 操作符一样）</p>

<blockquote>
<p>转载自微信，仅供个人学习使用</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python常见的错误<九>]]></title>
    <link href="https://sparkbye.github.io/myBlog/15655124741455.html"/>
    <updated>2019-08-11T16:34:34+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15655124741455.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">常见错误8: 未能解决Python 2和Python 3之间的差异</h4>

<p>请看下面这个 filefoo.py:</p>

<pre><code class="language-python">import sys

def bar(i):
    if i == 1:
        raise KeyError(1)
    if i == 2:
        raise ValueError(2)

def bad():
    e = None
    try:
        bar(int(sys.argv[1]))
    except KeyError as e:
        print(&#39;key error&#39;)
    except ValueError as e:
        print(&#39;value error&#39;)
    print(e)

bad()
</code></pre>

<p>在Python 2中运行正常：</p>

<pre><code class="language-python">$ python foo.py 1
key error
1
$ python foo.py 2
value error
2
</code></pre>

<p>但是，现在让我们把它在Python 3中运行一下：</p>

<pre><code class="language-python">&gt;&gt;&gt; python3 foo.py 1
key error
Traceback (most recent call last):
  File &quot;foo.py&quot;, line 19, in &lt;module&gt;
    bad()
  File &quot;foo.py&quot;, line 17, in bad
    print(e)
UnboundLocalError: local variable &#39;e&#39; referenced before assignment
</code></pre>

<p>出什么问题了？ “问题”就是，在 Python 3 中，异常的对象在 except 代码块之外是不可见的。（这样做的原因是，它将保存一个对内存中堆栈帧的引用周期，直到垃圾回收器运行并且从内存中清除掉引用。了解更多技术细节请参考）</p>

<p><a href="https://docs.python.org/3/reference/compound_stmts.html#except">https://docs.python.org/3/reference/compound_stmts.html#except</a></p>

<p>一种解决办法是在 except 代码块的外部作用域中定义一个对异常对象的引用，以便访问。下面的例子使用了该方法，因此最后的代码可以在Python 2 和 Python 3中运行良好。</p>

<pre><code class="language-python">import sys

def bar(i):
    if i == 1:
        raise KeyError(1)
    if i == 2:
        raise ValueError(2)
        
def good():
    exception = None
    try:
        bar(int(sys.argv[1]))
    except KeyError as e:
        exception = e
        print(&#39;key error&#39;)
    except ValueError as e:
        exception = e
        print(&#39;value error&#39;)
    print(exception)

sys.argv.append(1)
good()
sys.argv.append(2)
good()
</code></pre>

<blockquote>
<p>转载自微信，仅供个人学习使用</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python常见的错误<八>]]></title>
    <link href="https://sparkbye.github.io/myBlog/15655124251876.html"/>
    <updated>2019-08-11T16:33:45+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15655124251876.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">常见错误8: 未能解决Python 2和Python 3之间的差异</h4>

<p>请看下面这个 filefoo.py:</p>

<pre><code class="language-python">import sys

def bar(i):
    if i == 1:
        raise KeyError(1)
    if i == 2:
        raise ValueError(2)

def bad():
    e = None
    try:
        bar(int(sys.argv[1]))
    except KeyError as e:
        print(&#39;key error&#39;)
    except ValueError as e:
        print(&#39;value error&#39;)
    print(e)

bad()
</code></pre>

<p>在Python 2中运行正常：</p>

<pre><code class="language-python">$ python foo.py 1
key error
1
$ python foo.py 2
value error
2
</code></pre>

<p>但是，现在让我们把它在Python 3中运行一下：</p>

<pre><code class="language-python">&gt;&gt;&gt; python3 foo.py 1
key error
Traceback (most recent call last):
  File &quot;foo.py&quot;, line 19, in &lt;module&gt;
    bad()
  File &quot;foo.py&quot;, line 17, in bad
    print(e)
UnboundLocalError: local variable &#39;e&#39; referenced before assignment
</code></pre>

<p>出什么问题了？ “问题”就是，在 Python 3 中，异常的对象在 except 代码块之外是不可见的。（这样做的原因是，它将保存一个对内存中堆栈帧的引用周期，直到垃圾回收器运行并且从内存中清除掉引用。了解更多技术细节请参考）</p>

<p><a href="https://docs.python.org/3/reference/compound_stmts.html#except">https://docs.python.org/3/reference/compound_stmts.html#except</a></p>

<p>一种解决办法是在 except 代码块的外部作用域中定义一个对异常对象的引用，以便访问。下面的例子使用了该方法，因此最后的代码可以在Python 2 和 Python 3中运行良好。</p>

<pre><code class="language-python">import sys

def bar(i):
    if i == 1:
        raise KeyError(1)
    if i == 2:
        raise ValueError(2)
        
def good():
    exception = None
    try:
        bar(int(sys.argv[1]))
    except KeyError as e:
        exception = e
        print(&#39;key error&#39;)
    except ValueError as e:
        exception = e
        print(&#39;value error&#39;)
    print(exception)

sys.argv.append(1)
good()
sys.argv.append(2)
good()
</code></pre>

<blockquote>
<p>转载自微信，仅供个人学习使用</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python常见的错误<七>]]></title>
    <link href="https://sparkbye.github.io/myBlog/15655123624150.html"/>
    <updated>2019-08-11T16:32:42+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15655123624150.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">常见错误7: 创建循环依赖模块</h4>

<p>让我们假设你有两个文件，a.py 和 b.py，他们之间相互引用，如下所示：</p>

<pre><code class="language-python">import b

def f():
    return b.x
print(f())
</code></pre>

<pre><code class="language-python">import a

x = 1
def g():
    print(a.f())
</code></pre>

<p>首先，让我们尝试引入 a.py：</p>

<pre><code class="language-python">import a
</code></pre>

<p>可以正常工作。这也许是你感到很奇怪。毕竟，我们确实在这里引入了一个循环依赖的模块，我们推测这样会出问题的，不是吗？<br/><br/>
答案就是在Python中，仅仅引入一个循环依赖的模块是没有问题的。如果一个模块已经被引入了，Python并不会去再次引入它。但是，根据每个模块要访问其他模块中的函数和变量位置的不同，就很可能会遇到问题。<br/><br/>
所以，回到我们这个例子，当我们引入 a.py 时，再引入 b.py 不会产生任何问题，因为当引入的时候，b.py 不需要 a.py 中定义任何东西。b.py 中唯一引用 a.py 中的东西是调用 a.f()。 但是那个调用是发生在g() 中的，并且 a.py 和 b.py 中都没有调用 g()。所以运行正常。<br/><br/>
但是，如果我们尝试去引入b.py 会发生什么呢？（在这之前不引入a.py），如下所示:</p>

<pre><code class="language-python">import b
</code></pre>

<p>啊哦。 出问题了！此处的问题是，在引入b.py的过程中，Python尝试去引入 a.py，但是a.py 要调用f()，而f() 有尝试去访问 b.x。但是此时 b.x 还没有被定义呢。所以发生了 AttributeError 异常。</p>

<p>至少，解决这个问题很简单，只需修改b.py，使其在g()中引入 a.py：</p>

<pre><code class="language-python">x = 1

def g():
    import a    # 只有当g()被调用的时候才会引入a
    print a.f()
</code></pre>

<p>现在，当我们再引入b，没有任何问题：</p>

<pre><code class="language-python">&gt;&gt;&gt; import b
&gt;&gt;&gt; b.g()
1    # Printed a first time since module &#39;a&#39; calls &#39;print f()&#39; at the end
1    # Printed a second time, this one is our call to &#39;g&#39;
</code></pre>

<blockquote>
<p>转载自微信，仅供个人学习使用</p>
</blockquote>

]]></content>
  </entry>
  
</feed>
