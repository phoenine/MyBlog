<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Ascetic in the deadlock]]></title>
  <link href="https://sparkbye.github.io/myBlog/atom.xml" rel="self"/>
  <link href="https://sparkbye.github.io/myBlog/"/>
  <updated>2017-12-25T21:41:28+08:00</updated>
  <id>https://sparkbye.github.io/myBlog/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[Python学习之整数比较]]></title>
    <link href="https://sparkbye.github.io/myBlog/15142090414246.html"/>
    <updated>2017-12-25T21:37:21+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15142090414246.html</id>
    <content type="html"><![CDATA[
<p>最近学习python，发现整数比较时一个有趣的现象：</p>

<pre><code class="language-python">a = 256
b = 256
print id(a)
print id(b)
print(a == b)
print(a is b)
print(id(a) == id(b))
print(id(a) is id(b))
c = 257
d = 257
print id(c)
print id(d)
print(c == d)
print(c is d)
print(id(c) == id(d))
print(id(c) is id(d))
</code></pre>

<p>在pycharm中运行的结果是：</p>

<pre><code>32019104
32019104
True
True
True
False
40550424
40550424
True
True
True
False
</code></pre>

<p>而在Python IDE中运行：</p>

<pre><code class="language-python">&gt;&gt;&gt; a = 256
&gt;&gt;&gt; b = 256
&gt;&gt;&gt; a == b
True
&gt;&gt;&gt; a is b
True
&gt;&gt;&gt; id(a)
32346576L
&gt;&gt;&gt; id(b)
32346576L
&gt;&gt;&gt; c = 257
&gt;&gt;&gt; d = 257
&gt;&gt;&gt; c == d
True
&gt;&gt;&gt; c is d
False
&gt;&gt;&gt; id(c)
39891736L
&gt;&gt;&gt; id(d)
39891712L
</code></pre>

<p>为什么同样是Python2.7.14，得出的结果迥然不同呢？<br/>
在Python中一切都是对象，因此整数也是对象。对象之间比较是否相等可以用==，也可以用is，两者的区别主要是：<br/>
- is比较的是两个对象的id值是否相等，也就是比较俩对象是否为同一个实例对象，是否指向同一个内存地址。<br/>
- ==比较的是两个对象的内容是否相等，默认会调用对象的__eq__()方法。</p>

<p>因此，代码段中<code>a == b</code>很好理解，因为两个对象的值都是256， 而<code>a is b</code>返回True， 说明a和b都是指向同一对象的。但是当值为257时，为什么指向的不是同一个对象呢？</p>

<p><strong>问题一：256和257，差别在哪里？</strong></p>

<p>出于对性能的考虑，Python内部做了很多的优化工作，对于整数对象，Python把一些频繁使用的整数对象缓存起来，保存到一个叫small_ints的链表中，在Python的整个生命周期内，任何需要引用这些整数对象的地方，都不再重新创建新的对象，而是直接引用缓存中的对象。Python把这些可能频繁使用的整数对象规定在范围[-5, 256)之间的小对象放在small_ints中，注意左闭右开。但凡是需要用些小整数时，就从这里面取，不再去临时创建新的对象。因为257不再小整数范围内，因此尽管a和b的值是一样，但是他们在Python内部却是以两个独立的对象存在的，各自为政，互不干涉。</p>

<p>源码位置：<code>Include/intobject.h | Objects/intobject.c</code></p>

<p><strong>小整数对象池：</strong><br/>
小整数对象池就是一个<strong>PyIntObject指针数组</strong></p>

<pre><code class="language-C">#ifndef NSMALLPOSINTS
#define NSMALLPOSINTS 257
#endif
#ifndef NSMALLNEGINTS
#define NSMALLNEGINTS 5
#endif
#if NSMALLNEGINTS + NSMALLPOSINTS &gt; 0
/* References to small integers are saved in this array so that they can be shared. The integers that are saved are those in the range -NSMALLNEGINTS (inclusive) to NSMALLPOSINTS (not inclusive).*/
static PyIntObject *small_ints[NSMALLNEGINTS + NSMALLPOSINTS];
#endif
</code></pre>

<p>其结构如下：<br/>
<img src="media/15142090414246/15142908389467.png" alt=""/></p>

<p><strong>问题二：都是257，is结局为啥不一样？</strong></p>

<p>其实答案就是如此简单：</p>

<p>对于Python而言，存储好的脚本文件（Script file）和在Console中的交互式（interactive）命令，执行方式不同。对于脚本文件，解释器将其当作整个代码块执行，而对于交互性命令行中的每一条命令，解释器将其当作单独的代码块执行。而Python在执行同一个代码块的初始化对象的命令时，会检查是否其值是否已经存在，如果存在，会将其重用（这句话不够严谨，后面会详谈）。所以在给出的例子中，文件执行时（同一个代码块）会把a、b两个变量指向同一个对象；而在命令行执行时，a、b赋值语句分别被当作两个代码块执行，所以会得到两个不同的对象，因而is判断返回False。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Auto Migrate Tool]]></title>
    <link href="https://sparkbye.github.io/myBlog/15142078830298.html"/>
    <updated>2017-12-25T21:18:03+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15142078830298.html</id>
    <content type="html"><![CDATA[
<p>最近需要测试NFV某个node的性能，所以需要Node ei-0单独在一个computer上，所以写了一个脚本：</p>

<pre><code class="language-sh">function echo__blue()      { echo -e &quot;\e[0;34;1m$1\e[0m&quot;;}
function echo__red()       { echo -e &quot;\e[0;31;1m$1\e[0m&quot;;}
function echo__green()     { echo -e &quot;\e[0;32;1m$1\e[0m&quot;;}
function echo__yellow()    { echo -e &quot;\e[0;33;1m$1\e[0m&quot;;}

COMPUTER_LIST=`nova hypervisor-list | awk &#39;{print $4}&#39; | awk &#39;NR&gt;2&#39;`
UE_NODE_NAME=`nova list | grep ei-0 | awk &#39;{print $4}&#39;`
OPTIMAL_COMPUTER=&#39;&#39;
INIT_USED=8.0
for COMPUTER in $COMPUTER_LIST
    do
        CPUS_USED=`nova hypervisor-show $COMPUTER | grep -i &quot;vcpus_used&quot; | awk &#39;{print $4}&#39; | head -1`
        echo__blue &quot;$COMPUTER node&#39;s vcpus_used is :  $CPUS_USED&quot;
        if [[ $(echo &quot;$CPUS_USED == 0.0&quot;|bc) = 1 ]];then
            echo__blue &quot;Greate! $COMPUTER is a optimal computer.&quot;
            OPTIMAL_COMPUTER=$COMPUTER
            break
        elif [[ $(echo &quot;$CPUS_USED &gt; 0.0&quot;|bc) = 1 ]] &amp;&amp; [[ $(echo &quot;$CPUS_USED &lt; 8.0 &quot;|bc) = 1 ]];then
            echo__green &quot;Maybe $COMPUTER is a selectable computer.&quot;
            if [[ $(echo &quot;$CPUS_USED &lt; $INIT_USED&quot;|bc) = 1 ]];then
                INIT_USED=$CPUS_USED
                OPTIMAL_COMPUTER=$COMPUTER
                echo__blue &quot;Now OPTIMAL_COMPUTER is: $COMPUTER.&quot;
            fi
        elif [[ $(echo &quot;$CPUS_USED &gt;= 8.0&quot;|bc) = 1 ]] &amp;&amp; [[ $(echo &quot;$CPUS_USED &lt;= 13.0 &quot;|bc) = 1 ]];then
            echo__red &quot;Maybe $COMPUTER is not a good choice.&quot;
            INSTANCE_NUMBER=`nova hypervisor-servers compute-159 | awk &#39;{print $4}&#39; | awk &#39;NR&gt;2&#39; | awk &#39;{if(length!=0) print $0}&#39; | wc -l`
            USED_RATE=$(echo &quot;$CPUS_USED / $INSTANCE_NUMBER&quot; | bc)
            echo &quot;===========USED_RATE: $USED_RATE=============&quot;
            if [[ $(echo &quot;$USED_RATE &lt; $INIT_USED&quot;|bc) = 1 ]];then
                INIT_USED=$USED_RATE
                echo &quot;===========INIT_USED: $INIT_USED=============&quot;
                OPTIMAL_COMPUTER=$COMPUTER
                echo__blue &quot;Now OPTIMAL_COMPUTER is: $COMPUTER.&quot;
            else
                continue
            fi
        else
            echo__red &quot;This computer node is full.&quot;
        fi
    done
echo &quot;===========Finally the chosen computer is $OPTIMAL_COMPUTER.==============&quot;
echo__green &quot;==============Begin to migrate UE node to $OPTIMAL_COMPUTER.=====================&quot;
nova live-migration $UE_NODE_NAME $OPTIMAL_COMPUTER
UE_NODE_STATE=`nova list | grep ei-0 | awk &#39;{print $10}&#39;`
if [ &quot;Running&quot; != &quot;$UE_NODE_STATE&quot; ];then
    echo &quot;Still migrating, please wait...&quot;
    sleep 5
fi
echo__green &quot;Live migration is successfully.&quot;  
</code></pre>

<p>shell不是经常使用，所以编写过程中才发现浮点数不能判断以及计算的问题，因此记录下，遇到问题可以这么写：</p>

<ul>
<li><p>通过bc</p>

<p>bc是一种任意精度的计算语言，注意是一种语言，它提供了一些语法结构，比如条件判断、循环等，可以说是很强大的，其中一个用途就是用来进行运算以及进制转换。我们经常使用的expr只支持整数运算，对于浮点运算就无能为力了，而且expr不能进行指数运算，而都有bc这些都不再话下。</p>

<pre><code class="language-sh">$(echo &quot;$CPUS_USED &gt; 0.0&quot;|bc) = 1
</code></pre></li>
<li><p>通过dc<br/>
可能你曾经知道有此命令，也可能你还不知道。dc相比与bc要复杂，但是简单操作还是比较简单。简单的说dc是一直压栈操作，和bc一样，它也可以交互使用，或者与echo一起配合使用，它也支持浮点运算。dc后续再作研究。</p></li>
<li><p>expr<br/>
expr竟然也可以？先保存下来，下次再试试：</p>

<pre><code class="language-sh">if [ `expr $a \&gt; $b` -eq 0 ];then
echo $b is bigger
else
echo $a is bigger
fi
</code></pre></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python格式化输出与format函数]]></title>
    <link href="https://sparkbye.github.io/myBlog/15137747318292.html"/>
    <updated>2017-12-20T20:58:51+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15137747318292.html</id>
    <content type="html"><![CDATA[
<p>本文主要整理和汇总python一系列的格式化输出方式：</p>

<p><strong>打印整数</strong></p>

<pre><code class="language-python">print (&quot;I&#39;m number %d&quot; % (20))

&gt;&gt;&gt; I&#39;m number 20  
</code></pre>

<p><strong>打印浮点数(默认)</strong></p>

<pre><code class="language-python">print(&quot;This book&#39;s weight is %f kg&quot; % (0.85))

&gt;&gt;&gt; This book&#39;s height is 0.850000 kg 
</code></pre>

<p><strong>打印浮点数(指定位数)</strong></p>

<pre><code class="language-python">print(&quot;His height is %.2f m&quot; % (1.73))

&gt;&gt;&gt; His height is 1.73 m 
</code></pre>

<p><strong>打印字符串</strong></p>

<pre><code class="language-python">print(&quot;My name is %s&quot; % (&#39;terry&#39;))

&gt;&gt;&gt; My name is terry 
</code></pre>

<p><strong>打印指定占位符宽度</strong></p>

<pre><code class="language-python">print(&quot;Type:%9s Value:%3d Latency:%5.2f&quot; % (&#39;AVP_KMOD&#39;, 44, 0.45))

&gt;&gt;&gt; Type: AVP_KMOD Value: 44 Latency: 0.45 
</code></pre>

<p><strong>打印指定占位符(左对齐)</strong></p>

<pre><code class="language-python">print(&quot;Name:%-10s Age:%-8d Height:%-8.2f&quot;%(&quot;Terry&quot;,25,1.83))

&gt;&gt;&gt; Name:Terry      Age:25       Height:1.83 
</code></pre>

<p><strong>打印指定占位符(前导0)</strong></p>

<pre><code class="language-python">print (&quot;Speed:%010d Rate:%08d Height:%08.2f&quot;%(1000,25,1.83))

&gt;&gt;&gt; Speed:0000001000 Rate:00000025 Height:00001.83 
</code></pre>

<p>在python2.6之后，又增加了一种格式化字符串的函数str.format()，通过{}来代替%。<br/>
用法主要包含以下几类：</p>

<p><strong>通过位置</strong><br/>
字符串的format函数可以接受不限个参数，位置可以不按顺序，可以不用或者用多次:</p>

<pre><code class="language-python">print(&#39;{0},{1},{0}&#39;.format(&#39;aaa&#39;, &#39;bbb&#39;))

&gt;&gt;&gt; aaa,bbb,aaa  
</code></pre>

<p><strong>通过关键字参数</strong></p>

<pre><code class="language-python">print(&#39;{name},{age}&#39;.format(age=18,name=&#39;Terry&#39;))

&gt;&gt;&gt; Terry,18  
</code></pre>

<p><strong>通过对象属性</strong></p>

<pre><code class="language-python">class Person:
    def __init__(self,name,age):
        self.name = name
        self.age = age

    def __str__(self):
        return &#39;This guy is {self.name},he is {self.age} old.&#39;.format(self=self)

print str(Person(&#39;Terry&#39;,18))

&gt;&gt;&gt; This guy is Terry,he is 18 old.
</code></pre>

<p><strong>通过下标</strong></p>

<pre><code class="language-python">person = [&#39;Terry&#39;,18]
print(&#39;{0[0]},{0[1]}&#39;.format(person))

&gt;&gt;&gt; Terry,18
</code></pre>

<p><strong>通过格式</strong><br/>
如上面的前导0：</p>

<pre><code class="language-python">print(&#39;{:0&gt;8}&#39;.format(&#39;189&#39;))
print(&#39;{:&gt;8}&#39;.format(&#39;189&#39;))
print(&#39;{:a&gt;8}&#39;.format(&#39;189&#39;))

&gt;&gt;&gt; 00000189
&gt;&gt;&gt;      189
&gt;&gt;&gt; aaaaa189
</code></pre>

<p>以及浮点数：</p>

<pre><code class="language-python">print(&#39;{:.2f}&#39;.format(321.33345))

&gt;&gt;&gt; 321.33
</code></pre>

<p><strong>其他类型</strong><br/>
主要就是二进制b、十进制d、八进制o、十六进制x:</p>

<pre><code class="language-python">print(&#39;{:b}&#39;.format(46))
print(&#39;{:d}&#39;.format(46))
print(&#39;{:o}&#39;.format(46))
print(&#39;{:x}&#39;.format(46))

&gt;&gt;&gt; 101110
&gt;&gt;&gt; 46
&gt;&gt;&gt; 56
&gt;&gt;&gt; 2e
</code></pre>

<p>此外， 用逗号还能用来做金额的千位分隔符。</p>

<pre><code class="language-python">print(&#39;{:,}&#39;.format(99988844333))

&gt;&gt;&gt; 99,988,844,333
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python中的__name__和__main__]]></title>
    <link href="https://sparkbye.github.io/myBlog/15096259430881.html"/>
    <updated>2017-11-02T20:32:23+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15096259430881.html</id>
    <content type="html"><![CDATA[
<p>对于大多数编译型编程语言来说， 如C、C++、Java等，都会有一个main函数来作为函数的入口。而python则有所不同，它基本属于脚本语言，即从脚本的第一行开始逐行解释运行，没有统一的入口。而&quot;if <strong>name</strong>==&quot;__main__&quot;:&quot; 这一句可以理解为主程序入口；<br/>
python是使用缩进对齐的方式执行的，对于没有缩进的代码，会在载入时自动执行。另外代码除了直接执行外，还可以作为模块调用。为了区分执行和调用，python引入了内置属性：__name__。</p>

<ol>
<li>当代码被执行时，__name__的值为 ‘__main__’</li>
<li>当代码被调用时，如果在模块中，__name__就表示模块名；如果在类中，__name__就表示类名。</li>
</ol>

<p>举个栗子：<br/>
在test_1.py中写入如下代码：</p>

<pre><code>print &quot;I&#39;m the first...&quot;

def test():
    print &quot;I&#39;m the second...&quot;

print __name__
if __name__ == &quot;__main__&quot;:
    test()
    print &quot;I&#39;m the third...&quot;
else:
    print &quot;I&#39;m the last...&quot;
</code></pre>

<p>直接执行test_1.py，会有如下结果：</p>

<pre><code>C:\Python27\python.exe D:/userdata/f7yang/workspace/Python_test/test_libraries/test_study_10/test_1.py
I&#39;m the first...
__main__
I&#39;m the second...
I&#39;m the third...
</code></pre>

<p>可以看出，此时__name__的值为‘__main__’ ，<br/>
而作为调用来执行时：<br/>
<code>from test_1 import test</code><br/>
会有如下结果：</p>

<pre><code>C:\Python27\python.exe D:/userdata/f7yang/workspace/Python_test/test_libraries/test_study_10/test_2.py
I&#39;m the first...
test_1
I&#39;m the last...
</code></pre>

<p>此时__name__的值为test_1，即模块的名字 。 <br/>
其实简而言之，自动执行类似自己称呼自己，调用则类似别人称呼自己，如是而已。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[通过MWeb上传Blog]]></title>
    <link href="https://sparkbye.github.io/myBlog/15095429404216.html"/>
    <updated>2017-11-01T21:29:00+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15095429404216.html</id>
    <content type="html"><![CDATA[
<h6 id="toc_0">你所需要做的，仅仅是：</h6>

<ol>
<li><p>新增分类 -&gt; CSDN Blog</p></li>
<li><p>右击编辑 -&gt; 高级设置 -&gt; 发布服务， 选择MetaWeblog API</p></li>
</ol>

<p><img src="media/15095429404216/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-01%2021.30.08.png" alt="屏幕快照 2017-11-01 21.30.08"/><br/>
3. 生成网站，并推送到博客</p>

<p><img src="media/15095429404216/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-01%2021.41.21.png" alt="屏幕快照 2017-11-01 21.41.21"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义控件]]></title>
    <link href="https://sparkbye.github.io/myBlog/14991719231835.html"/>
    <updated>2017-07-04T20:38:43+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/14991719231835.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">UIView的封装</h3>

<p>如果一个view内部的子控件比较多，一般会考虑自定义一个view，把它内部子控件的创建屏蔽起来，不让外界关心。外界可以传入对应的模型数据给view，view拿到模型数据后给内部的子控件设置对应的数据继承自系统自带的控件，写一个属于自己的控件。<br/>
* 目的：封装空间内部的细节，不让外界关心</p>

<h3 id="toc_1">UIView的封装有两种方式</h3>

<p>通过纯代码封装：<br/>
1. 新建一个继承UIView的类<br/>
2. 在刚刚新建类的类扩展中添加子控件属性（用weak声明，防止内存泄露）<br/>
3. 在initWithFrame:方法中添加子控件<br/>
4. 在layoutSubviews方法中设置子控件的frame（在该方法中一定要调用[super layoutSubviews]方法）<br/>
5. 提供一个模型属性，重写模型属性的set方法<br/>
6. 在该setter方法中取出模型属性，给对应的子控件赋值<br/>
UIView的封装代码如下：</p>

<pre><code> /**
  *  CustomView.h文件
  */

 // 步骤1 新建一个继承UIView的类
 #import &lt;UIKit/UIKit.h&gt;
 @class CustomModel;
 @interface CustomView : UIView
 // 在这里为了方便，可以自行添加构造方法，方便使用
 // 步骤5 提供一个`模型`属性，重写模型属性的set方法
 @property (nonatomic, strong) CustomModel *model;
 @end
</code></pre>

<pre><code>/**
 *  CustomView.m文件
 */
 #import &quot;CustomView.h&quot;
 #import &quot;CustomModel.h&quot;
 @interface CustomView ()
 // 步骤2 在刚刚新建类的`类扩展`中添加子控件属性（用`weak`声明，防止内存泄露）
 @property (nonatomic, weak) UIImageView *iconImageView;
 @property (nonatomic, weak) UILabel *nameLabel;
 @end

 @implementation CustomView
 // 步骤3 在initWithFrame:方法中添加子控件
 - (instancetype)initWithFrame:(CGRect)frame
 {
     if (self = [super initWithFrame:frame]) {
     // 注意：该处不要给子控件设置frame与数据，可以在这里初始化子控件的属性
     UIImageView *iconImageView = [[UIImageView alloc] init];
     self.iconImageView = iconImageView;
     [self addSubview:iconImageView];

     UILabel *nameLabel = [[UILabel alloc] init];
     // 设置子控件的属性
     nameLabel.textAlignment = NSTextAlignmentCenter;
     nameLabel.font = [UIFont systemFontOfSize:10];
     self.nameLabel = nameLabel;
     [self addSubview:nameLabel];
     }
     return self;
 }

 // 步骤4 在`layoutSubviews`方法中设置子控件的`frame`（在该方法中一定要调用`[super layoutSubviews]`方法）
 - (void)layoutSubviews
 {
     [super layoutSubviews];

     CGFloat iconImageViewX = 0;
     CGFloat iconImageViewY = 0;
     CGFloat iconImageViewW = self.bounds.size.width;
     CGFloat iconImageViewH = 80;
     self.iconImageView.frame = CGRectMake(iconImageViewX, iconImageViewY, iconImageViewW, iconImageViewH);

     CGFloat nameLabelX = 0;
     CGFloat nameLabelY = iconImageViewH;
     CGFloat nameLabelW = iconImageViewW;
     CGFloat nameLabelH = self.bounds.size.height - iconImageViewH;
     self.iconImageView.frame = CGRectMake(nameLabelX, nameLabelY, nameLabelW, nameLabelH);
 }

 // 步骤6 在该`setter`方法中取出模型属性，给对应的子控件赋值
 - (void)setModel:(CustomModel *)model
 {
     _model = model;
     self.iconImageView.image = [UIImage imageNamed:model.icon];
     self.nameLabel.text = model.name;
 }
 @end
</code></pre>

<p>layoutSubviews在以下情况下会被调用：<br/>
1. init初始化不会触发layoutSubviews<br/>
2. addSubview会触发layoutSubviews<br/>
3. 设置view的Frame会触发layoutSubviews，当然前提是frame的值设置前后发生了变化<br/>
4. 滚动一个UIScrollView会触发layoutSubviews<br/>
5. 旋转Screen会触发父UIView上的layoutSubviews事件<br/>
6. 改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件</p>

<p>模型代码如下：</p>

<pre><code> /**
  *  CustomModel.h文件
  */
 #import &lt;Foundation/Foundation.h&gt;

 @interface CustomModel : NSObject
    /**
     *  名字
     */
 @property (nonatomic, copy) NSString *name;
    /**
     *  图片
     */
 @property (nonatomic, copy) NSString *icon;

 + (instancetype)modelWithName:(NSString *)name icon:(NSString *)icon;
 - (instancetype)initWithName:(NSString *)name icon:(NSString *)icon;

 @end
</code></pre>

<pre><code> /**
  *  CustomModel.m文件
  */
 #import &quot;CustomModel.h&quot;

 @implementation CustomModel
 + (instancetype)modelWithName:(NSString *)name icon:(NSString *)icon
 {
     return [[self alloc] initWithName:name icon:icon];
 }

 - (instancetype)initWithName:(NSString *)name icon:(NSString *)icon
 {
     if (self = [super init]) {
         self.name = name;
         self.icon = icon;
     }
     return self;
 }
 @end
</code></pre>

<p>如何使用？只需在控制器代码中执行4个步骤，简单方便：</p>

<pre><code>// 创建自定义的View
 CustomView *customView = [[CustomView alloc] init];
// 设置数据
 CustomModel *model = [CustomModel modelWithName:@&quot;hosea_zhou&quot; icon:@&quot;1&quot;];
 customView.model = model;
// 设置frame
 customView.frame = CGRectMake(100, 100, 67, 100);
// 添加子控件
 [self.view addSubview:customView];
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIButton]]></title>
    <link href="https://sparkbye.github.io/myBlog/14976187081535.html"/>
    <updated>2017-06-16T21:11:48+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/14976187081535.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">UIButton的状态</h3>

<ul>
<li><p>normal(普通状态)</p>

<ul>
<li>默认情况（DEFAULT）</li>
<li>对应的枚举常量： UIControlStateNormal</li>
</ul></li>
<li><p>highlighted (高亮状态)</p>

<ul>
<li>按钮被按下去的时候</li>
<li>对应的枚举常量： UIControlStateHighlighted</li>
</ul></li>
<li><p>disabled (失效状态)</p>

<ul>
<li>如果enabled属性为NO，就是出于disabled状态，代表按钮不可以被点击</li>
<li>对应的枚举变量： UIControlStateDisabled</li>
</ul></li>
</ul>

<h3 id="toc_1">UIButton代码应用</h3>

<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
    UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom];
    button.frame = CGRectMake(100, 300, 200, 100);
    button.backgroundColor = [UIColor redColor];
    [button setTitle:@&quot;Mytest&quot; forState:UIControlStateNormal];
    [button setTitleColor:[UIColor yellowColor] forState:UIControlStateNormal];
    [button setTitle:@&quot;HighLight&quot; forState:UIControlStateHighlighted];
    [button setTitleColor:[UIColor blueColor] forState:UIControlStateHighlighted];
    [button setImage:[UIImage imageNamed:@&quot;makefg&quot;] forState:UIControlStateNormal];

    [self.view addSubview:button];
    [button addTarget:self action:@selector(clickButton:) forControlEvents:UIControlEventTouchDown];
}

-(IBAction)clickButton:(UIButton *)button {
    button.enabled = NO;

}
</code></pre>

<h3 id="toc_2">九宫格布局</h3>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UILable]]></title>
    <link href="https://sparkbye.github.io/myBlog/14966683926548.html"/>
    <updated>2017-06-05T21:13:12+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/14966683926548.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">UILable常见属性</h3>

<p><code>@property(nonatomic, copy) NSString *text;</code><br/>
* 显示文字</p>

<p><code>@property(nonatomic, retain) UIFont *font;</code><br/>
* 显示字体</p>

<p><code>@property(nonatomic, retain) UIColor *textColor;</code><br/>
* 文字颜色</p>

<p><code>@property(nonatomic) NSTextAlignment textAlignment;</code><br/>
* 对齐模式(左对齐，居中对齐， 右对齐)</p>

<p><code>@property(nonatomic) NSInteger numberOfLines;</code><br/>
*文字行数</p>

<p><code>property(nonatomic) NSLineBreakMode lineBreakMode;</code><br/>
* 换行模式</p>

<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
    UILabel *lable = [[UILabel alloc] init];
    
    lable.frame = CGRectMake(50, 300, 300, 200);
    lable.backgroundColor = [UIColor redColor];
    lable.text = @&quot;你这头猪&quot;;
    lable.textAlignment = NSTextAlignmentCenter;
    lable.font = [UIFont systemFontOfSize:20.f];
    lable.font = [UIFont boldSystemFontOfSize:20.f];
    lable.textColor = [UIColor purpleColor];
    lable.shadowOffset = CGSizeMake(4, -10);
    lable.shadowColor = [UIColor blueColor];
    lable.lineBreakMode = NSLineBreakByClipping;
    [self.view addSubview:lable];   
}
</code></pre>

<h3 id="toc_1">UIImageView</h3>

<p><img src="media/14966683926548/14967586896546.jpg" alt=""/></p>

<h3 id="toc_2">毛玻璃效果</h3>

<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
    
    UIImageView *imageView = [[UIImageView alloc] init];
    imageView.backgroundColor = [UIColor redColor];
    imageView.frame = self.view.bounds;
    imageView.image = [UIImage imageNamed:@&quot;IMG_2585&quot;];
    imageView.contentMode = UIViewContentModeScaleAspectFill;
    
    UIToolbar *toolBar = [[UIToolbar alloc] init];
    toolBar.frame = imageView.bounds;
    toolBar.barStyle = UIBarStyleBlack;
    toolBar.alpha = 0.85;
    [imageView addSubview:toolBar];
    
    [self.view addSubview:imageView];
}
</code></pre>

<h3 id="toc_3">四种设置UIImage尺寸的方法</h3>

<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
    UIImageView *imageView = [[UIImageView alloc] init];
    //第一种方式
    imageView.frame = CGRectMake(100, 100, 200, 200);
    imageView.backgroundColor = [UIColor purpleColor];
    imageView.image = [UIImage imageNamed:@&quot;1&quot;];
    imageView.contentMode = UIViewContentModeScaleAspectFill;
    //第二种方式
    UIImage *image = [UIImage imageNamed:@&quot;1&quot;];
    imageView.frame = CGRectMake(0, 0, image.size.width, image.size.height);
    imageView.backgroundColor = [UIColor purpleColor];
    imageView.image = image;
    //第三种方式
    UIImageView *imageView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@&quot;1&quot;]];
    imageView.center = CGPointMake(100, 300);
    //第四种方式
    UIImageView *imageView = [[UIImageView alloc] initWithFrame:(CGRectMake(100, 100, 200, 200))];
    UIImage *image = [UIImage imageNamed:@&quot;1&quot;];
    imageView.image = image;
    
    [self.view addSubview:imageView];
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIView]]></title>
    <link href="https://sparkbye.github.io/myBlog/14965374170472.html"/>
    <updated>2017-06-04T08:50:17+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/14965374170472.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">UIView常见属性</h3>

<p><code>@property(nonatomic, readonly) UIView *superview;</code><br/>
* 获取自己的父控件对象</p>

<p><code>@property(nonatomic, readonly, copy) NSArray *subviews;</code><br/>
* 获取自己的子控件对象</p>

<p><code>@property(nonatomic) NSInteger tag;</code><br/>
* 控件的ID，父控件可以通过tag来找到对应的子控件</p>

<p><code>@property(nonatomic) CGAffineTransform transform;</code><br/>
* 控件的形变属性(可以设置旋转角度、比例缩放、平移等属性)</p>

<p><code>@property(nonatomic) CGRect frame;</code><br/>
* 控件矩形框在父控件中的位置和尺寸</p>

<p><code>@property(nonatomic) CGRect bounds;</code><br/>
* 控件矩形框的位置和尺寸</p>

<p><code>@property(nonatomic) CGPoint center;</code><br/>
* 控件重点的位置</p>

<pre><code>#import &quot;ViewController.h&quot;

@interface ViewController ()

@property(weak, nonatomic) UILabel *lable;

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
    
    UILabel *lable = [[UILabel alloc] init];
    lable.frame = CGRectMake(200, 100, 100, 60);
    lable.backgroundColor = [UIColor redColor];
    [self.view addSubview:lable];
    self.lable = lable;
}

- (IBAction)bounds {
    self.lable.bounds = CGRectMake(0, 0, 200, 40);
}

- (IBAction)center {
    self.lable.center = CGPointMake(self.view.frame.size.width * 0.5, self.view.frame.size.height * 0.5);
}
@end

</code></pre>

<h3 id="toc_1">常见的方法</h3>

<pre><code>-(void)loadView{
    [super loadView];
}

-(void)viewDidLoad{
    [super viewDidLoad];
} 

-(void)didReceiveMemoryWarning{
    [super didReceiveMemoryWarning];
}
</code></pre>

<h5 id="toc_2">viewDidLoad</h5>

<ul>
<li>系统调用</li>
<li>controller的View加载完毕的时候调用</li>
<li>控件的初始化，数据的初始化(懒加载)</li>
</ul>

<h5 id="toc_3">didReceiveMemoryWarning</h5>

<ul>
<li>系统调用</li>
<li>当控制器接受到内存警告调用</li>
<li>去除一些不必要的内存，去除耗时的内存</li>
</ul>

<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
//    NSLog(@&quot;%@&quot;, self.greenView.superview);
//    NSLog(@&quot;%@&quot;, self.greenView.subviews);
//    NSLog(@&quot;%@&quot;, self.view.subviews);
    UISwitch *sw = [[UISwitch alloc] init];
    [sw setHighlighted:true];
    [self.view addSubview:sw];
    [sw removeFromSuperview];
}
</code></pre>

<h5 id="toc_4">addSubview</h5>

<ul>
<li>添加一个子控件
##### removeFromSuperview</li>
<li>从父控件中移除
##### -(UIView *)viewwithTag:(NSInteger)tag;</li>
<li>根据一个tag找出对应的控件</li>
<li>不推荐使用tag

<ul>
<li>tag的效率差</li>
<li>tag容易乱</li>
</ul></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Block]]></title>
    <link href="https://sparkbye.github.io/myBlog/14950245211652.html"/>
    <updated>2017-05-17T20:35:21+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/14950245211652.html</id>
    <content type="html"><![CDATA[
<ul>
<li>Block是一个数据类型；</li>
</ul>

<hr/>

<p>既然block是一个数据类型，那么我们自然可以声明一个block类型的变量，那么block变量中存储的是什么呢？</p>

<hr/>

<blockquote>
<p>block类型的变量中存储的是代码段（可以有参数，可以有返回值）。</p>
</blockquote>

<h3 id="toc_0">如何声明一个block变量</h3>

<pre><code>void (^myBlock1)();
int (^myBlock2)();
int (^myBlock3)(int num1, int num2);
</code></pre>

<h3 id="toc_1">block变量的初始化</h3>

<pre><code>void (^myBlock1)() = ^void(){
        NSLog(@&quot;test&quot;);
    };

int (^myBlock2)() = ^int(){
    int num1 = 10 + 20;
    return num1;
};

int (^myblock3)(int num1, int num2) = ^int(int num1, int num2){
    int num3 = num1 + num2;
    return num3;
};
</code></pre>

<blockquote>
<p>赋值给block变量的代码段必须要符合block变量的要求。</p>
</blockquote>

<pre><code>#import &lt;Foundation/Foundation.h&gt;

int main(int argc, const char * argv[]) {
    
    void (^myBlock1)();
    myBlock1 = ^void(){
        NSLog(@&quot;test&quot;);
    };
    myBlock1();
    
    int (^myBlock2)() = ^int(){
        int num1 = 10 + 20;
        return num1;
    };
    int sum = myBlock2();
    NSLog(@&quot;sum = %d&quot;, sum);
    
    int (^myblock3)(int num1, int num2) = ^int(int num1, int num2){
        int num3 = num1 + num2;
        return num3;
    };
    
    int res = myblock3(10, 100);
    NSLog(@&quot;res = %d&quot;, res);
    
    
    return 0;
}
</code></pre>

<h3 id="toc_2">block的简写</h3>

<ol>
<li>如果代码段没有返回值，那么代码段的void可以省略：</li>
</ol>

<pre><code>//既没有参数也没有返回值的，void和（）都可以省略
void (^myBlock1)() = ^(){
        NSLog(@&quot;test&quot;);
    };
</code></pre>

<ol>
<li>如果代码段没有参数，代码段的（）也可以省略：</li>
</ol>

<pre><code>int (^myBlock2)() = ^int{
    int num1 = 10 + 20;
    return num1;
};
</code></pre>

<ol>
<li> 如果有指定参数，可以只写参数类型而不写参数名称：</li>
</ol>

<pre><code>int (^myblock3)(int, int) = ^int(int num1, int num2){
    int num3 = num1 + num2;
    return num3;
};
</code></pre>

<ol>
<li><p>无论代码段是否有返回值，在写代码段的时候可以不写返回值的类型：</p></li>
</ol>

<ul>
<li>如果代码段省略了返回值，系统会自动确定返回值的类型</li>
<li>如果代码段有返回值，return的数据是什么类型，系统就会认为代码段是什么类型；</li>
</ul>

<pre><code>int (^myBlock4)(int, int) = ^(int num1, int num2){
    int num3 = num1 + num2;
    return num3;
};
    
int result = myBlock4(20, 30);
NSLog(@&quot;result is %d&quot;, result);
</code></pre>

<h3 id="toc_3">简化block的定义</h3>

<ol>
<li>typedef: 将block定义为一个短类型。</li>
</ol>

<pre><code>typedef void (^NewType)();
NewType block1 = ^void(){
    NSLog(@&quot;Hello&quot;);
};
block1();
</code></pre>

<ul>
<li>block内部可以取外部的局部变量和全局变量的值</li>
<li>block内部可以修改全部变量的值，但是无法修改外部局部变量的值</li>
<li>如果需要修改，则局部变量定义方式为__block int num = 100;</li>
</ul>

<h3 id="toc_4">block作为函数的参数</h3>

<ol>
<li>可以在函数中声明一个指定格式的block：</li>
</ol>

<pre><code>void test(void (^block1)()){
    NSLog(@&quot;~~~~~~~~&quot;);
    block1();
    NSLog(@&quot;~~~~~~~~&quot;);
}
</code></pre>

<ol>
<li>使用typedef简化定义：</li>
</ol>

<pre><code>typedef void (^NewBlock) ();

void test_2(NewBlock block2){
    NSLog(@&quot;~~~~~~~~&quot;);
    block2();
    NSLog(@&quot;~~~~~~~~&quot;);
}
</code></pre>

<ol>
<li>如何调用：</li>
</ol>

<pre><code>#import &lt;Foundation/Foundation.h&gt;

typedef void (^NewBlock) ();

void test(void (^block1)()){
    NSLog(@&quot;~~~~~~~~&quot;);
    block1();
    NSLog(@&quot;~~~~~~~~&quot;);
}

void test_2(NewBlock block2){
    NSLog(@&quot;~~~~~~~~&quot;);
    block2();
    NSLog(@&quot;~~~~~~~~&quot;);
}

int main(int argc, const char * argv[]) {

    NewBlock type = ^{
        NSLog(@&quot;hahahah&quot;);
    };
    
    test_2(type);
    
    test_2(^{
        NSLog(@&quot;hahahah&quot;);
    });
    
    return 0;
}
</code></pre>

<p>在这个状态下直接敲回车：<br/>
<img src="media/14950245211652/14955458877653.jpg" alt=""/><br/>
可以转换成：<br/>
<img src="media/14950245211652/14955459281745.jpg" alt=""/><br/>
然后直接补充代码即可：<br/>
<img src="media/14950245211652/14955459527916.jpg" alt=""/></p>

<blockquote>
<p>将block作为函数的参数可以实现什么效果？</p>
</blockquote>

<pre><code>⁃ 可以将调用者所写的代码放到函数的内部去执行；
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[继承与多态]]></title>
    <link href="https://sparkbye.github.io/myBlog/14896702983964.html"/>
    <updated>2017-03-16T21:18:18+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/14896702983964.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">static关键字</h3>

<ol>
<li><p>C语言中的static</p>

<ul>
<li>修饰局部变量</li>
<li>修饰全局变量</li>
<li>修饰函数</li>
</ul></li>
<li><p>OC中的static关键字</p>

<ul>
<li>static不能修饰属性，也不能修饰方法</li>
<li>static可以修饰方法中的局部变量</li>
</ul>

<p>如果方法中的局部变量被static修饰，那么这个变量就会变成静态变量，存储在常量区，当方法执行完毕不会被回收。下次再执行这个方法的时候，直接使用而不用再次声明。<br/>
<img src="media/14896702983964/14896706781899.jpg" alt=""/></p>

<ul>
<li>如果方法的返回值是当前类的对象，那么方法的返回值就写为instanceType</li>
</ul></li>
<li><p>什么时候用到static<br/>
<img src="media/14896702983964/14896717656421.jpg" alt=""/></p></li>
</ol>

<h3 id="toc_1">self关键字</h3>

<ul>
<li>self是一个指针；</li>
<li>在对象方法中self指向当前对象；</li>
<li><p>在类方法中self指向当前类；</p></li>
<li><p>作用：</p>

<ul>
<li>可以显式的访问当前对象的属性； self -&gt; 属性</li>
<li>可以使用self来调用当前对象的其他的对象方法；</li>
</ul></li>
</ul>

<h3 id="toc_2">私有属性和私有方法</h3>

<ul>
<li>将属性定义在@implementation之中和将属性定义在@interface之中并标记为@private唯一的区别： 提示和不提示</li>
<li>都不能被外界访问</li>
<li>方法不写声明，只写实现，那么这个方法就是一个私有方法；</li>
<li>私有方法只能在本类的其他方法中调用，不能被外界调用</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[类方法与对象方法]]></title>
    <link href="https://sparkbye.github.io/myBlog/14885942470746.html"/>
    <updated>2017-03-04T10:24:07+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/14885942470746.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">对象方法</h4>

<ul>
<li>调用：如果想要调用对象方法就必须先创建对象，通过对象名来调用</li>
<li>声明：使用‘-’号</li>
</ul>

<h4 id="toc_1">类方法</h4>

<ul>
<li>调用：类方法的调用不依赖于对象，如果要调用类方法，不需要去创建对象，直接通过类名来调用。</li>
<li>声明：使用‘+’号</li>
<li>在类方法中不能直接访问属性</li>
<li>属性是在对象创建的时候，跟随着对象一起创建在对象之中</li>
<li>类第一次被访问的时候，会做类加载，是把类的带啊存储在代码段</li>
<li>节约空间，提高效率</li>
<li>如果方法不需要直接访问属性，也不需要直接调用其他的对象方法，则可以定义为类方法</li>
</ul>

<h4 id="toc_2">类方法规范</h4>

<ul>
<li>如果写一个类，可以为这个类提供一个和类同名的类方法；</li>
</ul>

<h4 id="toc_3">NSString最常用的类方法</h4>

<p>instanceType 作为返回值 代表返回的是当前类的对象<br/>
<img src="media/14885942470746/14888085422135.jpg" alt=""/><br/>
<img src="media/14885942470746/14888090342021.jpg" alt=""/></p>

<h4 id="toc_4">NSString最常用的对象方法</h4>

<p><img src="media/14885942470746/14888092424014.jpg" alt=""/><br/>
<img src="media/14885942470746/14888094300096.jpg" alt=""/><br/>
<img src="media/14885942470746/14888095451151.jpg" alt=""/><br/>
<img src="media/14885942470746/14888099962376.jpg" alt=""/><br/>
<img src="media/14885942470746/14888102494936.jpg" alt=""/><br/>
<img src="media/14885942470746/14892006938627.jpg" alt=""/><br/>
<img src="media/14885942470746/14892007099870.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[对象与方法]]></title>
    <link href="https://sparkbye.github.io/myBlog/14879879409983.html"/>
    <updated>2017-02-25T09:59:00+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/14879879409983.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">分组导航标记</h4>

<p>标记：<br/>
<code># pragma mark XXXX</code><br/>
分割线：<br/>
<code># pragma mark -</code></p>

<h4 id="toc_1">类的本质</h4>

<ul>
<li>类的本质是我们自定义的一个<strong>数据类型</strong></li>
<li>类可以作为方法的参数:<code>- (void) test : (Dog *)Dog;</code></li>
<li>一个target钟的类无法直接在另外一个target钟访问；</li>
<li>类的属性代表这个类所拥有的东西；</li>
<li>类的方法代表该类所具备的行为和功能；</li>
</ul>

<h4 id="toc_2">对象作为类的属性</h4>

<p><img src="media/14879879409983/14880765155478.jpg" alt=""/></p>

<ul>
<li>属性的本质是变量；</li>
<li>在创建对象的时候，对象中的属性是按照类模板中个规定所创建出来的；</li>
<li>注意_dog是指针变量；如果对象的属性是另一个类的对象，这个属性仅仅是一个指针变量，并没有对象产生；
<img src="media/14879879409983/14880768553779.jpg" alt=""/>
<img src="media/14879879409983/14880772940474.jpg" alt=""/>
如果要再方法中调用当前对象的另一个方法 <code>[self 方法名]</code></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[nil和NULL]]></title>
    <link href="https://sparkbye.github.io/myBlog/14878614535108.html"/>
    <updated>2017-02-23T22:50:53+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/14878614535108.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">NULL</h4>

<ul>
<li>NULL可以作为指针变量的值；</li>
<li>如果一个指针变量的值是NULL值代表这个指针不指向内存中的任何一个空间；</li>
<li>NULL 其实是一个宏</li>
</ul>

<blockquote>
<p>#define NULL ((void *)0)</p>
</blockquote>

<h4 id="toc_1">nil</h4>

<ul>
<li>nil只能作为指针变量的值，代表指针变量不指向内存中的任何一个空间；</li>
<li>nil也是一个宏；</li>
<li>NULL和nil其实是一样的；
<img src="media/14878614535108/14878622149842.jpg" alt=""/>
<img src="media/14878614535108/14878623109287.jpg" alt=""/></li>
<li>一般C指针用NULL，OC的类指针用nil；</li>
</ul>

<blockquote>
<p>如果一个类指针的值为nil，那么通过指针去访问该指针指向的对象的属性，运行会报错；<br/>
该指针去访问指针指向的对象的方法，运行不会报错，但是不会去执行；</p>
</blockquote>

<p><img src="media/14878614535108/14878633255069.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[类、对象和方法]]></title>
    <link href="https://sparkbye.github.io/myBlog/14848362414368.html"/>
    <updated>2017-01-19T22:30:41+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/14848362414368.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">对象在内存中式如何存储的</h2>

<h4 id="toc_1">内存中的五大区域：</h4>

<ol>
<li>堆： 程序员手动申请的字节空间： malloc calloc</li>
<li>栈： 存储局部变量</li>
<li>BSS段： 存储未被初始化的全部变量 静态变量</li>
<li>数据段(常量区)： 存储已被初始化的全局 静态变量，常量</li>
<li>代码段： 存储程序的代码</li>
</ol>

<h4 id="toc_2">类加载</h4>

<ol>
<li>在创建对象的时候， 肯定是需要访问类的</li>
<li>声明一个类的指针变量也会访问类的</li>
<li>在程序运行期间，当某个类第一次被访问的时候，会将这个类存储到内存中的代码段区域，这个过程叫做类加载。</li>
<li>直到程序结束的时候才会被释放。</li>
</ol>

<h4 id="toc_3">对象在内存中的存储</h4>

<p>假设写在函数当中：<br/>
Person *p1 = [Person new];</p>

<ol>
<li>Person * p1 : 会在栈内存中申请一块空间，在栈内存中声明一个Person类型的指针变量p1(指针变量只能存储地址);</li>
<li>[Person new]: 真正在内存中创建对象的其实是这段代码;</li>
<li><p>new做的事情：</p></li>
</ol>

<ul>
<li>     在堆内存中申请一块合适大小的空间;</li>
<li>     在这个空间根据类的模板创建对象;</li>
<li>     类模板中定义了什么属性，就把这些属性依次声明在对象之中</li>
<li>     对象中还有另一个属性，叫做isa，这是一个指针，指向对象所属的类在代码段中的地址。</li>
<li>     初始化对象的属性：
    如果属性的类型是基本数据类型，那么就赋值0；<br/>
    如果属性的类型是C语言的指针类型，那么就赋值为NULL；<br/>
    如果属性的类型是OC的类指针类型，那么就赋值为nil</li>
</ul>

<p><img src="media/14848362414368/14876872482687.jpg" alt=""/></p>

<ul>
<li>     返回对象的地址</li>
</ul>

<p><img src="media/14848362414368/14876857739160.jpg" alt=""/></p>

<p>代码中的检测：<br/>
<img src="media/14848362414368/14876858990226.jpg" alt=""/></p>

<h4 id="toc_4">注意</h4>

<p>对象里面只有属性，没有方法(自己类的属性 + isa)；</p>

<p>如何访问对象的属性？</p>

<ul>
<li>  指针名-&gt;属性名；</li>
<li>  根据指针 找到指针指向的对象 再找到对象中的属性来访问；</li>
</ul>

<p>如何调用方法？</p>

<ul>
<li>  先根据指针名找到对象，对象发现要调用方法，在根据对象的isa指针找到类，然后调用类里面的方法；</li>
</ul>

<h4 id="toc_5">问题</h4>

<p>为什么不把方法存储在对象之中？  </p>

<ul>
<li>因为每一个对象的方法的代码实现都是一样的，没有必要为每一个对象都保存一个方法。
<img src="media/14848362414368/14876867543683.jpg" alt=""/></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C 编程]]></title>
    <link href="https://sparkbye.github.io/myBlog/14848334530232.html"/>
    <updated>2017-01-19T21:44:13+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/14848334530232.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>断断续续学习了好久的OC，一直没有提高，现在才完完全全信服了好记性不如烂笔头，今天开始坚持好好记录自己的学习过程，争取今年能上线一个自己满意的App，加油！</p>
</blockquote>

<h3 id="toc_0">1.最简单的一个例子</h3>

<pre><code>1. #import &lt;Foundation/Foundation.h&gt;
2. int main(int argc, const char *argv[])
3. {
4.     @autoreleasepool{
5.         NSLog(@&quot;Programming is fun!&quot;);
6.     }
7.     return 0;
8. }
</code></pre>

<ul>
<li class="task-list-item"><input disabled="disabled" type="checkbox" /> Objective C中，大小写是区分的；
</li>
<li class="task-list-item"><input disabled="disabled" type="checkbox" /> 编程时要养成插入注释的习惯；
</li>
</ul>

<h3 id="toc_1">2.程序解释</h3>

<p>第1行：程序告诉编译器找到并处理名为Foundation.h的文件；<br/>
第2行：指定程序的名称为main<br/>
问题：<br/>
<code>int argc, const char *argv[]</code>如何理解？<br/>
第4行：自动释放池；它的机制是：它使得应用在创建新对象时，系统能够有效地管理应用所使用的内存。<br/>
第5行：指定要调用名为NSLog的<strong>函数</strong><br/>
此处的@符号在位于一对双引号的字符串前面，这称为<strong>常量NSString对象</strong><br/>
第7行：表示要终止main的执行并返回一个状态值0；</p>

<h3 id="toc_2">3.练习</h3>

<h4 id="toc_3">第2题：</h4>

<pre><code>#import &lt;Foundation/Foundation.h&gt;
int main (int argc, const char * argv[])
{
    @autoreleasepool {
        NSLog(@&quot;In Objective-C, lowercase letters are significant.\nmain is where program execution begins.\nOpen and closed braces enclose program statements in a routine.\nAll program statements must be terminated by a semicolon.&quot;);
    }
    return 0;
}
</code></pre>

<h4 id="toc_4">第3题：</h4>

<pre><code>返回:
Testing...
....1
...2
..3
</code></pre>

<h4 id="toc_5">第4题：</h4>

<pre><code>#import &lt;Foundation/Foundation.h&gt;
int main (int argc, const char * argv[])
{
    @autoreleasepool{
        result = 87 - 15;
        NSLog(@&quot;The result is %i&quot;, result);
    }
    return 0;
}
</code></pre>

<h4 id="toc_6">第5题：</h4>

<pre><code>1. INT 改为int；
2. sum计算缺少；号；
3. NSLog要用“”号；
4. sum前缺少，号；
</code></pre>

<h4 id="toc_7">第6题：</h4>

<p><code>输出结果为：95</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[导航条navbar]]></title>
    <link href="https://sparkbye.github.io/myBlog/14841396902336.html"/>
    <updated>2017-01-11T21:01:30+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/14841396902336.html</id>
    <content type="html"><![CDATA[
<ol>
<li>navbar有<strong>背景色</strong></li>
<li>navbar可以是<strong>纯链接</strong>，也可以是<strong>表单</strong></li>
<li>navbar可以是表单和导航一起结合</li>
</ol>

<p>LESS版本：对应源文件navbar.less<br/>
Sass版本：对应元文件navbar.scss</p>

<h2 id="toc_0">基本导航条</h2>

<p>基本导航条分为两个步骤：<br/>
1. 制作导航的列表（<code>&lt;ul class=“navbar”&gt;</code>）基础上添上类名“navbar-nav”<br/>
2. 列表外部添加一个容器（div），使用类名“navbar”和“navbar-default”</p>

<p>“.navbar”样式主要功能：<br/>
* 设置左右padding<br/>
* 圆角</p>

<p>导航条的颜色是通过“.navbar-default”来控制，颜色和其他样式是通过配合父容器“navbar-default”来一起实现。</p>

<h2 id="toc_1">为导航条增加标题</h2>

<ol>
<li>navbar-header</li>
<li>navbar-brand</li>
</ol>

<h2 id="toc_2">带表单的导航条</h2>

<p>在navbar容器中放置一个带有navbar-form类名的表单。</p>

<pre><code>&lt;form action=&quot;##&quot; class=&quot;navbar-form navbar-left&quot; rol=&quot;search&quot;&gt;
    &lt;div class=&quot;form-group&quot;&gt;
        &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;请输入关键词&quot; /&gt;
    &lt;/div&gt;
    &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;搜索&lt;/button&gt;
&lt;/form&gt;
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bootstrap Study_1]]></title>
    <link href="https://sparkbye.github.io/myBlog/14834488859095.html"/>
    <updated>2017-01-03T21:08:05+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/14834488859095.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">What is Bootstrap</h2>

<ul>
<li>Free front-end framework </li>
<li>Includes HTML and CSS based design templates for typography, forms, buttons, tables, navigation, modals and many other.</li>
</ul>

<h3 id="toc_1">Containers</h3>

<ul>
<li>The <em>.container</em> class provides a responsive fixed width container</li>
<li>The <em>.container-fluid</em> class provides a full width container, spanning the entire width of the viewport</li>
</ul>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;title&gt;Bootstrap Example&lt;/title&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css&quot;&gt;
  &lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div class=&quot;container&quot;&gt;
  &lt;h1&gt;My First Bootstrap Page&lt;/h1&gt;
  &lt;p&gt;This is some text.&lt;/p&gt; 
&lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h3 id="toc_2">Grid classes</h3>

<p>The Bootstrap grid system has four classes:<br/>
* xs (for phones)<br/>
* sm (for tablets)<br/>
* md (for desktops)<br/>
* lg (for larger desktops)</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bootstrap Basic]]></title>
    <link href="https://sparkbye.github.io/myBlog/14832356716225.html"/>
    <updated>2017-01-01T09:54:31+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/14832356716225.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">基本的HTML模板</h2>

<ul>
<li>bootstrap模板为使IE6、7、8兼容， 需要引用下面的代码：</li>
</ul>

<pre><code>&lt;script src=&quot;https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js&quot;&gt;&lt;/script&gt;
</code></pre>

<ul>
<li>为使IE6、7、8兼容css3样式，需要引用下面的代码：</li>
</ul>

<pre><code>&lt;script src=&quot;https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js&quot;&gt;&lt;/script&gt;
</code></pre>

<ul>
<li>如果要使用Bootstrap的js插件，需要先调入jquery</li>
</ul>

<pre><code>&lt;script src=&quot;https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js&quot;&gt;&lt;/script&gt;
</code></pre>

<h2 id="toc_1">全局样式</h2>

]]></content>
  </entry>
  
</feed>
