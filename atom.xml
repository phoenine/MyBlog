<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Ascetic in the deadlock]]></title>
  <link href="https://sparkbye.github.io/myBlog/atom.xml" rel="self"/>
  <link href="https://sparkbye.github.io/myBlog/"/>
  <updated>2018-01-11T21:35:20+08:00</updated>
  <id>https://sparkbye.github.io/myBlog/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[Auto Install Stack(v2.0)]]></title>
    <link href="https://sparkbye.github.io/myBlog/15161073656469.html"/>
    <updated>2018-01-16T20:56:05+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15161073656469.html</id>
    <content type="html"><![CDATA[
<p>更新了脚本：</p>

<pre><code class="language-sh">#!/bin/bash

##############################################################################
# Use script like this:
# ./auto_install_stack.sh ${num}
#            run 1  --- will re-install stack with default image.
#            run 2  --- will re-install stack with specified image(install new stack with same yaml file).
#            run 3  --- will re-install stack with specified image and yaml parameter(first use this scripts).
##############################################################################

set -x

function echo__blue()            { echo -e &quot;\e[0;34;1m$1\e[0m&quot;;}
function echo__red()             { echo -e &quot;\e[0;31;1m$1\e[0m&quot;;}
function echo__green()           { echo -e &quot;\e[0;32;1m$1\e[0m&quot;;}
function echo__yellow()          { echo -e &quot;\e[0;33;1m$1\e[0m&quot;;}
function echo__red_shining()     { echo -e &quot;\033[31m \033[05m $2 \033[0m&quot;;}
function echo__blue_shining()    { echo -e &quot;\033[34m \033[05m $2 \033[0m&quot;;}

CURRENT_DIR=`pwd`
LOCAL_DIR=&quot;rcp-heat&quot;
STACK_TYPE=&quot;net&quot;
NUM=`echo ${CURRENT_DIR##*/} | tr -cd &quot;[0-9]&quot;`

if [ ${CURRENT_DIR##*/} != &quot;hranuser$NUM&quot; ];then
    echo__red &quot;======= Error: Current directory must be end with &#39;/hranuser&#39; ======&quot;
    exit -1
fi

if [ ! -d &quot;$LOCAL_DIR&quot; ];then
    mkdir -p $LOCAL_DIR
fi

function _create_image()
{
    IMAGE_FILE=`echo ${RCP_IMAGE_URL##*/} | cut -d &quot;.&quot; -f 1,2`
    IMAGE_EXIST=`glance image-list | grep $IMAGE_FILE | wc -l`
    if [ $IMAGE_EXIST -ne 0 ];then
        IMAGE_UUID=`glance image-list | grep $IMAGE_FILE | awk &#39;{print $2}&#39;`
        glance image-delete $IMAGE_UUID
        sleep 3
    fi
    echo__blue &quot;====== Begin to download RCP image to $LOCAL_DIR ======&quot;
    wget -O $LOCAL_DIR/${RCP_IMAGE_URL##*/} $RCP_IMAGE_URL
    if [ $? -ne 0 ];then
        echo__red &quot;====== Download image unsuceessfully, please check your image name is right ======&quot;
        exit -1
    fi
    echo__blue &quot;====== Download image suceessfully ======&quot;    
    echo__blue &quot;====== Begin to create image ======&quot;
    glance image-create --name=$IMAGE_FILE --container-format=bare --visibility=private --disk-format=qcow2 --file=$LOCAL_DIR/${RCP_IMAGE_URL##*/}
    IMAGE_UUID=`glance image-list | grep $IMAGE_FILE | awk &#39;{print $2}&#39;`
    while ((1))
    do
        GLANCE_STATUS=`glance image-show $IMAGE_UUID | grep status | awk &#39;{print $4}&#39;`
        if [ &quot;active&quot; != &quot;$GLANCE_STATUS&quot; ];then
            echo__blue &quot;====== Waiting for image active... ======&quot;
            sleep 5
        else
            break
        fi
    done
    echo__blue &quot;====== Create image suceessfully ======&quot;
    sleep 3
}

function _download_yaml()
{
    TEMPLATE_FILE=${RCP_TEMPLATE_URL##*/}
    echo__blue &quot;====== Downloading RCP template to $LOCAL_DIR/$TEMPLATE_FILE ======&quot;
    wget -O $LOCAL_DIR/$TEMPLATE_FILE $RCP_TEMPLATE_URL
    if [ $? -ne 0 ]
    then
        echo__red &quot;====== Download template unsuceessfully, please check your template file is right ======&quot;
        exit -1
    fi
    echo__blue &quot;====== Download template suceessfully ======&quot;
    ls -l $LOCAL_DIR
    tar -xzvf $LOCAL_DIR/$TEMPLATE_FILE -C $LOCAL_DIR
    rm -f $LOCAL_DIR/$TEMPLATE_FILE
}

function _uninstall_old_stack()
{
    echo__blue &quot;====== Begin to uninstall existed stack ======&quot;
    STACK_UUID=`openstack stack list | awk &#39;{print $2}&#39; | awk &#39;NR&gt;2&#39; | awk &#39;{if(length!=0) print $0}&#39;`
    ### === used for Multi-stack === ###
    # STACK_UUID=`openstack stack list | grep touchdown | awk &#39;{print $2}&#39; | awk &#39;{if(length!=0) print $0}&#39;`
    if [ -n &quot;$STACK_UUID&quot; ];then
        /usr/bin/expect &lt;&lt; EOF
        set time 10
        spawn openstack stack delete ${STACK_UUID}
        expect &quot;*y/N*&quot;
        send &quot;y\r&quot;
        expect eof
EOF
    fi
    while ((1))
    do
        STACK_STATUS=`openstack stack list | awk &#39;{print $6}&#39; | awk &#39;NR&gt;2&#39; | awk &#39;{if(length!=0) print $0}&#39;`
        if [ -n &quot;${STACK_STATUS}&quot; ];then
            sleep 10
            echo__blue &quot;====== Deleting old stack, please wait... ======&quot;
        else
            break
        fi
    done
    echo__blue &quot; === Uninstall existed stack successfully === &quot;
}

function _mod_env_file_part()
{
    echo__blue &quot;====== Begin to modify env file... ======&quot;
    image=`echo ${REPLY##*/} | cut -d &quot;.&quot; -f 1,2`
    RCP_HEAT_FILE=&quot;rcp-heat/$STACK_TYPE/rcp-heat.env&quot;
    sed -i &quot;s/image: .*/image: $image/g&quot; $RCP_HEAT_FILE
    echo__blue &quot;====== Modify successfully ======&quot;
}

function _mod_env_file_full()
{
    echo__blue &quot;====== Begin to modify env file... ======&quot;  
    availability_zone=&quot;nova&quot;
    cluster_id=&quot;RCP-1234&quot;
    dns_forwarders=&quot;10.56.126.31&quot;
    config_drive=&quot;false&quot;
    ext0=&quot;`neutron net-list | grep hran${num} | awk &#39;{print $4}&#39; | awk &#39;NR==1&#39;`&quot;
    ext1=&quot;`neutron net-list | grep hran${num} | awk &#39;{print $4}&#39; | awk &#39;NR==2&#39;`&quot;
    ext2=&quot;`neutron net-list | grep hran${num} | awk &#39;{print $4}&#39; | awk &#39;NR==3&#39;`&quot;
    cp=&quot;rcp_medium_v2&quot;
    ei=&quot;rcp_xlarge_v2&quot;
    mn=&quot;rcp_large_v2&quot;
    up=&quot;rcp_xlarge_v2&quot;
    uvm=&quot;rcp_medium_v2&quot;
    hostname_prefix=&quot;abc&quot;
    image=`echo ${RCP_IMAGE_URL##*/} | cut -d &quot;.&quot; -f 1,2`
    key_name=`nova keypair-list | awk &#39;NR&gt;2&#39; | awk &#39;{print $2}&#39; | awk &#39;{if(length!=0) print $0}&#39;`
    if [ -z &quot;$key_name&quot; ];then
        nova keypair-add default_key
        key_name=`nova keypair-list | awk &#39;NR&gt;2&#39; | awk &#39;{print $2}&#39; | awk &#39;{if(length!=0) print $0}&#39;`
    fi
    ntp_servers=&quot;10.39.12.252&quot;
    number_of_uvm_nodes=&quot;0&quot;
    ### use oam uuid
    #oam_network=&quot;`nova network-list | grep -w &quot;vnfoam &quot; | awk &#39;{print $2}&#39;`&quot;
    ### use oam name
    oam_network=&quot;vnfoam&quot;
    _nokadmin=&quot;Nokia123&quot;
    _nokfsoperator=&quot;RCP_owner&quot;
    root=&quot;root&quot;
    time_zone=&quot;Asia/Shanghai&quot;    
    vif_models=&quot;avp&quot;
    vif_models_2=&quot;virtio&quot;  
    rcp_heat_file=&quot;rcp-heat/$STACK_TYPE/rcp-heat.env&quot;
    sed -i &quot;s/availability_zone: .*/availability_zone: $availability_zone/g&quot; ${rcp_heat_file}
    sed -i &quot;s/cluster_id: .*/cluster_id: $cluster_id/g&quot; ${rcp_heat_file}
    sed -i &quot;s/dns_forwarders: .*/dns_forwarders: $dns_forwarders/g&quot; ${rcp_heat_file}
    sed -i &quot;s/config_drive: .*/config_drive: $config_drive/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ext0: .*/ext0: $ext0/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ext1: .*/ext1: $ext1/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ext2: .*/ext2: $ext2/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ cp: .*/ cp: $cp/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ ei: .*/ ei: $ei/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ mn: .*/ mn: $mn/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ up: .*/ up: $up/g&quot; ${rcp_heat_file}
    sed -i &quot;s/uvm: .*/uvm: $uvm/g&quot; ${rcp_heat_file}
    sed -i &quot;s/hostname_prefix: .*/hostname_prefix: $hostname_prefix/g&quot; ${rcp_heat_file}
    sed -i &quot;s/image: .*/image: $image/g&quot; ${rcp_heat_file}
    sed -i &quot;s/key_name: .*/key_name: $key_name/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ntp_servers: .*/ntp_servers: $ntp_servers/g&quot; ${rcp_heat_file}
    sed -i &quot;s/number_of_uvm_nodes: .*/number_of_uvm_nodes: $number_of_uvm_nodes/g&quot; ${rcp_heat_file}
    sed -i &quot;s/oam_network: .*/oam_network: $oam_network/g&quot; ${rcp_heat_file}
    sed -i &quot;s/_nokadmin: .*/_nokadmin: $_nokadmin/g&quot; ${rcp_heat_file}
    sed -i &quot;s/_nokfsoperator: .*/_nokfsoperator: $_nokfsoperator/g&quot; ${rcp_heat_file}
    sed -i &quot;s/root: .*/root: $root/g&quot; ${rcp_heat_file}
    sed -i &quot;s#time-zone: .*#time-zone: $time_zone#g&quot; ${rcp_heat_file}
    sed -i &quot;s/uvm_image: .*/uvm_image: $image/g&quot; ${rcp_heat_file}  
    sed -i &quot;s/ external: .*/ external: $vif_models/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ internal: .*/ internal: $vif_models_2/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ oam: .*/ oam: $vif_models/g&quot; ${rcp_heat_file}   
    echo__blue &quot;====== Modify successfully ======&quot;
}

function _launch_stack()
{
    echo__blue &quot;====== Begin to launch stack ======&quot;
    openstack stack create -f yaml -e $LOCAL_DIR/$STACK_TYPE/rcp-heat.env -t $LOCAL_DIR/$STACK_TYPE/rcp-heat.yaml ${CURRENT_DIR##*/}_auto
    while ((1))
    do
        STACK_STATUS=`openstack stack list | awk &#39;{print $6}&#39; | awk &#39;NR&gt;2&#39; | awk &#39;{if(length!=0) print $0}&#39;`
        if [ &quot;CREATE_COMPLETE&quot; != &quot;${STACK_STATUS}&quot; ];then
            sleep 30
            echo__blue &quot;====== Installing, please wait... ======&quot;
        else
            break
        fi
    done
    oam=`nova list | grep vnfoam | awk &#39;{print $13}&#39;`
    echo__blue_shining &quot;====== Launch stack successfully, ${oam} DONE ====== \033[05m ${oam}&quot;
}

function reinstall_stack_1()
{
    _uninstall_old_stack
    _launch_stack
}

function reinstall_stack_2()
{
    _create_image $REPLY
    _uninstall_old_stack
    _mod_env_file_part
    _launch_stack
    rm -f $LOCAL_DIR/${REPLY##*/}
}

function reinstall_stack_3()
{
    _download_yaml
    _mod_env_file_full
    _create_image ${RCP_IMAGE_URL}
    _uninstall_old_stack
    _launch_stack
    rm -f $LOCAL_DIR/${RCP_IMAGE_URL##*/}
}


case &quot;$1&quot; in
    1)
      echo &quot;Begin to re-install stack.....&quot;
      reinstall_stack_1
      echo &quot;Script completes!!!!!&quot;
      exit 1
      ;;
    2)
      read -p &quot;Please input specified image url: &quot;
      echo &quot;Begin to re-install stack with image ${REPLY##*/}.....&quot;
      reinstall_stack_2
      echo &quot;Script completes!!!!!&quot;
      exit 1
      ;;
    3)
      read -p &quot;Please input specified image url: &quot; RCP_IMAGE_URL
      read -p &quot;Please input specified yaml url: &quot; RCP_TEMPLATE_URL
      echo &quot;Begin to re-install stack with image ${RCP_IMAGE_URL##*/} and yaml ${RCP_TEMPLATE_URL##*/}.....&quot;
      reinstall_stack_3
      echo &quot;Script completes!!!!!&quot;
      exit 1
      ;;
    *)
      echo &quot;Usage:
            run 1  --- will re-install stack with default image.
            run 2  --- will re-install stack with specified image.
            run 3  --- will re-install stack with specified image and yaml parameter.&quot;
      exit 1
      ;;
esac
exit 0
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Auto Install Stack]]></title>
    <link href="https://sparkbye.github.io/myBlog/15161072350728.html"/>
    <updated>2018-01-16T20:53:55+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15161072350728.html</id>
    <content type="html"><![CDATA[
<p>自动安装脚本：</p>

<pre><code class="language-sh">#!/bin/bash

##############################################################################
# Use script like this:
# ./auto_install_stack.sh ${num}
#            run 1  --- will re-install stack with default image.
#            run 2  --- will re-install stack with specified image(install new stack with same yaml file).
#            run 3  --- will re-install stack with specified image and yaml parameter(first use this scripts).
##############################################################################

set +x

function echo_color(){
    case $1 in
        &quot;red&quot;)
            echo -e &quot;\033[31m $2 \033[0m&quot; ;;
        &quot;red-shining&quot;)
            echo -e &quot;\033[31m \033[05m $2 \033[0m&quot; ;;
        &quot;yellow&quot;)
            echo -e &quot;\033[33m $2 \033[0m&quot; ;;
        &quot;blue&quot;)
            echo -e &quot;\033[34m $2 \033[0m&quot; ;;
        &quot;blue-shining&quot;)
            echo -e &quot;\033[34m \033[05m $2 \033[0m&quot; ;;
        &quot;purple&quot;)
            echo -e &quot;\033[35m $2 \033[0m&quot; ;;
        &quot;green&quot;)
            echo -e &quot;\033[32m $2 \033[0m&quot; ;;
        &quot;*&quot;)
            echo -e &quot;\033[37m $2 \033[0m&quot; ;;
    esac
}

current_dir=`pwd`
num=`echo ${current_dir##*/} | tr -cd &quot;[0-9]&quot;`
if [ ${current_dir##*/} != &quot;hranuser${num}&quot; ]
then
    echo_color red &quot; === Error: Current directory must be end with &#39;/hranuser&#39; ===&quot;
    exit -1
fi
local_dir=&quot;rcp-heat&quot;
stack_type=&quot;net&quot;
if [ ! -d &quot;${local_dir}&quot; ]
then
    mkdir -p ${local_dir}
fi

function _create_image()
{
    RCP_IMAGE_URL=$1
    IMAGE_FILE=${RCP_IMAGE_URL##*/}
    echo_color blue &quot; === Begin to download RCP image to ${local_dir}/${IMAGE_FILE} === &quot;
    wget -O ${local_dir}/${IMAGE_FILE} ${RCP_IMAGE_URL}
    if [ $? -ne 0 ]
    then
        set +x
        echo_color red &quot; === Download image unsuceessfully, please check your image name is right === &quot;
        exit -1
    fi
    echo_color blue &quot; === Download image suceessfully ==== &quot;
    echo_color blue &quot; === Begin to create image === &quot;
    nova image-delete ${IMAGE_FILE}
    glance image-create --name=${IMAGE_FILE} --container-format=bare --visibility=private --disk-format=qcow2 --file=${local_dir}/${IMAGE_FILE}
    glance_status=`nova image-show ${IMAGE_FILE} | grep status | awk &#39;{print $4}&#39;`
    if [ &quot;ACTIVE&quot; != &quot;${glance_status}&quot; ]
    then
        echo_color blue-shining &quot; === Waiting for image active... ==== &quot;
        sleep 5
    fi
    echo_color blue &quot; === Create image suceessfully ==== &quot;
    sleep 3
}

function _download_yaml()
{
    TEMPLATE_FILE=${RCP_TEMPLATE_URL##*/}
    echo_color blue &quot; === Downloading RCP template to ${local_dir}/${TEMPLATE_FILE} === &quot;
    wget -O ${local_dir}/${TEMPLATE_FILE} ${RCP_TEMPLATE_URL}
    if [ $? -ne 0 ]
    then
        set +x
        echo_color red &quot; === Download template unsuceessfully, please check your template file is right === &quot;
        exit -1
    fi
    echo_color blue &quot; === Download template suceessfully ==== &quot;
    ls -l ${local_dir}
    tar -xzvf ${local_dir}/${TEMPLATE_FILE} -C ${local_dir}
    rm -f ${local_dir}/${TEMPLATE_FILE}
}

function _uninstall_old_stack()
{
    echo_color blue &quot; === Begin to uninstall existed stack === &quot;
    ### === used for N34 === ###
    STACK_UUID=`heat stack-list | awk &#39;{print $2}&#39; | awk &#39;NR&gt;2&#39; | awk &#39;{if(length!=0) print $0}&#39;`
    ### === used for touchdown === ###
    # STACK_UUID=`heat stack-list | grep touchdown | awk &#39;{print $2}&#39; | awk &#39;{if(length!=0) print $0}&#39;`
    if [ -n &quot;${STACK_UUID}&quot; ]
    then    
        heat stack-delete ${STACK_UUID}
        while ((1))
        do
            set +x
            STACK_STATUS=`heat stack-list | awk &#39;{print $6}&#39; | awk &#39;NR&gt;2&#39; | awk &#39;{if(length!=0) print $0}&#39;`
            if [ -n &quot;${STACK_STATUS}&quot; ]
            then
                sleep 10
                echo_color blue &quot; === Deleting old stack, please wait... === &quot;
            else
                break
            fi
        done
    fi
    echo_color blue &quot; === Uninstall existed stack successfully === &quot;
}

function _mod_env_file_part()
{
    echo_color blue &quot; === Begin to modify env file... === &quot;
    RCP_IMAGE_URL=$REPLY
    IMAGE_FILE=${RCP_IMAGE_URL##*/}
    rcp_heat_file=&quot;rcp-heat/net/rcp-heat.env&quot;
    sed -i &quot;s/image: .*/image: ${IMAGE_FILE}/g&quot; ${rcp_heat_file}
    echo_color blue &quot; === Modify successfully. === &quot;
}

function _mod_env_file_full()
{
    echo_color blue &quot; === Begin to modify env file... === &quot;
    IMAGE_FILE=${RCP_IMAGE_URL##*/}
    key_name=&quot;default_key&quot;
    cluster_id=&quot;RCP-1234&quot;
    hostname_prefix=&quot;abc&quot;
    cp=&quot;rcp_medium_v2&quot;
    ei=&quot;rcp_xlarge_v2&quot;
    mn=&quot;rcp_large_v2&quot;
    up=&quot;rcp_xlarge_v2&quot;
    uvm=&quot;rcp_medium_v2&quot;
    time_zone=&quot;Asia/Shanghai&quot;
    ### use oam uuid
    #oam_network=&quot;`nova network-list | grep -w &quot;vnfoam &quot; | awk &#39;{print $2}&#39;`&quot;
    ### use oam name
    oam_network=&quot;vnfoam&quot;
    ntp_servers=&quot;10.39.12.252&quot;
    dns_forwarders=&quot;10.56.126.31&quot;
    vif_models=&quot;avp&quot;
    vif_models_2=&quot;virtio&quot;
    _nokadmin=&quot;Nokia123&quot;
    _nokfsoperator=&quot;RCP_owner&quot;
    root=&quot;root&quot;
    ext0=&quot;`nova network-list | grep hran${num} | awk &#39;{print $4}&#39; | awk &#39;NR==1&#39;`&quot;
    ext1=&quot;`nova network-list | grep hran${num} | awk &#39;{print $4}&#39; | awk &#39;NR==2&#39;`&quot;
    ext2=&quot;`nova network-list | grep hran${num} | awk &#39;{print $4}&#39; | awk &#39;NR==3&#39;`&quot;
    number_of_uvm_nodes=&quot;0&quot;
    rcp_heat_file=&quot;rcp-heat/net/rcp-heat.env&quot;
    sed -i &quot;s/image: .*/image: ${IMAGE_FILE}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/key_name: .*/key_name: ${key_name}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/cluster_id: .*/cluster_id: ${cluster_id}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/hostname_prefix: .*/hostname_prefix: ${hostname_prefix}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ cp: .*/ cp: ${cp}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ ei: .*/ ei: ${ei}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ mn: .*/ mn: ${mn}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ up: .*/ up: ${up}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/uvm: .*/uvm: ${uvm}/g&quot; ${rcp_heat_file}
    sed -i &quot;s#time-zone: .*#time-zone: ${time_zone}#g&quot; ${rcp_heat_file}
    sed -i &quot;s/oam_network: .*/oam_network: ${oam_network}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ntp_servers: .*/ntp_servers: ${ntp_servers}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/dns_forwarders: .*/dns_forwarders: ${dns_forwarders}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/_nokadmin: .*/_nokadmin: ${_nokadmin}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/_nokfsoperator: .*/_nokfsoperator: ${_nokfsoperator}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/root: .*/root: ${root}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ext0: .*/ext0: ${ext0}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ext1: .*/ext1: ${ext1}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ext2: .*/ext2: ${ext2}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ external: .*/ external: ${vif_models}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ internal: .*/ internal: ${vif_models_2}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/ oam: .*/ oam: ${vif_models}/g&quot; ${rcp_heat_file}
    sed -i &quot;s/number_of_uvm_nodes: .*/number_of_uvm_nodes: ${number_of_uvm_nodes}/g&quot; ${rcp_heat_file}
    nova keypair-add ${key_name}
    echo_color blue &quot; === Modify successfully. === &quot;
}

function _launch_stack()
{
    echo_color blue &quot; === Begin to launch stack === &quot;
    heat stack-create -e ${local_dir}/${stack_type}/rcp-heat.env -f ${local_dir}/${stack_type}/rcp-heat.yaml touchdown_auto
    while ((1))
    do
        set +x
        STACK_STATUS=`heat stack-list | awk &#39;{print $6}&#39; | awk &#39;NR&gt;2&#39; | awk &#39;{if(length!=0) print $0}&#39;`
        if [ &quot;CREATE_COMPLETE&quot; != &quot;${STACK_STATUS}&quot; ]
        then
            sleep 30
            echo_color blue &quot; === Installing, please wait... === &quot;
        else
            break
        fi
    done
    oam=`nova list | grep vnfoam | awk &#39;{print $14}&#39;`
    echo_color blue &quot; === Launch stack successfully, ${oam} === \033[05m ${oam} &quot;
}

function reinstall_stack_1()
{
    _uninstall_old_stack
    _launch_stack
}

function reinstall_stack_2()
{
    _create_image $REPLY
    _uninstall_old_stack
    _mod_env_file_part
    _launch_stack
    rm -f ${local_dir}/${IMAGE_FILE}
}

function reinstall_stack_3()
{
    _download_yaml
    _mod_env_file_full
    _create_image ${RCP_IMAGE_URL}
    _uninstall_old_stack
    _launch_stack
    rm -f ${local_dir}/${IMAGE_FILE}
}


case &quot;$1&quot; in
    1)
      echo &quot;Begin to re-install stack.....&quot;
      reinstall_stack_1
      echo &quot;Script completes!!!!!&quot;
      exit 1
      ;;
    2)
      read -p &quot;Please input specified image url: &quot;
      echo &quot;Begin to re-install stack with image ${REPLY##*/}.....&quot;
      reinstall_stack_2
      echo &quot;Script completes!!!!!&quot;
      exit 1
      ;;
    3)
      read -p &quot;Please input specified image url: &quot; RCP_IMAGE_URL
      read -p &quot;Please input specified yaml url: &quot; RCP_TEMPLATE_URL
      echo &quot;Begin to re-install stack with image ${RCP_IMAGE_URL##*/} and yaml ${RCP_TEMPLATE_URL##*/}.....&quot;
      reinstall_stack_3
      echo &quot;Script completes!!!!!&quot;
      exit 1
      ;;
    *)
      echo &quot;Usage:
            run 1  --- will re-install stack with default image.
            run 2  --- will re-install stack with specified image.
            run 3  --- will re-install stack with specified image and yaml parameter.&quot;
      exit 1
      ;;
esac
exit 0
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Auto Migrate Tools(v2.0)]]></title>
    <link href="https://sparkbye.github.io/myBlog/15161070375181.html"/>
    <updated>2018-01-16T20:50:37+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15161070375181.html</id>
    <content type="html"><![CDATA[
<p>更新了下脚本：<br/>
还是有些问题：<br/>
1. 如果有其他Project的node怎么处理？<br/>
2. 如果有自己的其他node怎么处理？</p>

<pre><code class="language-sh">#!/bin/bash

function echo__blue()      { echo -e &quot;\e[0;34;1m$1\e[0m&quot;;}
function echo__red()       { echo -e &quot;\e[0;31;1m$1\e[0m&quot;;}
function echo__green()     { echo -e &quot;\e[0;32;1m$1\e[0m&quot;;}
function echo__yellow()    { echo -e &quot;\e[0;33;1m$1\e[0m&quot;;}

COMPUTER_LIST=`nova hypervisor-list | awk &#39;{print $4}&#39; | awk &#39;NR&gt;2&#39; | awk &#39;{if(length!=0) print $0}&#39;`
UE_NODE_LIST=`nova list | grep ei | awk &#39;{print $4}&#39;`
UE_NODE_NAME=`nova list | grep ei-0 | awk &#39;{print $4}&#39;`
OTHER_NODE_LIST=`nova list --fields name | grep -v ei | awk &#39;NR&gt;2&#39; | awk &#39;{print $4}&#39; | awk &#39;{if(length!=0) print $0}&#39;`
OPTIMAL_COMPUTE=&#39;&#39;
INFERIOR_COMPUTE=&#39;&#39;
INIT_USED=8.0

for COMPUTER in $COMPUTER_LIST
    do
        CPUS_USED=`nova hypervisor-show $COMPUTER | grep -i &quot;vcpus_used&quot; | awk &#39;{print $4}&#39; | head -1`
        echo__blue &quot;$COMPUTER node&#39;s vcpus_used is :  $CPUS_USED&quot;
        if [[ $(echo &quot;$CPUS_USED == 0.0&quot;|bc) = 1 ]];then
            echo__blue &quot;Greate! $COMPUTER is a optimal computer.&quot;
            OPTIMAL_COMPUTER=$COMPUTER
            break
        elif [[ $(echo &quot;$CPUS_USED &gt; 0.0&quot;|bc) = 1 ]] &amp;&amp; [[ $(echo &quot;$CPUS_USED &lt; 8.0 &quot;|bc) = 1 ]];then
            echo__green &quot;Maybe $COMPUTER is a selectable computer.&quot;
            if [[ $(echo &quot;$CPUS_USED &lt; $INIT_USED&quot;|bc) = 1 ]];then
                INIT_USED=$CPUS_USED
                INFERIOR_COMPUTE=$COMPUTER
                echo__blue &quot;Now OPTIMAL_COMPUTER is: $COMPUTER.&quot;
            fi
        elif [[ $(echo &quot;$CPUS_USED &gt;= 8.0&quot;|bc) = 1 ]] &amp;&amp; [[ $(echo &quot;$CPUS_USED &lt;= 13.0 &quot;|bc) = 1 ]];then
            echo__red &quot;Maybe $COMPUTER is not a good choice.&quot;
            INSTANCE_NUMBER=`nova hypervisor-servers compute-159 | awk &#39;{print $4}&#39; | awk &#39;NR&gt;2&#39; | awk &#39;{if(length!=0) print $0}&#39; | wc -l`
            USED_RATE=$(echo &quot;$CPUS_USED / $INSTANCE_NUMBER&quot; | bc)
            echo &quot;===========USED_RATE: $USED_RATE=============&quot;
            if [[ $(echo &quot;$USED_RATE &lt; $INIT_USED&quot;|bc) = 1 ]];then
                INIT_USED=$USED_RATE
                echo &quot;===========INIT_USED: $INIT_USED=============&quot;
                INFERIOR_COMPUTE=$COMPUTER
                echo__blue &quot;Now OPTIMAL_COMPUTER is: $COMPUTER.&quot;
            else
                continue
            fi
        else
            echo__red &quot;This computer node is full.&quot;
        fi
    done
    echo &quot;===========Finally the chosen computer is : 1. $OPTIMAL_COMPUTER  2. $INFERIOR_COMPUTE.==============&quot;

for INSTANCE_NAME in $OTHER_NODE_LIST
        do
            UE_COMPUTE=`nova list --fields name,host,wrs-res:topology | grep $INSTANCE_NAME | awk &#39;{print $6}&#39;`
            CPUS_USED=`nova hypervisor-show $UE_COMPUTE | grep -i &quot;vcpus_used&quot; | awk &#39;{print $4}&#39; | head -1`
            echo__blue &quot;$UE_COMPUTE node&#39;s vcpus_used is :  $CPUS_USED&quot;
            if [[ $(echo &quot;$CPUS_USED == 8.0&quot;|bc) = 1 ]];then
                echo__blue &quot;Greate! $UE_COMPUTE is a optimal computer.&quot;
                OPTIMAL_COMPUTER=$UE_COMPUTE
                break
            else
                continue
            fi
        done
    echo__red &quot;All UE instance are not stand alone.&quot;

for INSTANCE_NAME in $UE_NODE_LIST
        do
            UE_COMPUTE=`nova list --fields name,host,wrs-res:topology | grep $INSTANCE_NAME | awk &#39;{print $6}&#39;`
            CPUS_USED=`nova hypervisor-show $UE_COMPUTE | grep -i &quot;vcpus_used&quot; | awk &#39;{print $4}&#39; | head -1`
            echo__blue &quot;$UE_COMPUTE node&#39;s vcpus_used is :  $CPUS_USED&quot;
            if [[ $(echo &quot;$CPUS_USED == 8.0&quot;|bc) = 1 ]];then
                echo__blue &quot;Greate! $UE_COMPUTE is a optimal computer.&quot;
                OPTIMAL_COMPUTER=$UE_COMPUTE
                break
            else
                continue
            fi
        done
    echo__red &quot;All other instance are not stand alone.&quot;

echo__green &quot;==============Begin to migrate UE node to $OPTIMAL_COMPUTER.=====================&quot;
if [[ -z &quot;$OPTIMAL_COMPUTER&quot; ]];then
    for UE_NODE in $UE_NODE_LIST
        do
            nova live-migration $UE_NODE $OPTIMAL_COMPUTER
            sleep 5
            if [ &quot;Running&quot; != &quot;$UE_NODE_STATE&quot; ];then
                echo &quot;Still migrating, please wait...&quot;
                sleep 5     
            fi
        done
else
    for UE_NODE in $UE_NODE_LIST
        do
            nova live-migration $UE_NODE $INFERIOR_COMPUTE
            sleep 5
            if [ &quot;Running&quot; != &quot;$UE_NODE_STATE&quot; ];then
                echo &quot;Still migrating, please wait...&quot;
                sleep 5     
            fi
        done   
fi

echo__green &quot;Live migration is successfully.&quot;
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python对象的浅拷贝与深拷贝]]></title>
    <link href="https://sparkbye.github.io/myBlog/15156751072902.html"/>
    <updated>2018-01-11T20:51:47+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15156751072902.html</id>
    <content type="html"><![CDATA[
<p>我们知道，对象赋值实际上是简单的对象引用。也就是说，当你创建了一个对象，然后把它赋值给另外一个变量的时候，Python并没有拷贝这个对象，而是拷贝了这个对象的引用。<br/>
举例说明：</p>

<pre><code class="language-python">x = 3.14
y = x
</code></pre>

<p>语句<code>x = 3.14</code>创建了一个浮点型对象并将其引用赋值给x。<br/>
x是第一个引用。<br/>
语句<code>y = x</code>创建了一个指向同一对象的别名y，而事实上并没有为y创建一个新对象(该对象引用计数变成了2)。<br/>
<img src="media/15156751072902/15156757071783.jpg" alt=""/></p>

<h3 id="toc_0">对象赋值</h3>

<p>直接看一段代码：</p>

<pre><code class="language-python">will = [&quot;Will&quot;, 28, [&quot;Python&quot;, &quot;C#&quot;, &quot;JavaScript&quot;]]
wilber = will
print id(will)
print will
print [id(ele) for ele in will]
print id(wilber)
print wilber
print [id(ele) for ele in wilber]

will[0] = &quot;Wilber&quot;
will[2].append(&quot;CSS&quot;)
print id(will)
print will
print [id(ele) for ele in will]
print id(wilber)
print wilber
print [id(ele) for ele in wilber]
</code></pre>

<p>代码的输出为：<br/>
<img src="media/15156751072902/15156770585054.png" alt=""/></p>

<p>下面来分析一下这段代码：</p>

<ul>
<li>首先，创建了一个名为will的变量，这个变量指向一个list对象，从第一张图中可以看到所有对象的地址（每次运行，结果可能不同）</li>
<li>然后，通过will变量对wilber变量进行赋值，那么wilber变量将指向will变量对应的对象（内存地址），也就是说&quot;wilber is will&quot;，&quot;wilber[i] is will[i]&quot;

<ul>
<li>可以理解为，Python中，对象的赋值都是进行对象引用（内存地址）传递</li>
</ul></li>
<li>第三张图中，由于will和wilber指向同一个对象，所以对will的任何修改都会体现在wilber上

<ul>
<li>这里需要注意的一点是，str是不可变类型，所以当修改的时候会替换旧的对象，产生一个新的地址39758496
<img src="media/15156751072902/15156771227464.png" alt=""/></li>
</ul></li>
</ul>

<h3 id="toc_1">浅拷贝</h3>

<p>下面就来看看浅拷贝的结果：</p>

<pre><code class="language-python">import copy

will = [&quot;Will&quot;, 28, [&quot;Python&quot;, &quot;C#&quot;, &quot;JavaScript&quot;]]
wilber = copy.copy(will)

print id(will)
print will
print [id(ele) for ele in will]
print id(wilber)
print wilber
print [id(ele) for ele in wilber]

will[0] = &quot;Wilber&quot;
will[2].append(&quot;CSS&quot;)
print id(will)
print will
print [id(ele) for ele in will]
print id(wilber)
print wilber
print [id(ele) for ele in wilber]
</code></pre>

<p>代码的输出结果如下：<br/>
<img src="media/15156751072902/15156771638072.png" alt=""/><br/>
分析一下这段代码：</p>

<ul>
<li>首先，依然使用一个will变量，指向一个list类型的对象</li>
<li>然后，通过copy模块里面的浅拷贝函数copy()，对will指向的对象进行浅拷贝，然后浅拷贝生成的新对象赋值给wilber变量

<ul>
<li>浅拷贝会创建一个新的对象，这个例子中&quot;wilber is not will&quot;</li>
<li>但是，对于对象中的元素，浅拷贝就只会使用原始元素的引用（内存地址），也就是说&quot;wilber[i] is will[i]&quot;</li>
</ul></li>
<li>当对will进行修改的时候

<ul>
<li>由于list的第一个元素是不可变类型，所以will对应的list的第一个元素会使用一个新的对象39758496</li>
<li>但是list的第三个元素是一个可不类型，修改操作不会产生新的对象，所以will的修改结果会相应的反应到wilber上
<img src="media/15156751072902/15156771821899.png" alt=""/>
总结一下，当我们使用下面的操作的时候，会产生浅拷贝的效果：</li>
</ul></li>
<li>使用切片[:]操作</li>
<li>使用工厂函数（如list/dir/set）</li>
<li>使用copy模块中的copy()函数
例如：</li>
</ul>

<pre><code class="language-python">will = [&quot;Will&quot;, 28, [&quot;Python&quot;, &quot;C#&quot;, &quot;JavaScript&quot;]]
willber = will[:]
wiww = list(will)
</code></pre>

<h3 id="toc_2">深拷贝</h3>

<p>最后来看看深拷贝：</p>

<pre><code class="language-python">import copy

will = [&quot;Will&quot;, 28, [&quot;Python&quot;, &quot;C#&quot;, &quot;JavaScript&quot;]]
wilber = copy.deepcopy(will)

print id(will)
print will
print [id(ele) for ele in will]
print id(wilber)
print wilber
print [id(ele) for ele in wilber]

will[0] = &quot;Wilber&quot;
will[2].append(&quot;CSS&quot;)
print id(will)
print will
print [id(ele) for ele in will]
print id(wilber)
print wilber
print [id(ele) for ele in wilber]
</code></pre>

<p>代码的输出结果如下：<br/>
<img src="media/15156751072902/15156773634373.png" alt=""/></p>

<p>分析一下这段代码：</p>

<ul>
<li>首先，同样使用一个will变量，指向一个list类型的对象</li>
<li>然后，通过copy模块里面的深拷贝函数deepcopy()，对will指向的对象进行深拷贝，然后深拷贝生成的新对象赋值给wilber变量

<ul>
<li>跟浅拷贝类似，深拷贝也会创建一个新的对象，这个例子中&quot;wilber is not will&quot; </li>
<li>但是，对于对象中的元素，深拷贝都会重新生成一份（有特殊情况，下面会说明），而不是简单的使用原始元素的引用（内存地址）

<ul>
<li>例子中will的第三个元素指向39737304，而wilber的第三个元素是一个全新的对象39773088，也就是说，&quot;wilber[2] is not will[2]&quot;</li>
</ul></li>
</ul></li>
<li>当对will进行修改的时候

<ul>
<li>由于list的第一个元素是不可变类型，所以will对应的list的第一个元素会使用一个新的对象39758496</li>
<li>但是list的第三个元素是一个可不类型，修改操作不会产生新的对象，但是由于&quot;wilber[2] is not will[2]&quot;，所以will的修改不会影响wilber
<img src="media/15156751072902/15156773891985.png" alt=""/></li>
</ul></li>
</ul>

<h3 id="toc_3">拷贝的特殊情况</h3>

<p>其实，对于拷贝有一些特殊情况：</p>

<ul>
<li>对于非容器类型（如数字、字符串、和其他&#39;原子&#39;类型的对象）没有拷贝这一说

<ul>
<li>也就是说，对于这些类型，&quot;obj is copy.copy(obj)&quot; 、&quot;obj is copy.deepcopy(obj)&quot;</li>
</ul></li>
<li>如果元祖变量只包含原子类型对象，则不能深拷贝，看下面的例子
<img src="media/15156751072902/15156774222287.png" alt=""/></li>
</ul>

<h3 id="toc_4">总结</h3>

<p>本文介绍了对象的赋值和拷贝，以及它们之间的差异：<br/>
* Python中对象的赋值都是进行对象引用（内存地址）传递<br/>
* 使用copy.copy()，可以进行对象的浅拷贝，它复制了对象，但对于对象中的元素，依然使用原始的引用.<br/>
* 如果需要复制一个容器对象，以及它里面的所有元素（包含元素的子元素），可以使用copy.deepcopy()进行深拷贝<br/>
* 对于非容器类型（如数字、字符串、和其他&#39;原子&#39;类型的对象）没有被拷贝一说<br/>
* 如果元祖变量只包含原子类型对象，则不能深拷贝.</p>

<p>文章引用：<br/>
<a href=""></a><a href="https://www.cnblogs.com/wilber2013/p/4645353.html">https://www.cnblogs.com/wilber2013/p/4645353.html</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pyhton变量变换原理]]></title>
    <link href="https://sparkbye.github.io/myBlog/15142967450536.html"/>
    <updated>2017-12-26T21:59:05+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15142967450536.html</id>
    <content type="html"><![CDATA[
<p>我们在C语言中实现变量交换，往往会使用到通过中间变量来交换两个变量的值：</p>

<pre><code class="language-C">tmp = x;
x = y;
y = tmp;
</code></pre>

<p>而在python中，则无需中间变量即可实现：</p>

<pre><code class="language-python">x , y = y, x
</code></pre>

<p>看起来很神奇，那么具体实现机制是什么呢？<br/>
将这个之前，我们先来了解python的多元赋值机制(《python核心编程3.2》)。通常形式是这样的：</p>

<pre><code class="language-python">x, y , z = 1, 2, &#39;a string&#39;
</code></pre>

<p>采取这种方式的赋值是，等号两边的对象其实都是元祖，即：</p>

<pre><code class="language-python">(x, y, z) = (1, 2, &#39;a string&#39;)
</code></pre>

<p>变量名x, y, z都是引用，内存开辟除了三个空间分别存储1, 2, &#39;a string&#39;，三个变量分别指向这三块地址。由这三个变量构造的元组tuple，<strong>它有三个元素，这三个元素并不是x,y,z这三个变量，而是这三个变量所指向的地址空间里的内容</strong>。如果此时再另x=4,此时在地址空间会另开辟出一块空间存储4，x进而指向这块空间，而元组内的三个值仍保持不变。<br/>
接着我们来解读x, y = y, x， 同样， 它等价于(x, y) = (y, x)。<br/>
运行时，首先构造一个元组(y, x)，然后构造另一个元组(x, y)，接着用元组(y, x)赋值给(x, y)，元组赋值过程从左到右，依次进行。假如x=1,y=2，先令x=y,此时x=2,然后令y=x,y等于1。<br/>
<img src="media/15142967450536/15142979681246.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Unittest与Mock]]></title>
    <link href="https://sparkbye.github.io/myBlog/15142936231027.html"/>
    <updated>2017-12-26T21:07:03+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15142936231027.html</id>
    <content type="html"><![CDATA[
<p><strong>unittest</strong><br/>
python内部自带了一个单元测试的模块，pyUnit也就是我们说的：unittest<br/>
python unittest的框架如下： <br/>
<img src="media/15142936231027/15142937307631.png" alt=""/><br/>
基本使用方法如下：</p>

<ol>
<li>import unittest module</li>
<li>定义一个继承自unittest.TestCase的测试用例类。</li>
<li>定义setUp和tearDown，在每个测试用例前后做一些辅助工作。</li>
<li>定义测试用例，名字需要以test开头。</li>
<li>一个测试用例原则上只测试一个方面，测试目的和测试内容应很明确。主要是调用assertEqual、assertRaises等断言方法判断程序执行结果和预期值是否相符。</li>
<li>调用unittest.main()启动测试</li>
<li>如果测试未通过，会输出相应的错误提示。如果测试全部通过则不显示任何东西，这时可以添加-v参数显示详细信息。</li>
</ol>

<p>这里举个简单的例子说明：<br/>
<img src="media/15142936231027/15142939572020.png" alt=""/></p>

<p>常用的断言：<br/>
<img src="media/15142936231027/15142939778044.png" alt=""/></p>

<p><strong>Mock</strong></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python学习之整数比较]]></title>
    <link href="https://sparkbye.github.io/myBlog/15142090414246.html"/>
    <updated>2017-12-25T21:37:21+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15142090414246.html</id>
    <content type="html"><![CDATA[
<p>最近学习python，发现整数比较时一个有趣的现象：</p>

<pre><code class="language-python">a = 256
b = 256
print id(a)
print id(b)
print(a == b)
print(a is b)
print(id(a) == id(b))
print(id(a) is id(b))
c = 257
d = 257
print id(c)
print id(d)
print(c == d)
print(c is d)
print(id(c) == id(d))
print(id(c) is id(d))
</code></pre>

<p>在pycharm中运行的结果是：</p>

<pre><code>32019104
32019104
True
True
True
False
40550424
40550424
True
True
True
False
</code></pre>

<p>而在Python IDE中运行：</p>

<pre><code class="language-python">&gt;&gt;&gt; a = 256
&gt;&gt;&gt; b = 256
&gt;&gt;&gt; a == b
True
&gt;&gt;&gt; a is b
True
&gt;&gt;&gt; id(a)
32346576L
&gt;&gt;&gt; id(b)
32346576L
&gt;&gt;&gt; c = 257
&gt;&gt;&gt; d = 257
&gt;&gt;&gt; c == d
True
&gt;&gt;&gt; c is d
False
&gt;&gt;&gt; id(c)
39891736L
&gt;&gt;&gt; id(d)
39891712L
</code></pre>

<p>为什么同样是Python2.7.14，得出的结果迥然不同呢？<br/>
在Python中一切都是对象，因此整数也是对象。对象之间比较是否相等可以用==，也可以用is，两者的区别主要是：<br/>
- is比较的是两个对象的id值是否相等，也就是比较俩对象是否为同一个实例对象，是否指向同一个内存地址。<br/>
- ==比较的是两个对象的内容是否相等，默认会调用对象的__eq__()方法。</p>

<p>因此，代码段中<code>a == b</code>很好理解，因为两个对象的值都是256， 而<code>a is b</code>返回True， 说明a和b都是指向同一对象的。但是当值为257时，为什么指向的不是同一个对象呢？</p>

<p><strong>问题一：256和257，差别在哪里？</strong></p>

<p>出于对性能的考虑，Python内部做了很多的优化工作，对于整数对象，Python把一些频繁使用的整数对象缓存起来，保存到一个叫small_ints的链表中，在Python的整个生命周期内，任何需要引用这些整数对象的地方，都不再重新创建新的对象，而是直接引用缓存中的对象。Python把这些可能频繁使用的整数对象规定在范围[-5, 256)之间的小对象放在small_ints中，注意左闭右开。但凡是需要用些小整数时，就从这里面取，不再去临时创建新的对象。因为257不再小整数范围内，因此尽管a和b的值是一样，但是他们在Python内部却是以两个独立的对象存在的，各自为政，互不干涉。</p>

<p>源码位置：<code>Include/intobject.h | Objects/intobject.c</code></p>

<p><strong>小整数对象池：</strong><br/>
小整数对象池就是一个<strong>PyIntObject指针数组</strong></p>

<pre><code class="language-C">#ifndef NSMALLPOSINTS
#define NSMALLPOSINTS 257
#endif
#ifndef NSMALLNEGINTS
#define NSMALLNEGINTS 5
#endif
#if NSMALLNEGINTS + NSMALLPOSINTS &gt; 0
/* References to small integers are saved in this array so that they can be shared. The integers that are saved are those in the range -NSMALLNEGINTS (inclusive) to NSMALLPOSINTS (not inclusive).*/
static PyIntObject *small_ints[NSMALLNEGINTS + NSMALLPOSINTS];
#endif
</code></pre>

<p>其结构如下：<br/>
<img src="media/15142090414246/15142908389467.png" alt=""/></p>

<p><strong>问题二：都是257，is结局为啥不一样？</strong></p>

<p>其实答案就是如此简单：</p>

<p>对于Python而言，存储好的脚本文件（Script file）和在Console中的交互式（interactive）命令，执行方式不同。对于脚本文件，解释器将其当作整个代码块执行，而对于交互性命令行中的每一条命令，解释器将其当作单独的代码块执行。而Python在执行同一个代码块的初始化对象的命令时，会检查是否其值是否已经存在，如果存在，会将其重用（这句话不够严谨，后面会详谈）。所以在给出的例子中，文件执行时（同一个代码块）会把a、b两个变量指向同一个对象；而在命令行执行时，a、b赋值语句分别被当作两个代码块执行，所以会得到两个不同的对象，因而is判断返回False。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Auto Migrate Tool]]></title>
    <link href="https://sparkbye.github.io/myBlog/15142078830298.html"/>
    <updated>2017-12-25T21:18:03+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15142078830298.html</id>
    <content type="html"><![CDATA[
<p>最近需要测试NFV某个node的性能，所以需要Node ei-0单独在一个computer上，所以写了一个脚本：</p>

<pre><code class="language-sh">function echo__blue()      { echo -e &quot;\e[0;34;1m$1\e[0m&quot;;}
function echo__red()       { echo -e &quot;\e[0;31;1m$1\e[0m&quot;;}
function echo__green()     { echo -e &quot;\e[0;32;1m$1\e[0m&quot;;}
function echo__yellow()    { echo -e &quot;\e[0;33;1m$1\e[0m&quot;;}

COMPUTER_LIST=`nova hypervisor-list | awk &#39;{print $4}&#39; | awk &#39;NR&gt;2&#39;`
UE_NODE_NAME=`nova list | grep ei-0 | awk &#39;{print $4}&#39;`
OPTIMAL_COMPUTER=&#39;&#39;
INIT_USED=8.0
for COMPUTER in $COMPUTER_LIST
    do
        CPUS_USED=`nova hypervisor-show $COMPUTER | grep -i &quot;vcpus_used&quot; | awk &#39;{print $4}&#39; | head -1`
        echo__blue &quot;$COMPUTER node&#39;s vcpus_used is :  $CPUS_USED&quot;
        if [[ $(echo &quot;$CPUS_USED == 0.0&quot;|bc) = 1 ]];then
            echo__blue &quot;Greate! $COMPUTER is a optimal computer.&quot;
            OPTIMAL_COMPUTER=$COMPUTER
            break
        elif [[ $(echo &quot;$CPUS_USED &gt; 0.0&quot;|bc) = 1 ]] &amp;&amp; [[ $(echo &quot;$CPUS_USED &lt; 8.0 &quot;|bc) = 1 ]];then
            echo__green &quot;Maybe $COMPUTER is a selectable computer.&quot;
            if [[ $(echo &quot;$CPUS_USED &lt; $INIT_USED&quot;|bc) = 1 ]];then
                INIT_USED=$CPUS_USED
                OPTIMAL_COMPUTER=$COMPUTER
                echo__blue &quot;Now OPTIMAL_COMPUTER is: $COMPUTER.&quot;
            fi
        elif [[ $(echo &quot;$CPUS_USED &gt;= 8.0&quot;|bc) = 1 ]] &amp;&amp; [[ $(echo &quot;$CPUS_USED &lt;= 13.0 &quot;|bc) = 1 ]];then
            echo__red &quot;Maybe $COMPUTER is not a good choice.&quot;
            INSTANCE_NUMBER=`nova hypervisor-servers compute-159 | awk &#39;{print $4}&#39; | awk &#39;NR&gt;2&#39; | awk &#39;{if(length!=0) print $0}&#39; | wc -l`
            USED_RATE=$(echo &quot;$CPUS_USED / $INSTANCE_NUMBER&quot; | bc)
            echo &quot;===========USED_RATE: $USED_RATE=============&quot;
            if [[ $(echo &quot;$USED_RATE &lt; $INIT_USED&quot;|bc) = 1 ]];then
                INIT_USED=$USED_RATE
                echo &quot;===========INIT_USED: $INIT_USED=============&quot;
                OPTIMAL_COMPUTER=$COMPUTER
                echo__blue &quot;Now OPTIMAL_COMPUTER is: $COMPUTER.&quot;
            else
                continue
            fi
        else
            echo__red &quot;This computer node is full.&quot;
        fi
    done
echo &quot;===========Finally the chosen computer is $OPTIMAL_COMPUTER.==============&quot;
echo__green &quot;==============Begin to migrate UE node to $OPTIMAL_COMPUTER.=====================&quot;
nova live-migration $UE_NODE_NAME $OPTIMAL_COMPUTER
UE_NODE_STATE=`nova list | grep ei-0 | awk &#39;{print $10}&#39;`
if [ &quot;Running&quot; != &quot;$UE_NODE_STATE&quot; ];then
    echo &quot;Still migrating, please wait...&quot;
    sleep 5
fi
echo__green &quot;Live migration is successfully.&quot;  
</code></pre>

<p>shell不是经常使用，所以编写过程中才发现浮点数不能判断以及计算的问题，因此记录下，遇到问题可以这么写：</p>

<ul>
<li><p>通过bc</p>

<p>bc是一种任意精度的计算语言，注意是一种语言，它提供了一些语法结构，比如条件判断、循环等，可以说是很强大的，其中一个用途就是用来进行运算以及进制转换。我们经常使用的expr只支持整数运算，对于浮点运算就无能为力了，而且expr不能进行指数运算，而都有bc这些都不再话下。</p>

<pre><code class="language-sh">$(echo &quot;$CPUS_USED &gt; 0.0&quot;|bc) = 1
</code></pre></li>
<li><p>通过dc<br/>
可能你曾经知道有此命令，也可能你还不知道。dc相比与bc要复杂，但是简单操作还是比较简单。简单的说dc是一直压栈操作，和bc一样，它也可以交互使用，或者与echo一起配合使用，它也支持浮点运算。dc后续再作研究。</p></li>
<li><p>expr<br/>
expr竟然也可以？先保存下来，下次再试试：</p>

<pre><code class="language-sh">if [ `expr $a \&gt; $b` -eq 0 ];then
echo $b is bigger
else
echo $a is bigger
fi
</code></pre></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python格式化输出与format函数]]></title>
    <link href="https://sparkbye.github.io/myBlog/15137747318292.html"/>
    <updated>2017-12-20T20:58:51+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15137747318292.html</id>
    <content type="html"><![CDATA[
<p>本文主要整理和汇总python一系列的格式化输出方式：</p>

<p><strong>打印整数</strong></p>

<pre><code class="language-python">print (&quot;I&#39;m number %d&quot; % (20))

&gt;&gt;&gt; I&#39;m number 20  
</code></pre>

<p><strong>打印浮点数(默认)</strong></p>

<pre><code class="language-python">print(&quot;This book&#39;s weight is %f kg&quot; % (0.85))

&gt;&gt;&gt; This book&#39;s height is 0.850000 kg 
</code></pre>

<p><strong>打印浮点数(指定位数)</strong></p>

<pre><code class="language-python">print(&quot;His height is %.2f m&quot; % (1.73))

&gt;&gt;&gt; His height is 1.73 m 
</code></pre>

<p><strong>打印字符串</strong></p>

<pre><code class="language-python">print(&quot;My name is %s&quot; % (&#39;terry&#39;))

&gt;&gt;&gt; My name is terry 
</code></pre>

<p><strong>打印指定占位符宽度</strong></p>

<pre><code class="language-python">print(&quot;Type:%9s Value:%3d Latency:%5.2f&quot; % (&#39;AVP_KMOD&#39;, 44, 0.45))

&gt;&gt;&gt; Type: AVP_KMOD Value: 44 Latency: 0.45 
</code></pre>

<p><strong>打印指定占位符(左对齐)</strong></p>

<pre><code class="language-python">print(&quot;Name:%-10s Age:%-8d Height:%-8.2f&quot;%(&quot;Terry&quot;,25,1.83))

&gt;&gt;&gt; Name:Terry      Age:25       Height:1.83 
</code></pre>

<p><strong>打印指定占位符(前导0)</strong></p>

<pre><code class="language-python">print (&quot;Speed:%010d Rate:%08d Height:%08.2f&quot;%(1000,25,1.83))

&gt;&gt;&gt; Speed:0000001000 Rate:00000025 Height:00001.83 
</code></pre>

<p>在python2.6之后，又增加了一种格式化字符串的函数str.format()，通过{}来代替%。<br/>
用法主要包含以下几类：</p>

<p><strong>通过位置</strong><br/>
字符串的format函数可以接受不限个参数，位置可以不按顺序，可以不用或者用多次:</p>

<pre><code class="language-python">print(&#39;{0},{1},{0}&#39;.format(&#39;aaa&#39;, &#39;bbb&#39;))

&gt;&gt;&gt; aaa,bbb,aaa  
</code></pre>

<p><strong>通过关键字参数</strong></p>

<pre><code class="language-python">print(&#39;{name},{age}&#39;.format(age=18,name=&#39;Terry&#39;))

&gt;&gt;&gt; Terry,18  
</code></pre>

<p><strong>通过对象属性</strong></p>

<pre><code class="language-python">class Person:
    def __init__(self,name,age):
        self.name = name
        self.age = age

    def __str__(self):
        return &#39;This guy is {self.name},he is {self.age} old.&#39;.format(self=self)

print str(Person(&#39;Terry&#39;,18))

&gt;&gt;&gt; This guy is Terry,he is 18 old.
</code></pre>

<p><strong>通过下标</strong></p>

<pre><code class="language-python">person = [&#39;Terry&#39;,18]
print(&#39;{0[0]},{0[1]}&#39;.format(person))

&gt;&gt;&gt; Terry,18
</code></pre>

<p><strong>通过格式</strong><br/>
如上面的前导0：</p>

<pre><code class="language-python">print(&#39;{:0&gt;8}&#39;.format(&#39;189&#39;))
print(&#39;{:&gt;8}&#39;.format(&#39;189&#39;))
print(&#39;{:a&gt;8}&#39;.format(&#39;189&#39;))

&gt;&gt;&gt; 00000189
&gt;&gt;&gt;      189
&gt;&gt;&gt; aaaaa189
</code></pre>

<p>以及浮点数：</p>

<pre><code class="language-python">print(&#39;{:.2f}&#39;.format(321.33345))

&gt;&gt;&gt; 321.33
</code></pre>

<p><strong>其他类型</strong><br/>
主要就是二进制b、十进制d、八进制o、十六进制x:</p>

<pre><code class="language-python">print(&#39;{:b}&#39;.format(46))
print(&#39;{:d}&#39;.format(46))
print(&#39;{:o}&#39;.format(46))
print(&#39;{:x}&#39;.format(46))

&gt;&gt;&gt; 101110
&gt;&gt;&gt; 46
&gt;&gt;&gt; 56
&gt;&gt;&gt; 2e
</code></pre>

<p>此外， 用逗号还能用来做金额的千位分隔符。</p>

<pre><code class="language-python">print(&#39;{:,}&#39;.format(99988844333))

&gt;&gt;&gt; 99,988,844,333
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python中的__name__和__main__]]></title>
    <link href="https://sparkbye.github.io/myBlog/15096259430881.html"/>
    <updated>2017-11-02T20:32:23+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15096259430881.html</id>
    <content type="html"><![CDATA[
<p>对于大多数编译型编程语言来说， 如C、C++、Java等，都会有一个main函数来作为函数的入口。而python则有所不同，它基本属于脚本语言，即从脚本的第一行开始逐行解释运行，没有统一的入口。而&quot;if <strong>name</strong>==&quot;__main__&quot;:&quot; 这一句可以理解为主程序入口；<br/>
python是使用缩进对齐的方式执行的，对于没有缩进的代码，会在载入时自动执行。另外代码除了直接执行外，还可以作为模块调用。为了区分执行和调用，python引入了内置属性：__name__。</p>

<ol>
<li>当代码被执行时，__name__的值为 ‘__main__’</li>
<li>当代码被调用时，如果在模块中，__name__就表示模块名；如果在类中，__name__就表示类名。</li>
</ol>

<p>举个栗子：<br/>
在test_1.py中写入如下代码：</p>

<pre><code>print &quot;I&#39;m the first...&quot;

def test():
    print &quot;I&#39;m the second...&quot;

print __name__
if __name__ == &quot;__main__&quot;:
    test()
    print &quot;I&#39;m the third...&quot;
else:
    print &quot;I&#39;m the last...&quot;
</code></pre>

<p>直接执行test_1.py，会有如下结果：</p>

<pre><code>C:\Python27\python.exe D:/userdata/f7yang/workspace/Python_test/test_libraries/test_study_10/test_1.py
I&#39;m the first...
__main__
I&#39;m the second...
I&#39;m the third...
</code></pre>

<p>可以看出，此时__name__的值为‘__main__’ ，<br/>
而作为调用来执行时：<br/>
<code>from test_1 import test</code><br/>
会有如下结果：</p>

<pre><code>C:\Python27\python.exe D:/userdata/f7yang/workspace/Python_test/test_libraries/test_study_10/test_2.py
I&#39;m the first...
test_1
I&#39;m the last...
</code></pre>

<p>此时__name__的值为test_1，即模块的名字 。 <br/>
其实简而言之，自动执行类似自己称呼自己，调用则类似别人称呼自己，如是而已。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[通过MWeb上传Blog]]></title>
    <link href="https://sparkbye.github.io/myBlog/15095429404216.html"/>
    <updated>2017-11-01T21:29:00+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/15095429404216.html</id>
    <content type="html"><![CDATA[
<h6 id="toc_0">你所需要做的，仅仅是：</h6>

<ol>
<li><p>新增分类 -&gt; CSDN Blog</p></li>
<li><p>右击编辑 -&gt; 高级设置 -&gt; 发布服务， 选择MetaWeblog API</p></li>
</ol>

<p><img src="media/15095429404216/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-01%2021.30.08.png" alt="屏幕快照 2017-11-01 21.30.08"/><br/>
3. 生成网站，并推送到博客</p>

<p><img src="media/15095429404216/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-01%2021.41.21.png" alt="屏幕快照 2017-11-01 21.41.21"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义控件]]></title>
    <link href="https://sparkbye.github.io/myBlog/14991719231835.html"/>
    <updated>2017-07-04T20:38:43+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/14991719231835.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">UIView的封装</h3>

<p>如果一个view内部的子控件比较多，一般会考虑自定义一个view，把它内部子控件的创建屏蔽起来，不让外界关心。外界可以传入对应的模型数据给view，view拿到模型数据后给内部的子控件设置对应的数据继承自系统自带的控件，写一个属于自己的控件。<br/>
* 目的：封装空间内部的细节，不让外界关心</p>

<h3 id="toc_1">UIView的封装有两种方式</h3>

<p>通过纯代码封装：<br/>
1. 新建一个继承UIView的类<br/>
2. 在刚刚新建类的类扩展中添加子控件属性（用weak声明，防止内存泄露）<br/>
3. 在initWithFrame:方法中添加子控件<br/>
4. 在layoutSubviews方法中设置子控件的frame（在该方法中一定要调用[super layoutSubviews]方法）<br/>
5. 提供一个模型属性，重写模型属性的set方法<br/>
6. 在该setter方法中取出模型属性，给对应的子控件赋值<br/>
UIView的封装代码如下：</p>

<pre><code> /**
  *  CustomView.h文件
  */

 // 步骤1 新建一个继承UIView的类
 #import &lt;UIKit/UIKit.h&gt;
 @class CustomModel;
 @interface CustomView : UIView
 // 在这里为了方便，可以自行添加构造方法，方便使用
 // 步骤5 提供一个`模型`属性，重写模型属性的set方法
 @property (nonatomic, strong) CustomModel *model;
 @end
</code></pre>

<pre><code>/**
 *  CustomView.m文件
 */
 #import &quot;CustomView.h&quot;
 #import &quot;CustomModel.h&quot;
 @interface CustomView ()
 // 步骤2 在刚刚新建类的`类扩展`中添加子控件属性（用`weak`声明，防止内存泄露）
 @property (nonatomic, weak) UIImageView *iconImageView;
 @property (nonatomic, weak) UILabel *nameLabel;
 @end

 @implementation CustomView
 // 步骤3 在initWithFrame:方法中添加子控件
 - (instancetype)initWithFrame:(CGRect)frame
 {
     if (self = [super initWithFrame:frame]) {
     // 注意：该处不要给子控件设置frame与数据，可以在这里初始化子控件的属性
     UIImageView *iconImageView = [[UIImageView alloc] init];
     self.iconImageView = iconImageView;
     [self addSubview:iconImageView];

     UILabel *nameLabel = [[UILabel alloc] init];
     // 设置子控件的属性
     nameLabel.textAlignment = NSTextAlignmentCenter;
     nameLabel.font = [UIFont systemFontOfSize:10];
     self.nameLabel = nameLabel;
     [self addSubview:nameLabel];
     }
     return self;
 }

 // 步骤4 在`layoutSubviews`方法中设置子控件的`frame`（在该方法中一定要调用`[super layoutSubviews]`方法）
 - (void)layoutSubviews
 {
     [super layoutSubviews];

     CGFloat iconImageViewX = 0;
     CGFloat iconImageViewY = 0;
     CGFloat iconImageViewW = self.bounds.size.width;
     CGFloat iconImageViewH = 80;
     self.iconImageView.frame = CGRectMake(iconImageViewX, iconImageViewY, iconImageViewW, iconImageViewH);

     CGFloat nameLabelX = 0;
     CGFloat nameLabelY = iconImageViewH;
     CGFloat nameLabelW = iconImageViewW;
     CGFloat nameLabelH = self.bounds.size.height - iconImageViewH;
     self.iconImageView.frame = CGRectMake(nameLabelX, nameLabelY, nameLabelW, nameLabelH);
 }

 // 步骤6 在该`setter`方法中取出模型属性，给对应的子控件赋值
 - (void)setModel:(CustomModel *)model
 {
     _model = model;
     self.iconImageView.image = [UIImage imageNamed:model.icon];
     self.nameLabel.text = model.name;
 }
 @end
</code></pre>

<p>layoutSubviews在以下情况下会被调用：<br/>
1. init初始化不会触发layoutSubviews<br/>
2. addSubview会触发layoutSubviews<br/>
3. 设置view的Frame会触发layoutSubviews，当然前提是frame的值设置前后发生了变化<br/>
4. 滚动一个UIScrollView会触发layoutSubviews<br/>
5. 旋转Screen会触发父UIView上的layoutSubviews事件<br/>
6. 改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件</p>

<p>模型代码如下：</p>

<pre><code> /**
  *  CustomModel.h文件
  */
 #import &lt;Foundation/Foundation.h&gt;

 @interface CustomModel : NSObject
    /**
     *  名字
     */
 @property (nonatomic, copy) NSString *name;
    /**
     *  图片
     */
 @property (nonatomic, copy) NSString *icon;

 + (instancetype)modelWithName:(NSString *)name icon:(NSString *)icon;
 - (instancetype)initWithName:(NSString *)name icon:(NSString *)icon;

 @end
</code></pre>

<pre><code> /**
  *  CustomModel.m文件
  */
 #import &quot;CustomModel.h&quot;

 @implementation CustomModel
 + (instancetype)modelWithName:(NSString *)name icon:(NSString *)icon
 {
     return [[self alloc] initWithName:name icon:icon];
 }

 - (instancetype)initWithName:(NSString *)name icon:(NSString *)icon
 {
     if (self = [super init]) {
         self.name = name;
         self.icon = icon;
     }
     return self;
 }
 @end
</code></pre>

<p>如何使用？只需在控制器代码中执行4个步骤，简单方便：</p>

<pre><code>// 创建自定义的View
 CustomView *customView = [[CustomView alloc] init];
// 设置数据
 CustomModel *model = [CustomModel modelWithName:@&quot;hosea_zhou&quot; icon:@&quot;1&quot;];
 customView.model = model;
// 设置frame
 customView.frame = CGRectMake(100, 100, 67, 100);
// 添加子控件
 [self.view addSubview:customView];
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIButton]]></title>
    <link href="https://sparkbye.github.io/myBlog/14976187081535.html"/>
    <updated>2017-06-16T21:11:48+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/14976187081535.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">UIButton的状态</h3>

<ul>
<li><p>normal(普通状态)</p>

<ul>
<li>默认情况（DEFAULT）</li>
<li>对应的枚举常量： UIControlStateNormal</li>
</ul></li>
<li><p>highlighted (高亮状态)</p>

<ul>
<li>按钮被按下去的时候</li>
<li>对应的枚举常量： UIControlStateHighlighted</li>
</ul></li>
<li><p>disabled (失效状态)</p>

<ul>
<li>如果enabled属性为NO，就是出于disabled状态，代表按钮不可以被点击</li>
<li>对应的枚举变量： UIControlStateDisabled</li>
</ul></li>
</ul>

<h3 id="toc_1">UIButton代码应用</h3>

<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
    UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom];
    button.frame = CGRectMake(100, 300, 200, 100);
    button.backgroundColor = [UIColor redColor];
    [button setTitle:@&quot;Mytest&quot; forState:UIControlStateNormal];
    [button setTitleColor:[UIColor yellowColor] forState:UIControlStateNormal];
    [button setTitle:@&quot;HighLight&quot; forState:UIControlStateHighlighted];
    [button setTitleColor:[UIColor blueColor] forState:UIControlStateHighlighted];
    [button setImage:[UIImage imageNamed:@&quot;makefg&quot;] forState:UIControlStateNormal];

    [self.view addSubview:button];
    [button addTarget:self action:@selector(clickButton:) forControlEvents:UIControlEventTouchDown];
}

-(IBAction)clickButton:(UIButton *)button {
    button.enabled = NO;

}
</code></pre>

<h3 id="toc_2">九宫格布局</h3>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UILable]]></title>
    <link href="https://sparkbye.github.io/myBlog/14966683926548.html"/>
    <updated>2017-06-05T21:13:12+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/14966683926548.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">UILable常见属性</h3>

<p><code>@property(nonatomic, copy) NSString *text;</code><br/>
* 显示文字</p>

<p><code>@property(nonatomic, retain) UIFont *font;</code><br/>
* 显示字体</p>

<p><code>@property(nonatomic, retain) UIColor *textColor;</code><br/>
* 文字颜色</p>

<p><code>@property(nonatomic) NSTextAlignment textAlignment;</code><br/>
* 对齐模式(左对齐，居中对齐， 右对齐)</p>

<p><code>@property(nonatomic) NSInteger numberOfLines;</code><br/>
*文字行数</p>

<p><code>property(nonatomic) NSLineBreakMode lineBreakMode;</code><br/>
* 换行模式</p>

<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
    UILabel *lable = [[UILabel alloc] init];
    
    lable.frame = CGRectMake(50, 300, 300, 200);
    lable.backgroundColor = [UIColor redColor];
    lable.text = @&quot;你这头猪&quot;;
    lable.textAlignment = NSTextAlignmentCenter;
    lable.font = [UIFont systemFontOfSize:20.f];
    lable.font = [UIFont boldSystemFontOfSize:20.f];
    lable.textColor = [UIColor purpleColor];
    lable.shadowOffset = CGSizeMake(4, -10);
    lable.shadowColor = [UIColor blueColor];
    lable.lineBreakMode = NSLineBreakByClipping;
    [self.view addSubview:lable];   
}
</code></pre>

<h3 id="toc_1">UIImageView</h3>

<p><img src="media/14966683926548/14967586896546.jpg" alt=""/></p>

<h3 id="toc_2">毛玻璃效果</h3>

<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
    
    UIImageView *imageView = [[UIImageView alloc] init];
    imageView.backgroundColor = [UIColor redColor];
    imageView.frame = self.view.bounds;
    imageView.image = [UIImage imageNamed:@&quot;IMG_2585&quot;];
    imageView.contentMode = UIViewContentModeScaleAspectFill;
    
    UIToolbar *toolBar = [[UIToolbar alloc] init];
    toolBar.frame = imageView.bounds;
    toolBar.barStyle = UIBarStyleBlack;
    toolBar.alpha = 0.85;
    [imageView addSubview:toolBar];
    
    [self.view addSubview:imageView];
}
</code></pre>

<h3 id="toc_3">四种设置UIImage尺寸的方法</h3>

<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
    UIImageView *imageView = [[UIImageView alloc] init];
    //第一种方式
    imageView.frame = CGRectMake(100, 100, 200, 200);
    imageView.backgroundColor = [UIColor purpleColor];
    imageView.image = [UIImage imageNamed:@&quot;1&quot;];
    imageView.contentMode = UIViewContentModeScaleAspectFill;
    //第二种方式
    UIImage *image = [UIImage imageNamed:@&quot;1&quot;];
    imageView.frame = CGRectMake(0, 0, image.size.width, image.size.height);
    imageView.backgroundColor = [UIColor purpleColor];
    imageView.image = image;
    //第三种方式
    UIImageView *imageView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@&quot;1&quot;]];
    imageView.center = CGPointMake(100, 300);
    //第四种方式
    UIImageView *imageView = [[UIImageView alloc] initWithFrame:(CGRectMake(100, 100, 200, 200))];
    UIImage *image = [UIImage imageNamed:@&quot;1&quot;];
    imageView.image = image;
    
    [self.view addSubview:imageView];
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIView]]></title>
    <link href="https://sparkbye.github.io/myBlog/14965374170472.html"/>
    <updated>2017-06-04T08:50:17+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/14965374170472.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">UIView常见属性</h3>

<p><code>@property(nonatomic, readonly) UIView *superview;</code><br/>
* 获取自己的父控件对象</p>

<p><code>@property(nonatomic, readonly, copy) NSArray *subviews;</code><br/>
* 获取自己的子控件对象</p>

<p><code>@property(nonatomic) NSInteger tag;</code><br/>
* 控件的ID，父控件可以通过tag来找到对应的子控件</p>

<p><code>@property(nonatomic) CGAffineTransform transform;</code><br/>
* 控件的形变属性(可以设置旋转角度、比例缩放、平移等属性)</p>

<p><code>@property(nonatomic) CGRect frame;</code><br/>
* 控件矩形框在父控件中的位置和尺寸</p>

<p><code>@property(nonatomic) CGRect bounds;</code><br/>
* 控件矩形框的位置和尺寸</p>

<p><code>@property(nonatomic) CGPoint center;</code><br/>
* 控件重点的位置</p>

<pre><code>#import &quot;ViewController.h&quot;

@interface ViewController ()

@property(weak, nonatomic) UILabel *lable;

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
    
    UILabel *lable = [[UILabel alloc] init];
    lable.frame = CGRectMake(200, 100, 100, 60);
    lable.backgroundColor = [UIColor redColor];
    [self.view addSubview:lable];
    self.lable = lable;
}

- (IBAction)bounds {
    self.lable.bounds = CGRectMake(0, 0, 200, 40);
}

- (IBAction)center {
    self.lable.center = CGPointMake(self.view.frame.size.width * 0.5, self.view.frame.size.height * 0.5);
}
@end

</code></pre>

<h3 id="toc_1">常见的方法</h3>

<pre><code>-(void)loadView{
    [super loadView];
}

-(void)viewDidLoad{
    [super viewDidLoad];
} 

-(void)didReceiveMemoryWarning{
    [super didReceiveMemoryWarning];
}
</code></pre>

<h5 id="toc_2">viewDidLoad</h5>

<ul>
<li>系统调用</li>
<li>controller的View加载完毕的时候调用</li>
<li>控件的初始化，数据的初始化(懒加载)</li>
</ul>

<h5 id="toc_3">didReceiveMemoryWarning</h5>

<ul>
<li>系统调用</li>
<li>当控制器接受到内存警告调用</li>
<li>去除一些不必要的内存，去除耗时的内存</li>
</ul>

<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
//    NSLog(@&quot;%@&quot;, self.greenView.superview);
//    NSLog(@&quot;%@&quot;, self.greenView.subviews);
//    NSLog(@&quot;%@&quot;, self.view.subviews);
    UISwitch *sw = [[UISwitch alloc] init];
    [sw setHighlighted:true];
    [self.view addSubview:sw];
    [sw removeFromSuperview];
}
</code></pre>

<h5 id="toc_4">addSubview</h5>

<ul>
<li>添加一个子控件
##### removeFromSuperview</li>
<li>从父控件中移除
##### -(UIView *)viewwithTag:(NSInteger)tag;</li>
<li>根据一个tag找出对应的控件</li>
<li>不推荐使用tag

<ul>
<li>tag的效率差</li>
<li>tag容易乱</li>
</ul></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Block]]></title>
    <link href="https://sparkbye.github.io/myBlog/14950245211652.html"/>
    <updated>2017-05-17T20:35:21+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/14950245211652.html</id>
    <content type="html"><![CDATA[
<ul>
<li>Block是一个数据类型；</li>
</ul>

<hr/>

<p>既然block是一个数据类型，那么我们自然可以声明一个block类型的变量，那么block变量中存储的是什么呢？</p>

<hr/>

<blockquote>
<p>block类型的变量中存储的是代码段（可以有参数，可以有返回值）。</p>
</blockquote>

<h3 id="toc_0">如何声明一个block变量</h3>

<pre><code>void (^myBlock1)();
int (^myBlock2)();
int (^myBlock3)(int num1, int num2);
</code></pre>

<h3 id="toc_1">block变量的初始化</h3>

<pre><code>void (^myBlock1)() = ^void(){
        NSLog(@&quot;test&quot;);
    };

int (^myBlock2)() = ^int(){
    int num1 = 10 + 20;
    return num1;
};

int (^myblock3)(int num1, int num2) = ^int(int num1, int num2){
    int num3 = num1 + num2;
    return num3;
};
</code></pre>

<blockquote>
<p>赋值给block变量的代码段必须要符合block变量的要求。</p>
</blockquote>

<pre><code>#import &lt;Foundation/Foundation.h&gt;

int main(int argc, const char * argv[]) {
    
    void (^myBlock1)();
    myBlock1 = ^void(){
        NSLog(@&quot;test&quot;);
    };
    myBlock1();
    
    int (^myBlock2)() = ^int(){
        int num1 = 10 + 20;
        return num1;
    };
    int sum = myBlock2();
    NSLog(@&quot;sum = %d&quot;, sum);
    
    int (^myblock3)(int num1, int num2) = ^int(int num1, int num2){
        int num3 = num1 + num2;
        return num3;
    };
    
    int res = myblock3(10, 100);
    NSLog(@&quot;res = %d&quot;, res);
    
    
    return 0;
}
</code></pre>

<h3 id="toc_2">block的简写</h3>

<ol>
<li>如果代码段没有返回值，那么代码段的void可以省略：</li>
</ol>

<pre><code>//既没有参数也没有返回值的，void和（）都可以省略
void (^myBlock1)() = ^(){
        NSLog(@&quot;test&quot;);
    };
</code></pre>

<ol>
<li>如果代码段没有参数，代码段的（）也可以省略：</li>
</ol>

<pre><code>int (^myBlock2)() = ^int{
    int num1 = 10 + 20;
    return num1;
};
</code></pre>

<ol>
<li> 如果有指定参数，可以只写参数类型而不写参数名称：</li>
</ol>

<pre><code>int (^myblock3)(int, int) = ^int(int num1, int num2){
    int num3 = num1 + num2;
    return num3;
};
</code></pre>

<ol>
<li><p>无论代码段是否有返回值，在写代码段的时候可以不写返回值的类型：</p></li>
</ol>

<ul>
<li>如果代码段省略了返回值，系统会自动确定返回值的类型</li>
<li>如果代码段有返回值，return的数据是什么类型，系统就会认为代码段是什么类型；</li>
</ul>

<pre><code>int (^myBlock4)(int, int) = ^(int num1, int num2){
    int num3 = num1 + num2;
    return num3;
};
    
int result = myBlock4(20, 30);
NSLog(@&quot;result is %d&quot;, result);
</code></pre>

<h3 id="toc_3">简化block的定义</h3>

<ol>
<li>typedef: 将block定义为一个短类型。</li>
</ol>

<pre><code>typedef void (^NewType)();
NewType block1 = ^void(){
    NSLog(@&quot;Hello&quot;);
};
block1();
</code></pre>

<ul>
<li>block内部可以取外部的局部变量和全局变量的值</li>
<li>block内部可以修改全部变量的值，但是无法修改外部局部变量的值</li>
<li>如果需要修改，则局部变量定义方式为__block int num = 100;</li>
</ul>

<h3 id="toc_4">block作为函数的参数</h3>

<ol>
<li>可以在函数中声明一个指定格式的block：</li>
</ol>

<pre><code>void test(void (^block1)()){
    NSLog(@&quot;~~~~~~~~&quot;);
    block1();
    NSLog(@&quot;~~~~~~~~&quot;);
}
</code></pre>

<ol>
<li>使用typedef简化定义：</li>
</ol>

<pre><code>typedef void (^NewBlock) ();

void test_2(NewBlock block2){
    NSLog(@&quot;~~~~~~~~&quot;);
    block2();
    NSLog(@&quot;~~~~~~~~&quot;);
}
</code></pre>

<ol>
<li>如何调用：</li>
</ol>

<pre><code>#import &lt;Foundation/Foundation.h&gt;

typedef void (^NewBlock) ();

void test(void (^block1)()){
    NSLog(@&quot;~~~~~~~~&quot;);
    block1();
    NSLog(@&quot;~~~~~~~~&quot;);
}

void test_2(NewBlock block2){
    NSLog(@&quot;~~~~~~~~&quot;);
    block2();
    NSLog(@&quot;~~~~~~~~&quot;);
}

int main(int argc, const char * argv[]) {

    NewBlock type = ^{
        NSLog(@&quot;hahahah&quot;);
    };
    
    test_2(type);
    
    test_2(^{
        NSLog(@&quot;hahahah&quot;);
    });
    
    return 0;
}
</code></pre>

<p>在这个状态下直接敲回车：<br/>
<img src="media/14950245211652/14955458877653.jpg" alt=""/><br/>
可以转换成：<br/>
<img src="media/14950245211652/14955459281745.jpg" alt=""/><br/>
然后直接补充代码即可：<br/>
<img src="media/14950245211652/14955459527916.jpg" alt=""/></p>

<blockquote>
<p>将block作为函数的参数可以实现什么效果？</p>
</blockquote>

<pre><code>⁃ 可以将调用者所写的代码放到函数的内部去执行；
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[继承与多态]]></title>
    <link href="https://sparkbye.github.io/myBlog/14896702983964.html"/>
    <updated>2017-03-16T21:18:18+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/14896702983964.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">static关键字</h3>

<ol>
<li><p>C语言中的static</p>

<ul>
<li>修饰局部变量</li>
<li>修饰全局变量</li>
<li>修饰函数</li>
</ul></li>
<li><p>OC中的static关键字</p>

<ul>
<li>static不能修饰属性，也不能修饰方法</li>
<li>static可以修饰方法中的局部变量</li>
</ul>

<p>如果方法中的局部变量被static修饰，那么这个变量就会变成静态变量，存储在常量区，当方法执行完毕不会被回收。下次再执行这个方法的时候，直接使用而不用再次声明。<br/>
<img src="media/14896702983964/14896706781899.jpg" alt=""/></p>

<ul>
<li>如果方法的返回值是当前类的对象，那么方法的返回值就写为instanceType</li>
</ul></li>
<li><p>什么时候用到static<br/>
<img src="media/14896702983964/14896717656421.jpg" alt=""/></p></li>
</ol>

<h3 id="toc_1">self关键字</h3>

<ul>
<li>self是一个指针；</li>
<li>在对象方法中self指向当前对象；</li>
<li><p>在类方法中self指向当前类；</p></li>
<li><p>作用：</p>

<ul>
<li>可以显式的访问当前对象的属性； self -&gt; 属性</li>
<li>可以使用self来调用当前对象的其他的对象方法；</li>
</ul></li>
</ul>

<h3 id="toc_2">私有属性和私有方法</h3>

<ul>
<li>将属性定义在@implementation之中和将属性定义在@interface之中并标记为@private唯一的区别： 提示和不提示</li>
<li>都不能被外界访问</li>
<li>方法不写声明，只写实现，那么这个方法就是一个私有方法；</li>
<li>私有方法只能在本类的其他方法中调用，不能被外界调用</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[类方法与对象方法]]></title>
    <link href="https://sparkbye.github.io/myBlog/14885942470746.html"/>
    <updated>2017-03-04T10:24:07+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/14885942470746.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">对象方法</h4>

<ul>
<li>调用：如果想要调用对象方法就必须先创建对象，通过对象名来调用</li>
<li>声明：使用‘-’号</li>
</ul>

<h4 id="toc_1">类方法</h4>

<ul>
<li>调用：类方法的调用不依赖于对象，如果要调用类方法，不需要去创建对象，直接通过类名来调用。</li>
<li>声明：使用‘+’号</li>
<li>在类方法中不能直接访问属性</li>
<li>属性是在对象创建的时候，跟随着对象一起创建在对象之中</li>
<li>类第一次被访问的时候，会做类加载，是把类的带啊存储在代码段</li>
<li>节约空间，提高效率</li>
<li>如果方法不需要直接访问属性，也不需要直接调用其他的对象方法，则可以定义为类方法</li>
</ul>

<h4 id="toc_2">类方法规范</h4>

<ul>
<li>如果写一个类，可以为这个类提供一个和类同名的类方法；</li>
</ul>

<h4 id="toc_3">NSString最常用的类方法</h4>

<p>instanceType 作为返回值 代表返回的是当前类的对象<br/>
<img src="media/14885942470746/14888085422135.jpg" alt=""/><br/>
<img src="media/14885942470746/14888090342021.jpg" alt=""/></p>

<h4 id="toc_4">NSString最常用的对象方法</h4>

<p><img src="media/14885942470746/14888092424014.jpg" alt=""/><br/>
<img src="media/14885942470746/14888094300096.jpg" alt=""/><br/>
<img src="media/14885942470746/14888095451151.jpg" alt=""/><br/>
<img src="media/14885942470746/14888099962376.jpg" alt=""/><br/>
<img src="media/14885942470746/14888102494936.jpg" alt=""/><br/>
<img src="media/14885942470746/14892006938627.jpg" alt=""/><br/>
<img src="media/14885942470746/14892007099870.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[对象与方法]]></title>
    <link href="https://sparkbye.github.io/myBlog/14879879409983.html"/>
    <updated>2017-02-25T09:59:00+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/14879879409983.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">分组导航标记</h4>

<p>标记：<br/>
<code># pragma mark XXXX</code><br/>
分割线：<br/>
<code># pragma mark -</code></p>

<h4 id="toc_1">类的本质</h4>

<ul>
<li>类的本质是我们自定义的一个<strong>数据类型</strong></li>
<li>类可以作为方法的参数:<code>- (void) test : (Dog *)Dog;</code></li>
<li>一个target钟的类无法直接在另外一个target钟访问；</li>
<li>类的属性代表这个类所拥有的东西；</li>
<li>类的方法代表该类所具备的行为和功能；</li>
</ul>

<h4 id="toc_2">对象作为类的属性</h4>

<p><img src="media/14879879409983/14880765155478.jpg" alt=""/></p>

<ul>
<li>属性的本质是变量；</li>
<li>在创建对象的时候，对象中的属性是按照类模板中个规定所创建出来的；</li>
<li>注意_dog是指针变量；如果对象的属性是另一个类的对象，这个属性仅仅是一个指针变量，并没有对象产生；
<img src="media/14879879409983/14880768553779.jpg" alt=""/>
<img src="media/14879879409983/14880772940474.jpg" alt=""/>
如果要再方法中调用当前对象的另一个方法 <code>[self 方法名]</code></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[nil和NULL]]></title>
    <link href="https://sparkbye.github.io/myBlog/14878614535108.html"/>
    <updated>2017-02-23T22:50:53+08:00</updated>
    <id>https://sparkbye.github.io/myBlog/14878614535108.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">NULL</h4>

<ul>
<li>NULL可以作为指针变量的值；</li>
<li>如果一个指针变量的值是NULL值代表这个指针不指向内存中的任何一个空间；</li>
<li>NULL 其实是一个宏</li>
</ul>

<blockquote>
<p>#define NULL ((void *)0)</p>
</blockquote>

<h4 id="toc_1">nil</h4>

<ul>
<li>nil只能作为指针变量的值，代表指针变量不指向内存中的任何一个空间；</li>
<li>nil也是一个宏；</li>
<li>NULL和nil其实是一样的；
<img src="media/14878614535108/14878622149842.jpg" alt=""/>
<img src="media/14878614535108/14878623109287.jpg" alt=""/></li>
<li>一般C指针用NULL，OC的类指针用nil；</li>
</ul>

<blockquote>
<p>如果一个类指针的值为nil，那么通过指针去访问该指针指向的对象的属性，运行会报错；<br/>
该指针去访问指针指向的对象的方法，运行不会报错，但是不会去执行；</p>
</blockquote>

<p><img src="media/14878614535108/14878633255069.jpg" alt=""/></p>

]]></content>
  </entry>
  
</feed>
